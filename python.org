#+TITLE:   python recipes 
#+AUTHOR:  Mohammad Reza Mansouri
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_HEAD: <script src="js/org-info.js"></script>
#+HTML_HEAD: <script src="js/ganalytics.js" async></script>
#+STARTUP: overview

* core types
** lists
*** remove duplicates from a list
#+begin_src python
set([1,1,2,3])
#+end_src

*** sort a list
#+begin_src python
sorted(list)
#+end_src

*** return n largest items from a list
#+begin_src python
import heapq
def two_highest(list_):
    return heapq.nlargest(2, set(list_)) if type(list_) == list else False
#+end_src

** dictionaries
* reflection
** check if a variable is number

#+begin_src python
type(var) == int
type(var) == float

type(var) is int
type(var) is float

isinstance(var,int)
isinstance(var,(int,long))
#+end_src

** check if a variable is string

#+begin_src python
type(var) == str

isinstance(var,str)
#+end_src

* File
** check file exist

#+begin_src python
import os.path
os.path.isfile(fname)    # checks if fname is afile
os.path.exists(file_path) # checks if file_path is file or directory
#+end_src

** read all files in a directory

You can use glob:

#+begin_src python

import glob, os
os.chdir("/mydir")
for file in glob.glob("*.txt"):
    print(file)

or simply os.listdir:

import os
for file in os.listdir("/mydir"):
    if file.endswith(".txt"):
        print(file)
or if you want to traverse directory, use os.walk:

import os
for root, dirs, files in os.walk("/mydir"):
    for file in files:
        if file.endswith(".txt"):
             print(os.path.join(root, file))
#+end_src 

* creating meaningful names 
  
 1. The last part of the name is a very broad summary of the thing. In a few
    cases, this may be all we need; context will supply the rest. We'll suggest
    some typical broad summary categories later.

 2. Use a prefix to narrow this name around your application or problem domain.

 3. If needed, put more narrow and specialized prefixes on this name to clarify
    how it's distinct from other classes, modules, packages, functions, and
    other objects. When in doubt about prefixing, remember how domain names
    work. Think of mail.google.com —the name flows from particular to general.
    There's no magic about the three levels of naming, but it often happens to
    work out that way. Format the name depending on how it's used in Python.
    There are three broad classes of things we'll put names on, which are shown
    as follows:

 *Classes* : A class has a name that summarizes the objects that are part of the
class. These names will (often) use CapitalizedCamelCase . The first letter of a
class name is capitalized to emphasize that it's a class, not an instance of the
class. A class is often a generic concept, rarely a description of a tangible
thing.

 *Objects* : A name for an object usually uses snake_case - all lowercase with
multiple _ characters between words. In Python, this includes variables,
functions, modules, packages, parameters, attributes of objects, methods of
classes, and almost everything else.

 *Script and module files* : These are really the OS resources, as seen by
Python. Therefore, a filename should follow the conventions for Python objects,
using letters, the _ characters and ending with the .py extension. It's
technically possible to have pretty wild and free filenames. Filenames that
don't follow Python rules can be difficult to use as a module or package.

* Doing currency calculations
When working with currency, we should always use the decimal module. If we try
to use Python's built-in float values, we'll have problems with rounding and
truncation of numbers.

#+begin_src python

>>> from decimal import Decimal
>>> tax_rate = Decimal('7.25')/Decimal(100)
>>> purchase_amount = Decimal('2.95')
>>> tax_rate * purchase_amount
Decimal('0.213875')

#+end_src 

* string
** slicing string 
  
 #+begin_src python
 >>> title = "Recipe 5: Rewriting, and the Immutable String"
 >>> colon_position = title.index(':')
 >>> discard_text, post_colon_text = title[:colon_position], title[colon_position+1:]
 >>> discard_text
 'Recipe 5'
 >>> post_colon_text
 ' Rewriting, and the Immutable String'
 #+end_src 

** slicing using ~partition()~:

 #+begin_src python
 >>> pre_colon_text, _, post_colon_text = title.partition(':')
 >>> pre_colon_text
 'Recipe 5'
 >>> post_colon_text
 ' Rewriting, and the Immutable String'
 #+end_src 

** updating a string with a replacement

 #+begin_src python
 >>> title = "Recipe 5: Rewriting, and the Immutable String"
 >>> post_colon_text = post_colon_text.replace(' ', '_')
 >>> post_colon_text = post_colon_text.replace(',', '_')
 >>> post_colon_text
 '_Rewriting__and_the_Immutable_String'
 #+end_src 

** Removing extra punctuation marks

 In many cases, there are some additional steps we might follow. We often want to
 remove leading and trailing _ characters. We can use strip() for this:

 #+begin_src python
 >>> post_colon_text = post_colon_text.strip('_')
 #+end_src 

** tell if a string is numeric

 #+begin_src python
 >>> 'some word'.isnumeric()
 False
 >>> '1298'.isnumeric()
 True
 #+end_src 

* numbers
** tell if float number is finite with integral value

#+begin_src python
>>> 1.5.is_integer()
False
>>> 1.0.is_integer()
True
>>> 1.4142135623730951.is_integer()
False
#+end_src 

* classes
** calling Superclass constructors

If subclass constructors need to guarantee that superclass construction-time
logic runs, too, they generally must call the superclass’s __init__ method
explicitly through the class:

#+begin_src python
class Super:
    def __init__(self, x):
        ...default code...

class Sub(Super):
    def __init__(self, x, y):
        Super.__init__(self, x)             # Run superclass __init__
        ...custom code...                   # Do my init actions

I = Sub(1, 2)
#+end_src 

** class interface
   
#+begin_src python
class Super:
    def method(self):
        print('in Super.method')           # Default behavior
    def delegate(self):
        self.action()                      # Expected to be defined

class Inheritor(Super):                    # Inherit method verbatim
    pass

class Replacer(Super):                     # Replace method completely
    def method(self):
        print('in Replacer.method')

class Extender(Super):                     # Extend method behavior
    def method(self):
        print('starting Extender.method')
        Super.method(self)
        print('ending Extender.method')

class Provider(Super):                     # Fill in a required method
    def action(self):
        print('in Provider.action')

if __name__ == '__main__':
    for klass in (Inheritor, Replacer, Extender):
        print('\n' + klass.__name__ + '...')
        klass().method()
    print('\nProvider...')
    x = Provider()
    x.delegate()
#+end_src 

#+begin_src 

% python specialize.py

Inheritor...
in Super.method

Replacer...
in Replacer.method

Extender...
starting Extender.method
in Super.method
ending Extender.method

Provider...
in Provider.action

#+end_src 

** Abstract superclass

abstract superclass—a class that expects parts of its behavior to be provided by
its subclasses. If an expected method is not defined in a subclass, Python
raises an undefined name exception when the inheritance search fails.

* Arguments and options

#+begin_src python 
#!/usr/bin/env python

import sys

arguments = sys.argv
print("The number of arguments passed was: %s") % (str(len(arguments)))
i=0
for x in arguments:
    print("The %d argument is %s") % (i,x)
    i+=1
#+end_src 

* =compat.py= and python version 2.x and 3.x

in some situations, developers may not want to include additional dependencies
in some small packages. A common practice is the additional module that gathers
all the compatibility code, usually named compat.py. Here is an example of such
a compat module taken from the python-gmaps project
(https://github.com/swistakm/python-gmaps):

#+begin_src python

# -*- coding: utf-8 -*-
import sys

if sys.version_info < (3, 0, 0):
    import urlparse  # noqa

    def is_string(s):
        return isinstance(s, basestring)

else:
    from urllib import parse as urlparse  # noqa

    def is_string(s):
        return isinstance(s, str)
#+end_src 

Such a compat.py module is popular even in projects that depends on Six for 2/3
compatibility because it is a very convenient way to store code that handles
compatibility with different versions of packages used as dependencies.
* Acronyms
PyPA (Python Packaging Authority)
* Useful Resources 

Awesome-python (https://github.com/vinta/awesome-python), which includes a
curated list of popular packages and frameworks

Python Weekly (http://www.pythonweekly.com/) is a popular newsletter that
delivers to its subscribers dozens of new and interesting Python packages and
resources every week




