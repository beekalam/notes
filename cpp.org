* code organization
** Making Sure a Header File Gets Included Only Once

#define a macro in your header file, and include only the contents of the header
file if the macro hasn't already been defined. You can use this combination of
the #ifndef, #define, and #endif preprocessor directives, as I did in Example:

#+begin_src cpp
#ifndef MYCLASS_H_  _ // #include guards
#define MYCLASS_H_  _
// Put everything here...
#endif // MYCLASS_H_  
#+end_src

** Ensuring You Have Only One Instance of a Variable Across Multiple Source Files

Declare and define the variable in a single implementation file in the usual
manner, and use the extern keyword in other implementation files where you
require access to that variable at runtime. Often, this means including the
extern declarations in a header file that is used by all implementation files
that need access to the global variable.

#+begin_src cpp
// global.h
#ifndef GLOBAL_H__ // See Recipe 2.0
#define GLOBAL_H__
#include <string>
extern int x;
extern std::string s;
#endif
// global.cpp
#include <string>
int x = 7;
std::string s = "Kangaroo";
// main.cpp
#include <iostream>
#include "global.h"
using namespace std; 
int main( ) {
   cout << "x = " << x << endl;
   cout << "s = " << s << endl;
}
#+end_src

The extern keyword is a way of telling the compiler that the actual storage for
a variable is allocated somewhere else. extern tells the linker that the
variable it qualifies is somewhere in another object file, and that the linker
needs to go find it when creating the final executable or library. If the linker
never finds the extern variable you have declared, or it finds more than one of
definition for it, you will get a link error.

** Reducing #includes with Forward Class Declarations
Use forward class declarations where possible to avoid unnecessary compilation
dependencies.
#+begin_src cpp
// myheader.h
#ifndef MYHEADER_H_  _
#define MYHEADER_H_  _
class A; // No need to include A's header
class B {
   public:
      void f(const A& a);
   // ...
   private:
      A* a_;
};
#endif
#+end_src
A forward class declaration is a way to ignore details that you don't need to be concerned with.

Sadly, you can't always use forward declarations. The class B in Example 2-4
only uses pointers or references to A, so I can get away with a forward
declaration. However, if I use an A member function or variable, or if I have an
object of type A--and not just a pointer or reference to onein my definition for
the class B, suddenly my forward declaration is insufficient.

* numbers
** Converting a String to a Numeric Type
The functions strtol, strtod, and strtoul, defined in <cstdlib>, convert a
null-terminated character string to a long int, double, or unsigned long.

#+begin_src cpp
#include <iostream>
#include <string>
#include <cstdlib>
using namespace std;
long hex2int(const string& hexStr) {
   char *offset;
   if (hexStr.length( ) > 2) {
      if (hexStr[0] == '0' && hexStr[1] == 'x') {
         return strtol(hexStr.c_str( ), &offset, 0);
      }
   }
   return strtol(hexStr.c_str( ), &offset, 16);
}
int main( ) {
   string str1 = "0x12AB";
   cout << hex2int(str1) << endl;
   string str2 = "12AB";
   cout << hex2int(str2) << endl;
   string str3 = "QAFG";
   cout << hex2int(str3) << endl;
}
#+end_src

The strtol function is a bit odd in that it allows you to use two different
methods for specifying a base of 16; you can either pass 16 as a third parameter
to the function; or, you can pass 0 for the base while preceding your string
with the characters 0x (just as you would do for specifying hexadecimal
constants in your code; however, remember that with strtol, you're passing a
string).

using boost
#+begin_src cpp
#include <iostream>
#include <string>
#include <boost/lexical_cast.hpp>
using namespace std;
int main( ) {
   string str1 = "750";
   string str2 = "2.71";
   string str3 = "0x7FFF";
   try {
      cout << boost::lexical_cast<int>(str1) << endl;
      cout << boost::lexical_cast<double>(str2) << endl;
      cout << boost::lexical_cast<int>(str3) << endl;
   }
   catch (boost::bad_lexical_cast& e) {
      cerr << "Bad cast: " << e.what( ) << endl;
   }
}
#+end_src
** Converting Numbers to Strings
#+begin_src cpp
#include <iostream>
#include <iomanip>
#include <string>
#include <sstream>
using namespace std;
int main( ) {
   stringstream ss;
   ss << "There are " << 9 << " apples in my cart.";
   cout << ss.str( ) << endl;  // stringstream::str( ) returns a string
                              // with the contents
   ss.str("");                   // Empty the string
   ss << showbase << hex << 16;  // Show the base in hexadecimal
   cout << "ss = " << ss.str( ) << endl;
   ss.str("");
   ss << 3.14;
   cout << "ss = " << ss.str( ) << endl;
}

//The output of Example 3-3 looks like this: 
//There are 9 apples in my cart.
//ss = 0x10
//ss = 3.14
#+end_src 

using boost
#+begin_src cpp
#include <iostream>
#include <boost/format.hpp>
using namespace std;
using boost::format;
using boost::io::str;
using boost::io::format_error;
int main( ) {
   try {
      format f("There are %1% ways %2% %3% %4%");
      f % 3;
      f % "to" % "do" % "this.";
      cout << f << endl;
      f.clear( ); // Clear buffers to format something else
      f.parse("Those cost $%d.");
      f % 50;
      cout << f << endl;
      int x = 11256099;
      string strx = str(format("%x") % x);
      cout << strx << endl;
   }
   catch (format_error &e) {
      cout << e.what( ) << endl;
   }
}

//Here's what you see when you run this program: 
//There are 3 ways to do this.
//Those cost $50.
//abc123
#+end_src 

#+begin_src cpp

string NumberToString ( int Number )
{
   ostringstream ss;
   ss << Number;
   return ss.str();
}

#+end_src

* conditional compilation using predifined macros

#+begin_src cpp
#ifdef _WIN32
# include <windows.h>
#else // Not Windows - assume we're on Unix
# include <sys/stat.h>
#endif
bool is_directory(const char* path)
{
#ifdef _WIN32
      // Windows implementation
#else
      // Unix implementation
#endif
}
#+end_src

On Windows, all the toolsets except the Cygwin port of GCC define the macro
_WIN32; macros defined automatically in this way are known as predefined macros.

* QT

* read from STDIN
** read number

#+begin_src c++
int n, m;
cin >> n >> m;  //reads a string "6 6" ==> n = 6, m = 6
#+end_src

* useful resources
https://cpbook.net/#downloads
https://github.com/ksaveljev/UVa-online-judge
http://felix-halim.net/
https://github.com/dipu-bd/UVA-Arena
http://dipu-bd.github.io/UVA-Arena/
https://github.com/search?q=topic%3Aproblem-solving&type=Repositories
** professinal cpp book code
http://www.wrox.com/WileyCDA/WroxTitle/Professional-C-3rd-Edition.productCd-1118858050,descCd-DOWNLOAD.html
