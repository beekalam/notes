#+TITLE:   c++ recipes 
#+AUTHOR:  Mohammad Reza Mansouri
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+STARTUP: overview

* code organization
** Making Sure a Header File Gets Included Only Once

#define a macro in your header file, and include only the contents of the header
file if the macro hasn't already been defined. You can use this combination of
the #ifndef, #define, and #endif preprocessor directives, as I did in Example:

#+begin_src cpp
#ifndef MYCLASS_H_  _ // #include guards
#define MYCLASS_H_  _
// Put everything here...
#endif // MYCLASS_H_  
#+end_src

** Ensuring You Have Only One Instance of a Variable Across Multiple Source Files

Declare and define the variable in a single implementation file in the usual
manner, and use the extern keyword in other implementation files where you
require access to that variable at runtime. Often, this means including the
extern declarations in a header file that is used by all implementation files
that need access to the global variable.

#+begin_src cpp
// global.h
#ifndef GLOBAL_H__ // See Recipe 2.0
#define GLOBAL_H__
#include <string>
extern int x;
extern std::string s;
#endif
// global.cpp
#include <string>
int x = 7;
std::string s = "Kangaroo";
// main.cpp
#include <iostream>
#include "global.h"
using namespace std; 
int main( ) {
   cout << "x = " << x << endl;
   cout << "s = " << s << endl;
}
#+end_src

The extern keyword is a way of telling the compiler that the actual storage for
a variable is allocated somewhere else. extern tells the linker that the
variable it qualifies is somewhere in another object file, and that the linker
needs to go find it when creating the final executable or library. If the linker
never finds the extern variable you have declared, or it finds more than one of
definition for it, you will get a link error.

** Reducing #includes with Forward Class Declarations
Use forward class declarations where possible to avoid unnecessary compilation
dependencies.
#+begin_src cpp
// myheader.h
#ifndef MYHEADER_H_  _
#define MYHEADER_H_  _
class A; // No need to include A's header
class B {
   public:
      void f(const A& a);
   // ...
   private:
      A* a_;
};
#endif
#+end_src
A forward class declaration is a way to ignore details that you don't need to be concerned with.

Sadly, you can't always use forward declarations. The class B in Example 2-4
only uses pointers or references to A, so I can get away with a forward
declaration. However, if I use an A member function or variable, or if I have an
object of type A--and not just a pointer or reference to onein my definition for
the class B, suddenly my forward declaration is insufficient.

* numbers
** Converting a String to a Numeric Type
The functions strtol, strtod, and strtoul, defined in <cstdlib>, convert a
null-terminated character string to a long int, double, or unsigned long.

#+begin_src cpp
#include <iostream>
#include <string>
#include <cstdlib>
using namespace std;
long hex2int(const string& hexStr) {
   char *offset;
   if (hexStr.length( ) > 2) {
      if (hexStr[0] == '0' && hexStr[1] == 'x') {
         return strtol(hexStr.c_str( ), &offset, 0);
      }
   }
   return strtol(hexStr.c_str( ), &offset, 16);
}
int main( ) {
   string str1 = "0x12AB";
   cout << hex2int(str1) << endl;
   string str2 = "12AB";
   cout << hex2int(str2) << endl;
   string str3 = "QAFG";
   cout << hex2int(str3) << endl;
}
#+end_src

The strtol function is a bit odd in that it allows you to use two different
methods for specifying a base of 16; you can either pass 16 as a third parameter
to the function; or, you can pass 0 for the base while preceding your string
with the characters 0x (just as you would do for specifying hexadecimal
constants in your code; however, remember that with strtol, you're passing a
string).

using boost
#+begin_src cpp
#include <iostream>
#include <string>
#include <boost/lexical_cast.hpp>
using namespace std;
int main( ) {
   string str1 = "750";
   string str2 = "2.71";
   string str3 = "0x7FFF";
   try {
      cout << boost::lexical_cast<int>(str1) << endl;
      cout << boost::lexical_cast<double>(str2) << endl;
      cout << boost::lexical_cast<int>(str3) << endl;
   }
   catch (boost::bad_lexical_cast& e) {
      cerr << "Bad cast: " << e.what( ) << endl;
   }
}
#+end_src
** Converting Numbers to Strings
 #+begin_src cpp
 #include <iostream>
 #include <iomanip>
 #include <string>
 #include <sstream>
 using namespace std;
 int main( ) {
    stringstream ss;
    ss << "There are " << 9 << " apples in my cart.";
    cout << ss.str( ) << endl;  // stringstream::str( ) returns a string
                               // with the contents
    ss.str("");                   // Empty the string
    ss << showbase << hex << 16;  // Show the base in hexadecimal
    cout << "ss = " << ss.str( ) << endl;
    ss.str("");
    ss << 3.14;
    cout << "ss = " << ss.str( ) << endl;
 }

 //The output of Example 3-3 looks like this: 
 //There are 9 apples in my cart.
 //ss = 0x10
 //ss = 3.14
 #+end_src 

 using boost
 #+begin_src cpp
 #include <iostream>
 #include <boost/format.hpp>
 using namespace std;
 using boost::format;
 using boost::io::str;
 using boost::io::format_error;
 int main( ) {
    try {
       format f("There are %1% ways %2% %3% %4%");
       f % 3;
       f % "to" % "do" % "this.";
       cout << f << endl;
       f.clear( ); // Clear buffers to format something else
       f.parse("Those cost $%d.");
       f % 50;
       cout << f << endl;
       int x = 11256099;
       string strx = str(format("%x") % x);
       cout << strx << endl;
    }
    catch (format_error &e) {
       cout << e.what( ) << endl;
    }
 }

 //Here's what you see when you run this program: 
 //There are 3 ways to do this.
 //Those cost $50.
 //abc123
 #+end_src 

 #+begin_src cpp

 string NumberToString ( int Number )
 {
    ostringstream ss;
    ss << Number;
    return ss.str();
 }

 #+end_src
** int to char string using sprintf
#+begin_src cpp
char string[BUFF_LENGTH];
sprintf(string, "%d", number);
#+end_src
** Testing Whether a String Contains a Valid Number
#+begin_src cpp
#include <iostream>
#include <boost/lexical_cast.hpp>
using namespace std;
using boost::lexical_cast;
using boost::bad_lexical_cast;
template<typename T>
bool isValid(const string& num) {
   bool res = true;
   try {
      T tmp = lexical_cast<T>(num);
   }
   catch (bad_lexical_cast &e) {
      res = false;
   }
   return(res);
}
void test(const string& s) {
   if (isValid<int>(s))
      cout << s << " is a valid integer." << endl;
   else
      cout << s << " is NOT a valid integer." << endl;
   if (isValid<double>(s))
      cout << s << " is a valid double." << endl;
   else
      cout << s << " is NOT a valid double." << endl;
   if (isValid<float>(s))
      cout << s << " is a valid float." << endl;
   else
      cout << s << " is NOT a valid float." << endl;
}
int main( ) {
   test("12345");
   test("1.23456");
   test("-1.23456");
   test(" - 1.23456");
   test("+1.23456");
   test("  1.23456  ");
   test("asdf");
}
#+end_src 

Here's the output from this example: 

12345 is a valid integer.
12345 is a valid double.
12345 is a valid float.
1.23456 is NOT a valid integer.
1.23456 is a valid double.
1.23456 is a valid float.
-1.23456 is NOT a valid integer.
-1.23456 is a valid double.
-1.23456 is a valid float.
 - 1.23456 is NOT a valid integer.
 - 1.23456 is NOT a valid double.
 - 1.23456 is NOT a valid float.
+1.23456 is NOT a valid integer.
+1.23456 is a valid double.
+1.23456 is a valid float.
  1.23456   is NOT a valid integer.
  1.23456   is NOT a valid double.
  1.23456   is NOT a valid float.
asdf is NOT a valid integer.
asdf is NOT a valid double.
asdf is NOT a valid float.


Discussion

The lexical_cast function template converts a value from one type to another. It is declared like this: 
template<typename Target, typename Source>
Target lexical_cast(Source arg)

Source is the type of the original variable, and Target is the type of the
variable being converted to. So, for example, if you want to convert from a
string to an int, you invoke lexical_cast like this:

int i = lexical_cast<int>(str); // str is a string

lexical_cast does the parsing and attempts the conversion. If the conversion is
not possible, it throws a bad_lexical_cast exception. In Example 3-5, I only
want to test for validity and don't need to keep the destination variable
around, so I return true if no exception is thrown, false otherwise.

You only have to supply the first template argument to lexical_cast because it's
a function template, which means the compiler can deduce the type of the
function argument and use that as the second template argument. Explaining this
distinction is more confusing than illustrating it, so let me use a code
example. Instead of invoking lexical_cast as in the previous code snippet, you
could do this:

int i = lexical_cast<int, string>(str);

This means the same thing, but you don't have to supply the string argument because the compiler can see that str is a string and figure out the rest. 

If you are going to write a similar wrapper function to test for validity and
return true or false, you would do well to write it as a function template. This
way, you only have to write it once with a parameterized type, and a different
version will be instantiated each time you use it on a different type.
** Comparing Floating-Point Numbers with Bounded Accuracy
Problem

You need to compare floating-point values, but you only want tests for equality,
greater-than, or less-than to be concerned with a limited number of digits. For
example, you want 3.33333 and 3.33333333 to show as being equal when comparing
to a precision of .0001.

Solution

Write your own comparison functions that take a parameter that bounds the
accuracy of the comparison. Example 3-6 shows the basic technique for such
comparison functions.

Example 3-6. Comparing floating-point numbers

#+begin_src cpp
#include <iostream>
#include <cmath>    // for fabs( )
using namespace std;
bool doubleEquals(double left, double right, double epsilon) {
   return (fabs(left - right) < epsilon);
}
bool doubleLess(double left, double right, double epsilon,
                bool orequal = false) {
   if (fabs(left - right) < epsilon) {
      // Within epsilon, so considered equal
      return (orequal);
   }
   return (left < right);
}
bool doubleGreater(double left, double right, double epsilon,
                   bool orequal = false) {
   if (fabs(left - right) < epsilon) {
      // Within epsilon, so considered equal
      return (orequal);
   }
   return (left > right);
}
int main( ) {
   double first = 0.33333333;
   double second = 1.0 / 3.0;
   cout << first << endl;
   cout << second << endl;
    
   // Straight equalify test. Fails when you wouldn't want it to.
   // (boolalpha prints booleans as "true" or "false")
   cout << boolalpha << (first == second) << endl;
   // New equality. Passes as scientific app probably wants.
   cout << doubleEquals(first, second, .0001) << endl;
   // New less-than
   cout << doubleLess(first, second, .0001) << endl;
   // New Greater-than
   cout << doubleGreater(first, second, .0001) << endl;
   // New less-than-or-equal-to
   cout << doubleLess(first, second, .0001, true) << endl;
   // New greater-than-or-equal-to
   cout << doubleGreater(first, second, .0001, true) << endl;
}
#+end_src 

Following is the output from this example: 
0.333333
0.333333
false
true
false
false
true
true


Discussion

The code in Example 3-6 starts with two values, 0.33333333 and whatever the
computer figures 1.0 / 3.0 to be. It prints out the two values using the default
formatting in cout; these two values appear to be the same at 0.333333. However,
when you compare these two values, they are indeed different. The value of 1.0 /
3.0 has more significant digits than 0.33333333, and therefore, as far as your
machine is concerned, the two numbers are not equal. In some applications,
however, you may want these two numbers to show up as being the same. The way to
handle this is to write three of your own functions for comparing double values:
doubleLess, doubleEquals, and doubleGreater, each of which takes two double
values as parameters. Additionally, the doubleLess and doubleGreater take an
additional parameter, which, when TRue, causes the functions to behave as
less-than-or-equal or greater-than-or-equal, respectively. To make these
functions handle a precision, first consider the doubleEquals function. Instead
of testing for equality, this function tests whether the difference between the
two numbers is within a user-specified epsilon. (The example uses .0001 for the
epsilon.) If so, then the function returns TRue, meaning the values are indeed
the same. Thus, the values 0.3333, 0.33333, 0.333333, 0.33333333333, and
0.33333323438 would all show up as being equal. To handle a less-than and
greater-than operation, first test whether the numbers are equal within the
range, as you did in the doubleEquals function. If so, then return true if you
want to include equality in the test, and false if you don't. Otherwise, do a
straight comparison.
** Parsing a String Containing a Number in Scientific Notation
Problem

You have a string containing a number in scientific notation, and you want to store the number's value in a double variable. 

Solution

The most direct way to parse a scientific notation number is by using the C++ library's built-in stringstream class declared in <sstream>, as you can see in Example 3-7. 
Example 3-7. Parsing a number in scientific notation
#+begin_src cpp
#include <iostream>
#include <sstream>
#include <string>
using namespace std;
double sciToDub(const string& str) {
   stringstream ss(str);
   double d = 0;
   ss >> d;
   if (ss.fail( )) {
      string s = "Unable to format ";
      s += str;
      s += " as a number!";
      throw (s);
   }
   return (d);
}
int main( ) {
   try {
      cout << sciToDub("1.234e5") << endl;
      cout << sciToDub("6.02e-2") << endl;
      cout << sciToDub("asdf") << endl;
   }
   catch (string& e) {
      cerr << "Whoops: " << e << endl;
   }
}
#+end_src 
Following is the output from this code: 
123400
0.0602
Whoops: Unable to format asdf as a number!


Discussion 
The stringstream class is, not surprisingly, a string that behaves
like a stream. It is declared in <sstring>. If you need to parse a string that
contains a number in scientific notation (see also Recipe 3.2), a stringstream
will do the job nicely. The standard stream classes already "know" how to parse
numbers, so don't waste your time reimplementing this logic if you don't have
to. In Example 3-7, I wrote the simple function sciToDub that takes a string
parameter and returns the double it contains, if it is valid. Within sciToDub, I
use the stringstream as follows:

#+begin_src cpp
stringstream ss(str); // Construct from a string
double d = 0;
ss >> d;
if (ss.fail( )) {
   string s = "Unable to format ";
   s += str;
   s += " as a number!";
   throw (s);
}
return (d);
#+end_src 

The most important part here is that all you have to do is use the right-shift
operator (>>) to read from the string stream into a double, just as you would
read from cin.

Well, that's not all you have to do. If there's a value in the stringstream that
can't be written to the variable on the right side of the >> operator, the fail
bit is set on the stream. You can check this bit using the fail member function
(this is actually a member function of basic_ios, which is a superclass of
stringstream). Additionally, the variable on the righthand side of the >>
operator is unchanged if the operation fails.

In the interest of being generic, however, you can avoid having to write
separate versions of sciToDub for ints, floats, doubles, and whatever else you
want to convert to by writing a function template. Consider this new version:
#+begin_src cpp
template<typename T>
T strToNum(const string& str) {
   stringstream ss(str);
   T tmp;
   ss >> tmp;
   if (ss.fail( )) {
      string s = "Unable to format ";
      s += str;
      s += " as a number!";
      throw (s);
   }
     
   return (tmp);
}
#+end_src 

Now, if you want to convert a string to a numeric type, you can do it like this:
#+begin_src cpp
double d = strToNum<double>("7.0");
float f = strToNum<float>("7.0");
int i = strToNum<int>("7.0");
#+end_src 
You can also make the type of character a template parameter, but that's straightforward to do, so I'll leave it as an exercise for you.

** Converting Between Numeric Types
   
Problem 
You have number of one type and you need to convert it to another, such
as an int to a short or a vice versa, but you want to catch any overflow or
underflow errors at runtime.

Solution

Use Boost's numeric_cast class template. It performs runtime checks that throw
an exception of type bad_numeric_cast if you will overflow or underflow the
variable where you are putting a value. Example 3-8 shows you how to do this.
Example 3-8. Safe numeric conversions
#+begin_src cpp
#include <iostream>
#include <boost/cast.hpp>
using namespace std;
using boost::numeric_cast;
using boost::bad_numeric_cast;
int main( ) {
   // Integer sizes
   try {
      int i = 32767;
      short s = numeric_cast<short>(i);
      cout << "s = " << s << endl;
      i++; // Now i is out of range (if sizeof(short) is 2)
      s = numeric_cast<short>(i);
   }
   catch (bad_numeric_cast& e) {
      cerr << e.what( ) << endl;
   }
   try {
      int i = 300;
      unsigned int ui = numeric_cast<unsigned int>(i);
      cout << ui << endl; // Fine
      i *= -1;
      ui = numeric_cast<unsigned int>(i); // i is negative!
   }
   catch (bad_numeric_cast& e) {
      cerr << e.what( ) << endl;
   }
   try {
      double d = 3.14;
      int i = numeric_cast<int>(d);
      i = numeric_cast<int>(d); // This shaves off the 0.14!
      cout << i << endl;  // i = 3
   }
   catch (bad_numeric_cast& e) {
      cerr << e.what( ) << endl;
   }
}
#+end_src 

Discussion

You are probably aware of the fact that the basic C++ types have different
sizes. The C++ standard has strict specifications for the relative size of
typesan int is always at least as big as a short int--but it does not specify
the absolute size. What this means is that if you take a long int and try to put
it in a short, or attempt to put an int in an unsigned int, then you may be
losing information about the value in the source variable, such as its sign or
even part of its numeric value.

Just knowing that this causes problems isn't enough. You may have tight space
requirements and not want to use four bytes for a long when you can get away
with two for a short (if your platform, in fact, uses these sizes, which are
common but not guaranteed). Because of your space requirements, you want to try
to store values in the smallest possible type. If you want to live dangerously
but want a safety net, use Boost's numeric_cast to catch loss of data at
runtime.

The syntax of numeric_cast is straightforward. It is a function template, declared like this: 
#+begin_src cpp
template<typename Target, typename Source>
inline Target numeric_cast(Source arg)
#+end_src 

It is just like lexical_cast if you have already read Recipe 3.1 or Recipe 3.3.
There are two template parameters, Target and Source, which represent the types
of the originating and destination values. Because it is a function template,
the compiler can deduce the type of the Source template argument, so you only
need to supply Target, like this:

#+begin_src cpp
int i = 32767;
short s = numeric_cast<short>(i);
#+end_src 

short is the template argument for the Target parameter. The compiler figures
out that Source is an int because i is an int.

In this case, I am cramming an int into a short. On my (Windows XP) system, an
int is four bytes and a short is two. A short is signed, which means that I have
15 bits to represent a number with and, therefore, 32,767 is the maximum
positive value it can hold. The above piece of code goes off without a hitch,
but when I increment i by one, it goes beyond the range of a short:

#+begin_src cpp
i++;
s = numeric_cast<short>(i); // Uh-oh
#+end_src 

And a bad_numeric_cast exception is thrownyou get the idea. See the rest of
Example 3-8: numeric_cast also catches underflow if you try to assign a negative
signed value to an unsigned type.

But numeric_cast doesn't solve all of your problems. If you try to put a
floating-point value in a nonfloating-point type, you lose everything to the
right of the decimal, correct? numeric_cast does not help you with this, so
don't think that it can rescue you from all of your risky endeavors. For
example, consider this piece of code from Example 3-8:
#+begin_src cpp
double d = 3.14;
int i = numeric_cast<int>(d);  // Ouch

// No exception is thrown here. But it is if you try this: 

double d = -3.14;
unsigned int ui = numeric_cast<unsigned in>(d);

#+end_src 

Because regardless of you tossing everything to the right of the decimal point out the window, you are losing the negative sign, and that is bad. 

** Getting the Minimum and Maximum Values for a Numeric Type

Problem

You need to know the largest or smallest representable value for your platform for a numeric type, such as an int or double. 

Solution

Use the numeric_limits class template in the <limits> header to get, among other
things, the largest and smallest possible values for a numeric type (see Example
3-9). Example 3-9. Getting numeric limits
#+begin_src cpp
#include <iostream>
#include <limits>
using namespace std;
template<typename T>
void showMinMax( ) {
   cout << "min: " << numeric_limits<T>::min( ) << endl;
   cout << "max: " << numeric_limits<T>::max( ) << endl;
   cout << endl;
}
int main( ) {
   cout << "short:" << endl;
   showMinMax<short>( );
   cout << "int:" << endl;
   showMinMax<int>( );
   cout << "long:" << endl;
   showMinMax<long>( );
   cout << "float:" << endl;
   showMinMax<float>( );
   cout << "double:" << endl;
   showMinMax<double>( );
   cout << "long double:" << endl;
   showMinMax<long double>( );
   cout << "unsigned short:" << endl;
   showMinMax<unsigned short>( );
   cout << "unsigned int:" << endl;
   showMinMax<unsigned int>( );
   cout << "unsigned long:" << endl;
   showMinMax<unsigned long>( );
}
#+end_src 

Here's what I get on Windows XP using Visual C++ 7.1: 

short:
min: -32768
max: 32767
int:
min: -2147483648
max: 2147483647
long:
min: -2147483648
max: 2147483647
float:
min: 1.17549e-038
max: 3.40282e+038
double:
min: 2.22507e-308
max: 1.79769e+308
long double:
min: 2.22507e-308
max: 1.79769e+308
unsigned short:
min: 0
max: 65535
unsigned int:
min: 0
max: 4294967295
unsigned long:
min: 0
max: 4294967295


Discussion

Example 3-9 shows a simple example for getting the minimum and maximum values
for native numeric types. The numeric_limits class template has a specialization
for all of the built-in types, including both numeric and nonnumeric. The
standard mandates that all of the types I use in Example 3-9 have a
specialization of numeric_limits, as well as these:

bool
char
signed char
unsigned char
wchar_t

min and max are static member functions in numeric_limits that return the highest and lowest values for the type parameter you pass in. 

* strings
** reverse string
#+begin_src c++
std::reverse(s.begin(), s.end());
// In the event that you want to copy the string to another string, but backward, use reverse iterators, like this: 
std::string s = "Los Angeles";
std::string rs;
rs.assign(s.rbegin( ), s.rend( ));
#+end_src

** Padding a String
You need to "pad," or fill, a string with a number of occurrences of some
character to a certain width. For example, you may want to pad the string
"Chapter 1" to 20 characters wide with periods, so that it looks like "Chapter
1...........".

*Solution*
Use string's insert and append member functions to pad a string with characters on the beginning or end. For example, to pad the end of a string to 20 characters with X's: 
#+begin_src c++
std::string s = "foo";
s.append(20 - s.length( ), 'X');

//To pad the string at the beginning instead: 

s.insert(s.begin( ), 20 - s.length( ), 'X');

#+end_src 

*A generic pad function template*

#+begin_src c++
#include <string>
#include <iostream>
using namespace std;
// The generic approach
template<typename T>
void pad(basic_string<T>& s,
         typename basic_string<T>::size_type n, T c) {
   if (n > s.length( ))
      s.append(n - s.length( ), c);
}
int main( ) {
   string  s  = "Appendix A";
   wstring ws = L"Acknowledgments"; // The "L" indicates that
                                     // this is a wide char
   pad(s, 20, '*');                  // literal
   pad(ws, 20, L'*');
   // cout  << s  << std::endl;  // You shouldn't be able to
   wcout << ws << std::endl;     // run these at the same time
}
#+end_src

** trimmin a string
*** trim
 #+begin_src c++
 #include <string>
 #include <iostream>
 // The approach for narrow character strings
 void rtrim(std::string& s, char c) {
    if (s.empty( ))
       return;
    std::string::iterator p;
    for (p = s.end( ); p != s.begin( ) && *--p == c;);
    if (*p != c)
       p++;
    s.erase(p, s.end( ));
 }
 int main( )
 {
    std::string s = "zoo";
    rtrim(s, 'o');
    std::cout << s << '\n';
 }
 #+end_src

 *A generic version of rtrim*
 #+begin_src c++

 #include <string>
 #include <iostream>
 using namespace std;
 // The generic approach for trimming single
 // characters from a string
 template<typename T>
 void rtrim(basic_string<T>& s, T c)
 {
    if (s.empty( ))
       return;
    typename basic_string<T>::iterator p;
    for (p = s.end( ); p != s.begin( ) && *--p == c;);
    if (*p != c)
       p++;
    s.erase(p, s.end( ));
 }
 int main( ) {
    string s = "Great!!!!";
    wstring ws = L"Super!!!!";
    rtrim(s, '!');
    rtrim(ws, L'!');
    cout << s << '\n';
    wcout << ws << L'\n';
 }
 #+end_src

*** trimming whitespace
 #+begin_src c++
 #include <string>
 #include <iostream>
 #include <cctype>
 #include <cwctype>
 using namespace std;
 template<typename T, typename F>
 void rtrimws(basic_string<T>& s, F f) {
    if (s.empty( ))
       return;
    typename basic_string<T>::iterator p;
    for (p = s.end( ); p != s.begin( ) && f(*--p););
      if (!f(*p))
       p++;
    s.erase(p, s.end( ));
 }
 // Overloads to make cleaner calling for client code
 void rtrimws(string& s) {
    rtrimws(s, isspace);
 }
 void rtrimws(wstring& ws) {
    rtrimws(ws, iswspace);
 }
 int main( ) {
    string s = "zing        ";
    wstring ws = L"zong        ";
    rtrimws(s);
    rtrimws(ws);
    cout << s << "|\n";
    wcout << ws << L"|\n";
 }
 #+end_src

*** Using Boost's string trim functions
#+begin_src c++
#include <iostream>
#include <string>
#include <boost/algorithm/string.hpp>
using namespace std;
using namespace boost;
int main( ) {
   string s1 = "      leading spaces?";
   trim_left(s1); // Trim the original
   string s2 = trim_left_copy(s1); // Trim, but leave original intact
   cout << "s1 = " << s1 << endl;
   cout << "s2 = " << s2 << endl;
   s1 = "YYYYboostXXX";
   s2 = trim_copy_if(s1, is_any_of("XY")); // Use a predicate to
   trim_if(s1, is_any_of("XY"));
   cout << "s1 = " << s1 << endl;
   cout << "s2 = " << s2 << endl;
   s1 = "1234 numbers 9876";
   s2 = trim_copy_if(s1, is_digit( ));
   cout << "s1 = " << s1 << endl;
   cout << "s2 = " << s2 << endl;
   // Nest calls to trim functions if you like
   s1 = "    ****Trim!***     ";
   s2 = trim_copy_if(trim_copy(s1), is_any_of("*"));
   cout << "s1 = " << s1 << endl;
   cout << "s2 = " << s2 << endl;
}
#+end_src

** access by position
#+begin_src c++
cout << *(input.end() - 2);     //gets value second to the last character in the string
cout << *(input.end() - 1);     //gets value of the last character in the string
#+end_src

cout <<
** convert number in character to equivalent int vice versa
#+begin_src cpp
//convert character to int
int res = '8'  - '0';
//convert number to character
char res = (char)('0'+ value);
#+end_src
** prepepend a character to string
   use the + operator
#+begin_src cpp
strin res;
res = 'c' + res;
//prepend a number to the end of a string
res = (char)('0' + 1) + res;
#+end_src
** Getting the Length of a String

#+begin_src cpp
#include <string>
#include <iostream>
using namespace std;
int main( ) {
   string s = "";
   string sr = "";
   sr.reserve(9000);
   cout << "s.length    = " << s.length( )   << '\n';
   cout << "s.capacity  = " << s.capacity( ) << '\n';
   cout << "s.max_size  = " << s.max_size( ) << '\n';
   cout << "sr.length   = " << sr.length( )   << '\n';
   cout << "sr.capacity = " << sr.capacity( ) << '\n';
   cout << "sr.max_size = " << sr.max_size( ) << '\n';
   for (int i = 0; i < 10000; ++i) {
      if (s.length( ) == s.capacity( )) {
         cout << "s reached capacity of " << s.length( )
              << ", growing...\n";
      }
      if (sr.length( ) == sr.capacity( )) {
         cout << "sr reached capacity of " << sr.length( )
              << ", growing...\n";
      }
      s += 'x';
      sr += 'x';
   }
}
#+end_src 

With Visual C++ 7.1, my output looks like this: 
s.length    = 0
s.capacity  = 15
s.max_size  = 4294967294
sr.length   = 0
sr.capacity = 9007
sr.max_size = 4294967294
s reached capacity of 15, growing...
s reached capacity of 31, growing...
s reached capacity of 47, growing...
s reached capacity of 70, growing...
s reached capacity of 105, growing...
s reached capacity of 157, growing...
s reached capacity of 235, growing...
s reached capacity of 352, growing...
s reached capacity of 528, growing...
s reached capacity of 792, growing...
s reached capacity of 1188, growing...
s reached capacity of 1782, growing...
s reached capacity of 2673, growing...
s reached capacity of 4009, growing...
s reached capacity of 6013, growing...
sr reached capacity of 9007, growing...
s reached capacity of 9019, growing...
** reverse string
To reverse a string "in place," without using a temporary string, use the reverse function template in the <algorithm> header: 
std::reverse(s.begin( ), s.end( ));

reverse works simply enough: it modifies the range you give it such that it is
in the opposite order that it was originally. It takes linear time. In the event
that you want to copy the string to another string, but backward, use reverse
iterators, like this:

std::string s = "Los Angeles";
std::string rs;
rs.assign(s.rbegin( ), s.rend( ));

rbegin and rend return reverse iterators. Reverse iterators behave as though
they are looking at the sequence backward. rbegin returns an iterator that
points to the last element, and rend returns an iterator that points to one
before the first; this is exactly opposite of what begin and end do.
** splitting a string
#+begin_src cpp
#include <string>
#include <vector>
#include <functional>
#include <iostream>
using namespace std;
void split(const string& s, char c,
           vector<string>& v) {
   string::size_type i = 0;
   string::size_type j = s.find(c);
   while (j != string::npos) {
      v.push_back(s.substr(i, j-i));
      i = ++j;
      j = s.find(c, j);
      if (j == string::npos)
         v.push_back(s.substr(i, s.length( )));
   }
}
int main( ) {
   vector<string> v;
   string s = "Account Name|Address 1|Address 2|City";
   split(s, '|', v);
   for (int i = 0; i < v.size( ); ++i) {
      cout << v[i] << '\n';
   }
}
#+end_src 

Making the example above a function template that accepts any kind of character
is trivial; just parameterize the character type and change references to string
to basic_string<T>:

#+begin_src cpp
template<typename T>
void split(const basic_string<T>& s, T c,
           vector<basic_string<T> >& v) {
   basic_string<T>::size_type i = 0;
   basic_string<T>::size_type j = s.find(c);
   while (j != basic_string<T>::npos) {
      v.push_back(s.substr(i, j-i));
      i = ++j;
      j = s.find(c, j);
      if (j == basic_string<T>::npos)
         v.push_back(s.substr(i, s.length( )));
   }
}
#+end_src
** splitting string with boost
   #+begin_src cpp
#include <iostream>
#include <string>
#include <list>
#include <boost/algorithm/string.hpp>
using namespace std;
using namespace boost;
int main( ) {
   string s = "one,two,three,four";
   list<string> results;
   split(results, s, is_any_of(","));  // Note this is boost::split
   for (list<string>::const_iterator p = results.begin( );
        p != results.end( ); ++p) {
      cout << *p << endl;
   }
}
#+end_src

** Tokenizing a String

Problem
You need to break a string into pieces using a set of delimiters. 

Use the find_first_of and first_first_not_of member functions on basic_string to
iterate through the string and alternately locate the next tokens and
non-tokens. Example 4-12 presents a simple StringTokenizer class that does just
that.

Example 4-12. A string tokenizer
#+begin_src cpp
#include <string>
#include <iostream>
using namespace std;
// String tokenizer class.
class StringTokenizer {
public:
   StringTokenizer(const string& s, const char* delim = NULL) :
      str_(s), count_(-1), begin_(0), end_(0) {
      if (!delim)
         delim_ = " \f\n\r\t\v";  //default to whitespace
      else
         delim_ = delim;
      // Point to the first token
      begin_ = str_.find_first_not_of(delim_);
      end_ = str_.find_first_of(delim_, begin_);
   }
   size_t countTokens( ) {
     if (count_ >= 0) // return if we've already counted
       return(count_);
     string::size_type n = 0;
     string::size_type i = 0;
     for (;;) {
        // advance to the first token
        if ((i = str_.find_first_not_of(delim_, i)) == string::npos)
           break;
        // advance to the next delimiter
        i = str_.find_first_of(delim_, i+1);
        n++;
        if (i == string::npos)
          break;
     }
     return (count_ = n);
   }
   bool hasMoreTokens( ) {return(begin_ != end_);}
   void nextToken(string& s) {
     if (begin_ != string::npos && end_ != string::npos) {
        s = str_.substr(begin_, end_-begin_);
        begin_ = str_.find_first_not_of(delim_, end_);
        end_ = str_.find_first_of(delim_, begin_);
     }
     else if (begin_ != string::npos && end_ == string::npos)
     {
        s = str_.substr(begin_, str_.length( )-begin_);
        begin_ = str_.find_first_not_of(delim_, end_);
     }
   }
private:
   StringTokenizer( ) {};
   string delim_;
   string str_;
   int count_;
   int begin_;
   int end_;
};
int main( ) {
   string s = " razzle dazzle giddyup ";
   string tmp;
   StringTokenizer st(s);
   cout << "there are " << st.countTokens( ) << " tokens.\n";
   while (st.hasMoreTokens( )) {
      st.nextToken(tmp);
      cout << "token = " << tmp << '\n';
   }
}
#+end_src
** Joining a Sequence of Strings
#+begin_src cpp
#include <string>
#include <vector>
#include <iostream>
using namespace std;
void join(const vector<string>& v, char c, string& s) {
   s.clear( );
   for (vector<string>::const_iterator p = v.begin( );
        p != v.end( ); ++p) {
      s += *p;
      if (p != v.end( ) - 1)
        s += c;
   }
}
int main( ) {
   vector<string> v;
   vector<string> v2;
   string s;
   v.push_back(string("fee"));
   v.push_back(string("fi"));
   v.push_back(string("foe"));
   v.push_back(string("fum"));
   join(v, '/', s);
   cout << s << '\n';
}
#+end_src
 
** Joining C-style strings

#+begin_src cpp
#include <string>
#include <iostream>
const static int MAGIC_NUMBER = 4;
template<typename T>
void join(T* arr[], size_t n, T c, std::basic_string<T>& s) {
   s.clear( );
   for (int i = 0; i < n; ++i) {
      if (arr[i] != NULL)
         s += arr[i];
      if (i < n-1)
         s += c;
   }
}
int main( ) {
   std::wstring ws;
   wchar_t* arr[MAGIC_NUMBER];
   arr[0] = L"you";
   arr[1] = L"ate";
   arr[2] = L"my";
   arr[3] = L"breakfast";
   join(arr, MAGIC_NUMBER, L'/', ws);
}
#+end_src

** number to string using std::to_string

#+begin_src cpp
#include <iostream>
#include <string>
 
int main() 
{
    double f = 23.43;
    double f2 = 1e-9;
    double f3 = 1e40;
    double f4 = 1e-40;
    double f5 = 123456789;
    std::string f_str = std::to_string(f);
    std::string f_str2 = std::to_string(f2); // Note: returns "0.000000"
    std::string f_str3 = std::to_string(f3); // Note: Does not return "1e+40".
    std::string f_str4 = std::to_string(f4); // Note: returns "0.000000"
    std::string f_str5 = std::to_string(f5);
    std::cout << "std::cout: " << f << '\n'
              << "to_string: " << f_str  << "\n\n"
              << "std::cout: " << f2 << '\n'
              << "to_string: " << f_str2 << "\n\n"
              << "std::cout: " << f3 << '\n'
              << "to_string: " << f_str3 << "\n\n"
              << "std::cout: " << f4 << '\n'
              << "to_string: " << f_str4 << "\n\n"
              << "std::cout: " << f5 << '\n'
              << "to_string: " << f_str5 << '\n';
}
#+end_src 

** string uppercase
*** #1
#+begin_src cpp
#include <iostream>
#include <cctype>
#include <algorithm>
using namespace std;
int main() {
   cout << "string: ";
   char s[256];
   cin.get(s, 256);
   string str = s;

  for(int i  = 0 ;i < str.size(); ++i)
        str[i] = toupper(str[i]);
        
     cout << str << endl;
   return 0;
}
#+end_src
*** #2

#+begin_src cpp
std::transform(str.begin(), str.end(),str.begin(), ::toupper);
#+end_src

** erase part of a string
#+begin_src cpp
#include <iostream>
#include <algorithm>
#include <string>
 
int main()
{
    std::string s = "This is an example";
    std::cout << s << '\n';
 
    s.erase(0, 5); // Erase "This "
    std::cout << s << '\n';
 
    s.erase(std::find(s.begin(), s.end(), ' ')); // Erase ' '
    std::cout << s << '\n';
 
    s.erase(s.find(' ')); // Trim from ' ' to the end of the string
    std::cout << s << '\n';
}
#+end_src

** remove a character from string
#+begin_src cpp
#include <algorithm>
#include <string>
#include <iostream>
#include <cctype>
 
int main()
{
    std::string str1 = "Text with some   spaces";
    str1.erase(std::remove(str1.begin(), str1.end(), ' '),
               str1.end());
    std::cout << str1 << '\n';
 
    std::string str2 = "Text\n with\tsome \t  whitespaces\n\n";
    str2.erase(std::remove_if(str2.begin(), 
                              str2.end(),
                              [](char x){return std::isspace(x);}),
               str2.end());
    std::cout << str2 << '\n';
}
#+end_src

* array
** allocate 2D array dynamically
#+begin_src cpp
int** ary = new int*[rowCount];
for(int i = 0; i < rowCount; ++i)
    ary[i] = new int[colCount];
#+end_src

* conditional compilation using predifined macros

#+begin_src cpp
#ifdef _WIN32
# include <windows.h>
#else // Not Windows - assume we're on Unix
# include <sys/stat.h>
#endif
bool is_directory(const char* path)
{
#ifdef _WIN32
      // Windows implementation
#else
      // Unix implementation
#endif
}
#+end_src

On Windows, all the toolsets except the Cygwin port of GCC define the macro
_WIN32; macros defined automatically in this way are known as predefined macros.

* QT
* vector
** minimum and max element of  vector
#+begin_src c++
// min_element/max_element example
#include <iostream>     // std::cout
#include <algorithm>    // std::min_element, std::max_element

bool myfn(int i, int j) { return i<j; }

struct myclass {
  bool operator() (int i,int j) { return i<j; }
} myobj;

int main () {
  int myints[] = {3,7,2,5,6,4,9};

  // using default comparison:
  std::cout << "The smallest element is " << *std::min_element(myints,myints+7) << '\n';
  std::cout << "The largest element is "  << *std::max_element(myints,myints+7) << '\n';

  // using function myfn as comp:
  std::cout << "The smallest element is " << *std::min_element(myints,myints+7,myfn) << '\n';
  std::cout << "The largest element is "  << *std::max_element(myints,myints+7,myfn) << '\n';

  // using object myobj as comp:
  std::cout << "The smallest element is " << *std::min_element(myints,myints+7,myobj) << '\n';
  std::cout << "The largest element is "  << *std::max_element(myints,myints+7,myobj) << '\n';

  return 0;
}
#+end_src

** sort
#+begin_src c++
// sort algorithm example
#include <iostream>     // std::cout
#include <algorithm>    // std::sort
#include <vector>       // std::vector

bool myfunction (int i,int j) { return (i<j); }

struct myclass {
  bool operator() (int i,int j) { return (i<j);}
} myobject;

int main () {
  int myints[] = {32,71,12,45,26,80,53,33};
  std::vector<int> myvector (myints, myints+8);               // 32 71 12 45 26 80 53 33

  // using default comparison (operator <):
  std::sort (myvector.begin(), myvector.begin()+4);           //(12 32 45 71)26 80 53 33

  // using function as comp
  std::sort (myvector.begin()+4, myvector.end(), myfunction); // 12 32 45 71(26 33 53 80)

  // using object as comp
  std::sort (myvector.begin(), myvector.end(), myobject);     //(12 26 32 33 45 53 71 80)

  // print out content:
  std::cout << "myvector contains:";
  for (std::vector<int>::iterator it=myvector.begin(); it!=myvector.end(); ++it)
    std::cout << ' ' << *it;
  std::cout << '\n';

  return 0;
}
#+end_src

** sum elements
#+begin_src cpp
#inculde <numeric>
sum_of_elements = std::accumulate(vector.begin(), vector.end(),0);
#+end_src
Be careful with accumulate. The last argument's type is used not just for the
initial value, but for the type of the result as well. If you put an int there,
it will accumulate ints even if the vector has float. If you are summing
floating-point numbers, change 0 to 0.0 or 0.0f

#+begin_src cpp
std::for_each(vector.begin(), vector.end(), [&](int n){
    sum_of_elements +=n;
});
// using range based loops
for(auto& n : vector)
   sum_of_elements += n;
#+end_src

** Bounds-checking on vectors

The characters in a basic_string are stored in a buffer that is a contiguous
chunk of memory with a static size. The buffer a string uses is an arbitrary
size initially, and as characters are added to the string, the buffer fills up
until its capacity is reached. When this happens, the buffer grows, sort of.
Specifically, a new buffer is allocated with a larger size, the characters are
copied from the old buffer to the new buffer, and the old buffer is deleted.

You can find out the size of the buffer (not the number of characters it
contains, but its maximum size) with the capacity member function. If you want
to manually set the capacity to avoid needless buffer copies, use the reserve
member function and pass it a numeric argument that indicates the desired buffer
size. There is a maximum size on the possible buffer size though, and you can
get that by calling max_size. You can use all of these to observe memory growth
in your standard library implementation.

#+begin_src cpp
#include <iostream>
#include <vector>
#include <exception>
using namespace std;
int main( ) {
   char carr[] = {'a', 'b', 'c', 'd', 'e'};
   cout << carr[100000] << '\n'; // Whoops, who knows what's going
                                 // to happen
   vector<char> v;
   v.push_back('a');
   v.push_back('b');
   v.push_back('c');
   v.push_back('d');
   v.push_back('e');
   try {
      cout << v.at(10000) << '\n'; // at checks bounds and throws
   } catch(out_of_range& e) {      // out_of_range if it's invalid
      cerr << e.what( ) << '\n';
   }
}
#+end_src 

If you catch out_of_range, defined in <stdexcept>, you can deal with invalid indexes in a meaningful way.

* algorithms
** algorithms collections
#+begin_src cpp
#include <algorithm>
#include <cstdio>
#include <string>
#include <vector>
using namespace std;

typedef struct {
  int id;
  int solved;
  int penalty;
} team;

bool icpc_cmp(team a, team b) {
  if (a.solved != b.solved) // can use this primary field to decide sorted order
    return a.solved > b.solved;   // ICPC rule: sort by number of problem solved
  else if (a.penalty != b.penalty)       // a.solved == b.solved, but we can use
                                       // secondary field to decide sorted order
    return a.penalty < b.penalty;       // ICPC rule: sort by descending penalty
  else                        // a.solved == b.solved AND a.penalty == b.penalty
    return a.id < b.id;                      // sort based on increasing team ID
}

int main() {
  int *pos, arr[] = {10, 7, 2, 15, 4};
  vector<int> v(arr, arr + 5);          // another way to initialize vector
  vector<int>::iterator j;

  // sort descending with vector
  sort(v.rbegin(), v.rend());        // example of using 'reverse iterator'
  for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
    printf("%d ", *it);                     // access the value of iterator
  printf("\n");
  printf("==================\n");

  // sort descending with integer array
  sort(arr, arr + 5);                                          // ascending
  reverse(arr, arr + 5);                                    // then reverse
  for (int i = 0; i < 5; i++)
    printf("%d ", arr[i]);
  printf("\n");
  printf("==================\n");

  random_shuffle(v.begin(), v.end());          // shuffle the content again
  for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
    printf("%d ", *it);
  printf("\n");
  printf("==================\n");
  partial_sort(v.begin(), v.begin() + 2, v.end());     // partial_sort demo
  for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
    printf("%d ", *it);
  printf("\n");
  printf("==================\n");

  // sort ascending
  sort(arr, arr + 5);                           // arr should be sorted now
  for (int i = 0; i < 5; i++)                            // 2, 4, 7, 10, 15
    printf("%d ", arr[i]);
  printf("\n");
  sort(v.begin(), v.end());                // sorting a vector, same output
  for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
    printf("%d ", *it);
  printf("\n");
  printf("==================\n");

  // multi-field sorting example, suppose we have 4 ICPC teams
  team nus[4] = { {1, 1, 10}, 
                  {2, 3, 60},
                  {3, 1, 20},
                  {4, 3, 60} };

  // without sorting, they will be ranked like this:
  for (int i = 0; i < 4; i++)
    printf("id: %d, solved: %d, penalty: %d\n",
           nus[i].id, nus[i].solved, nus[i].penalty);

  sort(nus, nus + 4, icpc_cmp);         // sort using a comparison function
  printf("==================\n");
  // after sorting using ICPC rule, they will be ranked like this:
  for (int i = 0; i < 4; i++)
    printf("id: %d, solved: %d, penalty: %d\n",
           nus[i].id, nus[i].solved, nus[i].penalty);
  printf("==================\n");

  // there is a trick for multi-field sorting if the sort order is "standard"
  // use "chained" pair class in C++ and put the highest priority in front
  typedef pair < int, pair < string, string > > state;
  state a = make_pair(10, make_pair("steven", "grace"));
  state b = make_pair(7, make_pair("steven", "halim"));
  state c = make_pair(7, make_pair("steven", "felix"));
  state d = make_pair(9, make_pair("a", "b"));
  vector<state> test;
  test.push_back(a);
  test.push_back(b);
  test.push_back(c);
  test.push_back(d);
  for (int i = 0; i < 4; i++)
    printf("value: %d, name1 = %s, name2 = %s\n", test[i].first,
    ((string)test[i].second.first).c_str(), ((string)test[i].second.second).c_str());
  printf("==================\n");
  sort(test.begin(), test.end());   // no need to use a comparison function
  // sorted ascending based on value, then based on name1,
  // then based on name2, in that order!
  for (int i = 0; i < 4; i++)
    printf("value: %d, name1 = %s, name2 = %s\n", test[i].first,
      ((string)test[i].second.first).c_str(), ((string)test[i].second.second).c_str());
  printf("==================\n");

  // binary search using lower bound
  pos = lower_bound(arr, arr + 5, 7);                              // found
  printf("%d\n", *pos);
  j = lower_bound(v.begin(), v.end(), 7);
  printf("%d\n", *j);

  pos = lower_bound(arr, arr + 5, 77);                         // not found
  if (pos - arr == 5) // arr is of size 5 -> 
                      //    arr[0], arr[1], arr[2], arr[3], arr[4]
                      // if lower_bound cannot find the required value,
                      //   it will set return arr index +1 of arr size, i.e.
                      //   the 'non existent' arr[5]
                      // thus, testing whether pos - arr == 5 blocks 
                      //   can detect this "not found" issue
    printf("77 not found\n");
  j = lower_bound(v.begin(), v.end(), 77);
  if (j == v.end()) // with vector, lower_bound will do the same:
                    //   return vector index +1 of vector size
                    // but this is exactly the position of vector.end()
                    //   so we can test "not found" this way
    printf("77 not found\n");
  printf("==================\n");

  // useful if you want to generate permutations of set
  next_permutation(arr, arr + 5); // 2, 4, 7, 10, 15 -> 2, 4, 7, 15, 10
  next_permutation(arr, arr + 5); // 2, 4, 7, 15, 10 -> 2, 4, 10, 7, 15
  for (int i = 0; i < 5; i++)
    printf("%d ", arr[i]);
  printf("\n");

  next_permutation(v.begin(), v.end());
  next_permutation(v.begin(), v.end());
  for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
    printf("%d ", *it);
  printf("\n");
  printf("==================\n");

  // sometimes these two useful simple macros are used
  printf("min(10, 7) = %d\n", min(10, 7));
  printf("max(10, 7) = %d\n", max(10, 7));

  return 0;
}
#+end_src
** stack queue and dequeue(double ended queue) example
#+begin_src cpp
#include <cstdio>
#include <stack>
#include <queue>
using namespace std;

int main() {
  stack<char> s;
  queue<char> q;
  deque<char> d;

  printf("%d\n", s.empty());                   // currently s is empty, true (1)
  printf("==================\n");
  s.push('a');
  s.push('b');
  s.push('c');
  // stack is LIFO, thus the content of s is currently like this:
  // c <- top
  // b
  // a
  printf("%c\n", s.top());                                   // output 'c'
  s.pop();                                                  // pop topmost
  printf("%c\n", s.top());                                   // output 'b'
  printf("%d\n", s.empty());        // currently s is not empty, false (0)
  printf("==================\n");

  printf("%d\n", q.empty());             // currently q is empty, true (1)
  printf("==================\n");
  while (!s.empty()) {                   // stack s still has 2 more items
    q.push(s.top());                          // enqueue 'b', and then 'a'
    s.pop();
  }
  q.push('z');                                        // add one more item
  printf("%c\n", q.front());                                  // prints 'b'
  printf("%c\n", q.back());                                   // prints 'z'

  // output 'b', 'a', then 'z' (until queue is empty), according to the insertion order above
  printf("==================\n");
  while (!q.empty()) {
    printf("%c\n", q.front());                      // take the front first
    q.pop();                             // before popping (dequeue-ing) it
  }

  printf("==================\n");
  d.push_back('a');
  d.push_back('b');
  d.push_back('c');
  printf("%c - %c\n", d.front(), d.back());               // prints 'a - c'
  d.push_front('d');
  printf("%c - %c\n", d.front(), d.back());               // prints 'd - c'
  d.pop_back();
  printf("%c - %c\n", d.front(), d.back());               // prints 'd - b'
  d.pop_front();
  printf("%c - %c\n", d.front(), d.back());               // prints 'a - b'

  return 0;
}
#+end_src
** map & set example
#+begin_src cpp
#include <cstdio>
#include <map>
#include <set>
#include <string>
using namespace std;

int main() {
  char name[20];
  int value;
  // note: there are many clever usages of this set/map
  // that you can learn by looking at top coder's codes
  // note, we don't have to use .clear() if we have just initialized the set/map
  set<int> used_values; // used_values.clear();
  map<string, int> mapper; // mapper.clear();

  // suppose we enter these 7 name-score pairs below
  /*
  john 78
  billy 69
  andy 80
  steven 77
  felix 82
  grace 75
  martin 81
  */
  mapper["john"] = 78;   used_values.insert(78);
  mapper["billy"] = 69;  used_values.insert(69);
  mapper["andy"] = 80;   used_values.insert(80);
  mapper["steven"] = 77; used_values.insert(77);
  mapper["felix"] = 82;  used_values.insert(82);
  mapper["grace"] = 75;  used_values.insert(75);
  mapper["martin"] = 81; used_values.insert(81);

  // then the internal content of mapper MAY be something like this:
  // re-read balanced BST concept if you do not understand this diagram
  // the keys are names (string)!
  //                        (grace,75) 
  //           (billy,69)               (martin,81)   
  //     (andy,80)   (felix,82)    (john,78)  (steven,77)

  // iterating through the content of mapper will give a sorted output
  // based on keys (names)
  for (map<string, int>::iterator it = mapper.begin(); it != mapper.end(); it++)
    printf("%s %d\n", ((string)it->first).c_str(), it->second);

  // map can also be used like this
  printf("steven's score is %d, grace's score is %d\n",
    mapper["steven"], mapper["grace"]);
    printf("==================\n");

  // interesting usage of lower_bound and upper_bound
  // display data between ["f".."m") ('felix' is included, martin' is excluded)
  for (map<string, int>::iterator it = mapper.lower_bound("f"); it != mapper.upper_bound("m"); it++)
    printf("%s %d\n", ((string)it->first).c_str(), it->second);

  // the internal content of used_values MAY be something like this
  // the keys are values (integers)!
  //                 (78) 
  //         (75)            (81)   
  //     (69)    (77)    (80)    (82)

  // O(log n) search, found
  printf("%d\n", *used_values.find(77));
  // returns [69, 75] (these two are before 77 in the inorder traversal of this BST)
  for (set<int>::iterator it = used_values.begin(); it != used_values.lower_bound(77); it++)
    printf("%d,", *it);
  printf("\n");
  // returns [77, 78, 80, 81, 82] (these five are equal or after 77 in the inorder traversal of this BST)
  for (set<int>::iterator it = used_values.lower_bound(77); it != used_values.end(); it++)
    printf("%d,", *it);
  printf("\n");
  // O(log n) search, not found
  if (used_values.find(79) == used_values.end())
    printf("79 not found\n");

  return 0;
}
#+end_src
** priority queue
#+begin_src cpp
#include <cstdio>
#include <iostream>
#include <string>
#include <queue>
using namespace std;

int main() {
  int money;
  char name[20];
  priority_queue< pair<int, string> > pq;             // introducing 'pair'
  pair<int, string> result;

  // suppose we enter these 7 money-name pairs below
  /*
  100 john
  10 billy
  20 andy
  100 steven
  70 felix
  2000 grace
  70 martin
  */
  pq.push(make_pair(100, "john"));          // inserting a pair in O(log n)
  pq.push(make_pair(10, "billy"));
  pq.push(make_pair(20, "andy"));
  pq.push(make_pair(100, "steven"));
  pq.push(make_pair(70, "felix"));
  pq.push(make_pair(2000, "grace"));
  pq.push(make_pair(70, "martin"));
  // priority queue will arrange items in 'heap' based
  // on the first key in pair, which is money (integer), largest first
  // if first keys tie, use second key, which is name, largest first
  
  // the internal content of pq heap MAY be something like this:
  // re-read (max) heap concept if you do not understand this diagram
  // the primary keys are money (integer), secondary keys are names (string)!
  //                        (2000,grace)
  //           (100,steven)               (70,martin)   
  //     (100,john)   (10,billy)     (20,andy)  (70,felix)

  // let's print out the top 3 person with most money
  result = pq.top();                // O(1) to access the top / max element
  pq.pop();          // O(log n) to delete the top and repair the structure
  printf("%s has %d $\n", ((string)result.second).c_str(), result.first);
  result = pq.top(); pq.pop();
  printf("%s has %d $\n", ((string)result.second).c_str(), result.first);
  result = pq.top(); pq.pop();
  printf("%s has %d $\n", ((string)result.second).c_str(), result.first);

  return 0;
}

#+end_src
** transforming elements in a sequence
#+begin_src cpp
#include <iostream>
#include <istream>
#include <string>
#include <list>
#include <algorithm>
#include <iterator>
#include <cctype>
#include "utils.h" // For printContainer( ): see 7.10
using namespace std;
// Convert a string to upper case
string strToUpper(const string& s) {
   string tmp;
   for (string::const_iterator p = s.begin( ); p != s.end( ); ++p)
      tmp += toupper(*p);
   return(tmp);
}
string strAppend(const string& s1, const string& s2) {
   return(s1 + s2);
}
int main( ) {
   cout << "Enter a series of strings: ";
   istream_iterator<string> start(cin);
   istream_iterator<string> end;
   list<string> lst(start, end), out;
   // Use transform with an unary function...
   transform(lst.begin( ), lst.end( ),
             back_inserter(out),
             strToUpper);
   printContainer(out);
   cin.clear( );
   cout << "Enter another series of strings: ";
   list<string> lst2(++start, end);
   out.clear( );
   // ...or a binary function and another input sequence.
   transform(lst.begin( ), lst.end( ), lst2.begin( ),
             back_inserter(out),
             strAppend);
   printContainer(out);
}

#+end_src 

Discussion

The obvious function for transforming data is transform. It has two forms. The
first form takes a sequence, an output iterator, and an unary functor. It
applies the functor to each element in the sequence and assigns the return value
to the next element pointed to by the output iterator. The output iterator can
be another sequence or the beginning of the originating sequence. In this
respect, transform handles both copy-style or in-place transformations.

#+begin_src cpp
Here's what the declarations for transform look like: 
Out transform(In first, In last, Out result, UnFunc f);
Out transform(In first1, In last1, In first2, In last2,
              Out result, BinFunc f);
#+end_src 
Both versions return an iterator that refers to one past the end of the result

sequence. Using either version is straightforward. To copy strings from one
sequence to another, but in uppercase, do as I did in Example 7-9:

#+begin_src cpp
std::transform(lst.begin( ), lst.end( ),
               std::back_inserter(out), strToUpper);
#+end_src 
If you want to modify the originating sequence, just pass in the beginning of
the sequence as the result iterator:

#+begin_src cpp
std::transform(lst.begin( ), lst.end( ),
               lst.begin( ), strToUpper);
#+end_src 
Using two sequences and a binary operation works the same way, and you can use
either one of the input sequences as the output sequence.

If you want to transform elements in place, you might want to avoid the overhead
of assigning each element to the return value of some function. Or if the
functor you want to use modifies its source object, you can use for_each
instead:

#+begin_src cpp
void strToUpperInPlace(string& s) {
   for (string::iterator p = s.begin( ); p != s.end( ); ++p)
      *p = std::toupper(*p);
}
// ...
std::for_each(lst.begin( ), lst.end( ), strToUpperInPlace);
#+end_src 
If what you want to do is change the sequence itself and not necessarily change
each of its elements, see Recipe 7.6, where I describe many of the standard
algorithms for rearranging the elements in a sequence. #+end_src

* bit manipulation
#+begin_src cpp
// note: for example usage of bitset, see ch5_06_primes.cpp

#include <cmath>
#include <cstdio>
#include <stack>
using namespace std;

#define isOn(S, j) (S & (1 << j))
#define setBit(S, j) (S |= (1 << j))
#define clearBit(S, j) (S &= ~(1 << j))
#define toggleBit(S, j) (S ^= (1 << j))
#define lowBit(S) (S & (-S))
#define setAll(S, n) (S = (1 << n) - 1)

#define modulo(S, N) ((S) & (N - 1))   // returns S % N, where N is a power of 2
#define isPowerOfTwo(S) (!(S & (S - 1)))
#define nearestPowerOfTwo(S) ((int)pow(2.0, (int)((log((double)S) / log(2.0)) + 0.5)))
#define turnOffLastBit(S) ((S) & (S - 1))
#define turnOnLastZero(S) ((S) | (S + 1))
#define turnOffLastConsecutiveBits(S) ((S) & (S + 1))
#define turnOnLastConsecutiveZeroes(S) ((S) | (S - 1))

void printSet(int vS) {                         // in binary representation
  printf("S = %2d = ", vS);
  stack<int> st;
  while (vS)
    st.push(vS % 2), vS /= 2;
  while (!st.empty())                         // to reverse the print order
    printf("%d", st.top()), st.pop();
  printf("\n");
}

int main() {
  int S, T;

  printf("1. Representation (all indexing are 0-based and counted from right)\n");
  S = 34; printSet(S);
  printf("\n");

  printf("2. Multiply S by 2, then divide S by 4 (2x2), then by 2\n");
  S = 34; printSet(S);
  S = S << 1; printSet(S);
  S = S >> 2; printSet(S);
  S = S >> 1; printSet(S);
  printf("\n");

  printf("3. Set/turn on the 3-th item of the set\n");
  S = 34; printSet(S);
  setBit(S, 3); printSet(S);
  printf("\n");

  printf("4. Check if the 3-th and then 2-nd item of the set is on?\n");
  S = 42; printSet(S);
  T = isOn(S, 3); printf("T = %d, %s\n", T, T ? "ON" : "OFF");
  T = isOn(S, 2); printf("T = %d, %s\n", T, T ? "ON" : "OFF");
  printf("\n");

  printf("5. Clear/turn off the 1-st item of the set\n");
  S = 42; printSet(S);
  clearBit(S, 1); printSet(S);
  printf("\n");

  printf("6. Toggle the 2-nd item and then 3-rd item of the set\n");
  S = 40; printSet(S);
  toggleBit(S, 2); printSet(S);
  toggleBit(S, 3); printSet(S);
  printf("\n");

  printf("7. Check the first bit from right that is on\n");
  S = 40; printSet(S);
  T = lowBit(S); printf("T = %d (this is always a power of 2)\n", T);
  S = 52; printSet(S);
  T = lowBit(S); printf("T = %d (this is always a power of 2)\n", T);
  printf("\n");

  printf("8. Turn on all bits in a set of size n = 6\n");
  setAll(S, 6); printSet(S);
  printf("\n");

  printf("9. Other tricks (not shown in the book)\n");
  printf("8 %c 4 = %d\n", '%', modulo(8, 4));
  printf("7 %c 4 = %d\n", '%', modulo(7, 4));
  printf("6 %c 4 = %d\n", '%', modulo(6, 4));
  printf("5 %c 4 = %d\n", '%', modulo(5, 4));
  printf("is %d power of two? %d\n", 9, isPowerOfTwo(9));
  printf("is %d power of two? %d\n", 8, isPowerOfTwo(8));
  printf("is %d power of two? %d\n", 7, isPowerOfTwo(7));
  for (int i = 0; i <= 16; i++)
    printf("Nearest power of two of %d is %d\n", i, nearestPowerOfTwo(i));
  printf("S = %d, turn off last bit in S, S = %d\n", 40, turnOffLastBit(40));
  printf("S = %d, turn on last zero in S, S = %d\n", 41, turnOnLastZero(41));
  printf("S = %d, turn off last consectuve bits in S, S = %d\n", 39, turnOffLastConsecutiveBits(39));
  printf("S = %d, turn on last consecutive zeroes in S, S = %d\n", 36, turnOnLastConsecutiveZeroes(36));

  return 0;
}
#+end_src

* read from STDIN
** read number

#+begin_src c++
int n, m;
cin >> n >> m;  //reads a string "6 6" ==> n = 6, m = 6
#+end_src
** read a value into array element
#+begin_src c++
float dep[110];
cin >> dep[12]; // read and put the value into slot 12
#+end_src

* examples
** reverse single linked list

#+begin_src cpp
struct Node {
    Node(int pvalue) : value(pvalue), next(nullptr) {}
    int value;
    Node* next;
};
 
// Iterative version
Node* ReverseLinkedList(Node* head) {
    auto cur = head;
    Node* prev = nullptr;
   
    while (cur != nullptr) {
        auto next = cur->next;
        cur->next = prev;
        prev = cur;
        cur = next;
    }
   
    return prev;
}
 
// Recursive version
Node* ReverseLinkedList(Node* prev, Node* cur) {
    if (cur == nullptr) return prev;
   
    Node* head = ReverseLinkedList(cur, cur->next);
    cur->next = prev;
   
    return head;
}
#+end_src
** detect cycle in linked list

#+begin_src cpp
  // Use two pointers, one pointer moves twice faster than the other one. If a cycle exists, they will meet.

  bool DetectCycle(ListNode *head) {
   if (head == nullptr) return false;
       
      auto runner = head;
      auto cur = head;
       
      while (runner != nullptr) {
          runner = runner->next;
          if (runner == cur) return true;
          if (runner != nullptr) {
              runner = runner->next;
              cur = cur->next;
          }
      }       
      return false;
  }
#+end_src
** detect Palindrome string

 #+begin_src cpp
 bool IsPalindrome(const string& input) {
     int i = 0;
     int j = input.size() - 1;
     while (i < j) {
         if (input[i] != input[j]) {
             return false;
         }
         ++i; --j;
     }  
     return true;
 }
 #+end_src

** reverse string

#+begin_src cpp
void Swap(string& input, int i, int j) {
    if (i == j) return;
    assert(i >= 0 && j >= 0);
    assert(i < input.size() && j < input.size());
    char tmp = input[i];
    input[i] = input[j];
    input[j] = tmp;
}
 
 
void Reverse(string& input) {
    int i = 0;
    int j = input.size() - 1;
   
    while (i < j) {
        Swap(input, i, j);
        ++i; --j;
    }
}
#+end_src

** sqrt

#+begin_src cpp
double Sqrt(double x) {
    const double target = 0.000001;
    double e = 1.0;
    double cand = x;          // Chosen candidate
    double re = x;            // Range end (inclusive)
    double rs = 0;            // Range start (inclusive)
 
    if (x * x == x) return x; // Identity case
 
    while (true) {            // NOTE: consider using maxIterations
        cand = rs + (re - rs) / 2.0;           
        e = abs(cand * cand - x);
 
        if (e <= target) {
            return cand;
        }
        else if (cand * cand > x) {
            re = cand;
        }
        else {
            rs = cand;
        }
    }       
    return cand;
}
 
Newtons square root method:
 
double Sqrt(double value) {
   if (value < 0) return double.NaN;
 
   double err = 1e-15;
   double t = value;
   while(abs(t - t / value) > err * t) {
       t = (t + value / t) / 2;
   }
   return t;
}
#+end_src

** implement pow(x,y) efficiently
   
Exponentiating by squaring is a general method for fast computation of large
positive integer powers of a number. A brief analysis shows that this algorithm
uses O(log n) squarings and O(log n) multiplications.

You should design your code to also handle ve power.

#+begin_src cpp
double powhelper(double x, int n) {
    if (n == 0) return 1;
 
    double tmp = powhelper(x, n / 2);
 
    if (n % 2 == 0)
        return tmp * tmp;
    else
        return (x * tmp * tmp);
}
 
double pow(double x, int n) {
    return n < 0 ?
           1.0 / powhelper(x, abs(n))
           : powhelper(x, n);
}
#+end_src

** check palindrome number

#+begin_src c
/* It returns 1 when number is palindrome, otherwise returns 0. */
#define NUMBER_LENGTH 20
int IsPalindrome_solution1(unsigned int number) {
  char string[NUMBER_LENGTH];
  sprintf(string, "%d", number);
  return IsPalindrome(string);
}

int IsPalindrome(const char* const string) {
  int palindrome = 1;
  if(string != NULL) {
    int length = strlen(string);
    int half = length >> 1;
    int i;
    for(i = 0; i < half; ++ i) {
      if(string[i] != string[length - 1 - i]) {
        palindrome = 0;
        break;
      }
    }
  }
  return palindrome
}
#+end_src
** check palindrome number v2

#+begin_src cpp
/* It returns 1 when number is palindrome, otherwise returns 0. */
int IsPalindrome_solution2(unsigned int number) {
  int reversed = 0;
  int copy = number;
  while(number != 0) {
    reversed = reversed * 10 + number % 10;
    number /= 10;
  }
  return (reversed == copy) ? 1 : 0;
}
#+end_src

** sum big integers
#+begin_src cpp
string Sum(const string& lhs, const string& rhs) {
    int i = lhs.length() - 1;
    int j = rhs.length() - 1;
    int carry = 0;
    int sum = 0;
    int unit = 1;
 
    string result;
    while (i >= 0 && j >= 0) {
        int value = (carry + (lhs[i--] - '0')
                    + (rhs[j--] - '0'));
        carry = value >= 10 ? 1 : 0;
        value = value % 10;
 
        result = (char)('0' + value) + result;
    }
 
    while (i >= 0) {
        int value = (carry + (lhs[i--] - '0'));
        carry = value >= 10 ? 1 : 0;
        value = value % 10;
 
        result = (char)('0' + value) + result;
    }
 
    while (j >= 0) {
        int value = (carry + (rhs[j--] - '0'));
        carry = value >= 10 ? 1 : 0;
        value = value % 10;
 
        result = (char)('0' + value) + result;
    }
 
    if (carry > 0) {
        result = (char)('0' + carry) + result;
    }
 
    return result;
}
#+end_src

** multiply big integers

#+begin_src cpp
string Multiply(string num1, string num2) {
 
    auto getMin = [&]() {
        if (num1.length() > num2.length()) return num2;
        else return num1;
    };
 
    auto getMax = [&]() {
        if (num1.length() > num2.length()) return num1;
        else return num2;
    };
 
    string smin = getMin();
    string smax = getMax();
 
    string prev;
    string cur;
    int unit = 0;
 
    for (int32_t i = smin.length() - 1; i >= 0; --i) {
        if (prev.empty()) {
            prev = Multiply(smin[i], smax, unit++);
        }
        else {
            cur = Multiply(smin[i], smax, unit++);
            prev = Sum(cur, prev);
        }
    }
    return prev;
}

string Multiply(char n, string s, int unit) {
    if (n == '0') return "0";
 
    string result;
    int carry = 0;
 
    for (int32_t i = s.length() - 1; i >= 0; --i) {
        // Multiply n x m
        int mul = carry + (s[i] - '0') * (n - '0');
 
        result = (char)('0' + (mul % 10)) + result;
 
        carry = mul / 10;
    }
 
    if (carry > 0) result = (char)('0' + carry) + result;
 
    // Handling trailing zeroes
    while (unit > 0) {
        result.push_back('0');
        unit--;
    }
 
    return result;
}
#+end_src

** mplement a function to replace each blank in a string with %20. 
For instance, it outputs We%20are%20happy. if the input is We are happy..

#+begin_src c
/*capacity is total capacity of a string, which is longer than its actual length*/
void ReplaceBlank(char string[], int capacity) {
  int originalLength, numberOfBlank, newLength;
  int i, indexOfOriginal, indexOfNew;
  if(string == NULL || capacity <= 0)
    return;
  /*originalLength is the actual length of string*/
  originalLength = numberOfBlank = i = 0;
  while(string[i] != '\0') {
    ++ originalLength;
    if(string[i] == ' ')
      ++ numberOfBlank;
    ++ i;
  }
  /*newLength is the length of the replaced string*/
  newLength = originalLength + numberOfBlank * 2;
  if(newLength > capacity)
    return;
  indexOfOriginal = originalLength;
  indexOfNew = newLength;
  while(indexOfOriginal >= 0 && indexOfNew > indexOfOriginal) {
    if(string[indexOfOriginal] == ' ') {
      string[indexOfNew --] = '0';
      string[indexOfNew --] = '2';
      string[indexOfNew --] = '%';
    }
    else {
      string[indexOfNew --] = string[indexOfOriginal];
    }
  -- indexOfOriginal;
  }
}
#+end_src

** array merge
Given two sorted arrays, denoted as array1 and array2, please merge them into array1 and
keep the merged array sorted. Suppose there is sufficient vacant memory at the end of array1 to accommodate
elements of array2.

#+begin_src c 
// Supposing there is enough memory at the end of array1,
// in order to accommodate numbers in array2
void merge(int* array1, int length1, int* array2, int length2) {
  int index1, index2, indexMerged;
  if(array1 == NULL || array2 == NULL)
    return;
  index1 = length1 - 1;
  index2 = length2 - 1;
  indexMerged = length1 + length2 - 1;
  while(index1 >= 0 && index2 >= 0) {
    if(array1[index1] >= array2[index2])
      array1[indexMerged--] = array1[index1--];
    else
      array1[indexMerged--] = array2[index2--];
  }
  while(index2 >= 0)
    array1[indexMerged--] = array2[index2--];
}
#+end_src

Since only one element in array1 or array2 is copied and moved once in each step, the overall time
complexity is O(m+n).

** pair Sum to k
Given an unsorted array of integers that can contain negative and positive
values, return all pairs that sum to k, where k is also an integer. Can you do
it better than O(n^2)?
 
Variation 1: write an O(n^2) algorithm to return all triplets that sum to k.

Variation 2: write an O(n^3) algorithm to return all quadruplets that sum to k.

Solution

A list of pairs that sum to k = 1 from the following array [0, -1, 1, 2, 3, -2]
are given by [-1, 2], [-2,3], and [0,1]. A list of pairs that sum to k = 2 from
the same array are given by [0,2] and [-1,3]. A list of pairs that sum to k = -2
from the same array is [-2,0].

By sorting the array into [-2, -1, 0, 1, 2, 3], while it incurs O(n log n) due
to the cost of sorting, it becomes more obvious how you find the solution. Once
the array is sorted, an O(n) solution to find all pairs that sum to k can be
collected by maintaining two cursors i and j that will move in the opposite
direction. If the sum of pairs at index i and j equals to the target k value,
updates both i and j indices. Otherwise if the sum is smaller, moves i one
position to the right, and conversely moves j to the left, until they meet.
#+begin_src cpp
int PairSum(
    const int* inputs,
    const int length,
    const int k,
    vector<Pair>& outputs)
{
    if (length == 0) return 0;
       
    size_t i = 0;
    size_t j = length - 1;
   
    while (i < j) {
        if (inputs[i] + inputs[j] == k) {
            outputs.push_back(make_pair(inputs[i], inputs[j]));
            i++; --j;
        }
        else if (inputs[i] + inputs[j] < k){
            ++i;
        }
        else {
            --j;
        }
    }
    return outputs.size();
}
#+end_src 
Now, how do you solve finding triplets (a, b, c) that sum to k?

Often, what we need is just a little bit of mind trick a.k.a insight. Finding
triplets (a, b, c) that sum to k can be formulated as finding pairs (a, b) that
sum to k  c. Remember a grade school math that allows you to express (a + b +
c) = k as (a + b) = (c  k)?

It is always good to show that you can write reusable code. Here is your chance
to shine during the interview. By cleverly formulating the problem this way, not
only you can simplify your solution and hence helping you from writing an
unnecessarily much more complex code that is more error prone, but it also
enables you to write a simpler and more elegant code
#+begin_src cpp
int TripletSum(const int* inputs, const int length, const int k)
{
    if (length == 0) return 0;
       
    size_t i = 0;
    size_t j = length - 1;
    int count = 0;
       
    for (int i = 0; i < length; ++i) {
        int value = inputs[i];
       
        // (a + b + c) = k can be expressed as
        // (a + b) = (k - c)
        const auto target = (k - value);
       
        vector<Pair> pairs;
        if (PairSum(&inputs[i + 1], length - i - 1, target, pairs) > 0) {
            PrintTriplets(value, pairs);
            count += pairs.size();
        }
    }
 
    return count;
}
#+end_src

* useful functions
** string_tolower & string_toupper

#+begin_src cpp
void string_tolower(std::string& str)
{
    transform(str.begin(), str.end(), str.begin(), ::tolower);
}
void string_toupper(std::string& str)
{
    transform(str.begin(), str.end(), str.begin(), ::toupper);
}
#+end_src

* useful resources
https://cpbook.net/#downloads
https://github.com/ksaveljev/UVa-online-judge
http://felix-halim.net/
https://github.com/dipu-bd/UVA-Arena
http://dipu-bd.github.io/UVA-Arena/
https://github.com/search?q=topic%3Aproblem-solving&type=Repositories
** professinal cpp book code
http://www.wrox.com/WileyCDA/WroxTitle/Professional-C-3rd-Edition.productCd-1118858050,descCd-DOWNLOAD.html



 
