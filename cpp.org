* code organization
** Making Sure a Header File Gets Included Only Once

#define a macro in your header file, and include only the contents of the header
file if the macro hasn't already been defined. You can use this combination of
the #ifndef, #define, and #endif preprocessor directives, as I did in Example:

#+begin_src cpp
#ifndef MYCLASS_H_  _ // #include guards
#define MYCLASS_H_  _
// Put everything here...
#endif // MYCLASS_H_  
#+end_src

** Ensuring You Have Only One Instance of a Variable Across Multiple Source Files

Declare and define the variable in a single implementation file in the usual
manner, and use the extern keyword in other implementation files where you
require access to that variable at runtime. Often, this means including the
extern declarations in a header file that is used by all implementation files
that need access to the global variable.

#+begin_src cpp
// global.h
#ifndef GLOBAL_H__ // See Recipe 2.0
#define GLOBAL_H__
#include <string>
extern int x;
extern std::string s;
#endif
// global.cpp
#include <string>
int x = 7;
std::string s = "Kangaroo";
// main.cpp
#include <iostream>
#include "global.h"
using namespace std; 
int main( ) {
   cout << "x = " << x << endl;
   cout << "s = " << s << endl;
}
#+end_src

The extern keyword is a way of telling the compiler that the actual storage for
a variable is allocated somewhere else. extern tells the linker that the
variable it qualifies is somewhere in another object file, and that the linker
needs to go find it when creating the final executable or library. If the linker
never finds the extern variable you have declared, or it finds more than one of
definition for it, you will get a link error.

** Reducing #includes with Forward Class Declarations
Use forward class declarations where possible to avoid unnecessary compilation
dependencies.
#+begin_src cpp
// myheader.h
#ifndef MYHEADER_H_  _
#define MYHEADER_H_  _
class A; // No need to include A's header
class B {
   public:
      void f(const A& a);
   // ...
   private:
      A* a_;
};
#endif
#+end_src
A forward class declaration is a way to ignore details that you don't need to be concerned with.

Sadly, you can't always use forward declarations. The class B in Example 2-4
only uses pointers or references to A, so I can get away with a forward
declaration. However, if I use an A member function or variable, or if I have an
object of type A--and not just a pointer or reference to onein my definition for
the class B, suddenly my forward declaration is insufficient.

* numbers
** Converting a String to a Numeric Type
The functions strtol, strtod, and strtoul, defined in <cstdlib>, convert a
null-terminated character string to a long int, double, or unsigned long.

#+begin_src cpp
#include <iostream>
#include <string>
#include <cstdlib>
using namespace std;
long hex2int(const string& hexStr) {
   char *offset;
   if (hexStr.length( ) > 2) {
      if (hexStr[0] == '0' && hexStr[1] == 'x') {
         return strtol(hexStr.c_str( ), &offset, 0);
      }
   }
   return strtol(hexStr.c_str( ), &offset, 16);
}
int main( ) {
   string str1 = "0x12AB";
   cout << hex2int(str1) << endl;
   string str2 = "12AB";
   cout << hex2int(str2) << endl;
   string str3 = "QAFG";
   cout << hex2int(str3) << endl;
}
#+end_src

The strtol function is a bit odd in that it allows you to use two different
methods for specifying a base of 16; you can either pass 16 as a third parameter
to the function; or, you can pass 0 for the base while preceding your string
with the characters 0x (just as you would do for specifying hexadecimal
constants in your code; however, remember that with strtol, you're passing a
string).

using boost
#+begin_src cpp
#include <iostream>
#include <string>
#include <boost/lexical_cast.hpp>
using namespace std;
int main( ) {
   string str1 = "750";
   string str2 = "2.71";
   string str3 = "0x7FFF";
   try {
      cout << boost::lexical_cast<int>(str1) << endl;
      cout << boost::lexical_cast<double>(str2) << endl;
      cout << boost::lexical_cast<int>(str3) << endl;
   }
   catch (boost::bad_lexical_cast& e) {
      cerr << "Bad cast: " << e.what( ) << endl;
   }
}
#+end_src
** Converting Numbers to Strings
#+begin_src cpp
#include <iostream>
#include <iomanip>
#include <string>
#include <sstream>
using namespace std;
int main( ) {
   stringstream ss;
   ss << "There are " << 9 << " apples in my cart.";
   cout << ss.str( ) << endl;  // stringstream::str( ) returns a string
                              // with the contents
   ss.str("");                   // Empty the string
   ss << showbase << hex << 16;  // Show the base in hexadecimal
   cout << "ss = " << ss.str( ) << endl;
   ss.str("");
   ss << 3.14;
   cout << "ss = " << ss.str( ) << endl;
}

//The output of Example 3-3 looks like this: 
//There are 9 apples in my cart.
//ss = 0x10
//ss = 3.14
#+end_src 

using boost
#+begin_src cpp
#include <iostream>
#include <boost/format.hpp>
using namespace std;
using boost::format;
using boost::io::str;
using boost::io::format_error;
int main( ) {
   try {
      format f("There are %1% ways %2% %3% %4%");
      f % 3;
      f % "to" % "do" % "this.";
      cout << f << endl;
      f.clear( ); // Clear buffers to format something else
      f.parse("Those cost $%d.");
      f % 50;
      cout << f << endl;
      int x = 11256099;
      string strx = str(format("%x") % x);
      cout << strx << endl;
   }
   catch (format_error &e) {
      cout << e.what( ) << endl;
   }
}

//Here's what you see when you run this program: 
//There are 3 ways to do this.
//Those cost $50.
//abc123
#+end_src 

#+begin_src cpp

string NumberToString ( int Number )
{
   ostringstream ss;
   ss << Number;
   return ss.str();
}

#+end_src

* strings
** reverse string
#+begin_src c++
std::reverse(s.begin(), s.end());
// In the event that you want to copy the string to another string, but backward, use reverse iterators, like this: 
std::string s = "Los Angeles";
std::string rs;
rs.assign(s.rbegin( ), s.rend( ));
#+end_src

**  Padding a String
You need to "pad," or fill, a string with a number of occurrences of some
character to a certain width. For example, you may want to pad the string
"Chapter 1" to 20 characters wide with periods, so that it looks like "Chapter
1...........".

*Solution*
Use string's insert and append member functions to pad a string with characters on the beginning or end. For example, to pad the end of a string to 20 characters with X's: 
#+begin_src c++
std::string s = "foo";
s.append(20 - s.length( ), 'X');

//To pad the string at the beginning instead: 

s.insert(s.begin( ), 20 - s.length( ), 'X');

#+end_src 

*A generic pad function template*

#+begin_src c++
#include <string>
#include <iostream>
using namespace std;
// The generic approach
template<typename T>
void pad(basic_string<T>& s,
         typename basic_string<T>::size_type n, T c) {
   if (n > s.length( ))
      s.append(n - s.length( ), c);
}
int main( ) {
   string  s  = "Appendix A";
   wstring ws = L"Acknowledgments"; // The "L" indicates that
                                     // this is a wide char
   pad(s, 20, '*');                  // literal
   pad(ws, 20, L'*');
   // cout  << s  << std::endl;  // You shouldn't be able to
   wcout << ws << std::endl;     // run these at the same time
}
#+end_src

** trimmin a string
*** trim
 #+begin_src c++
 #include <string>
 #include <iostream>
 // The approach for narrow character strings
 void rtrim(std::string& s, char c) {
    if (s.empty( ))
       return;
    std::string::iterator p;
    for (p = s.end( ); p != s.begin( ) && *--p == c;);
    if (*p != c)
       p++;
    s.erase(p, s.end( ));
 }
 int main( )
 {
    std::string s = "zoo";
    rtrim(s, 'o');
    std::cout << s << '\n';
 }
 #+end_src

 *A generic version of rtrim*
 #+begin_src c++

 #include <string>
 #include <iostream>
 using namespace std;
 // The generic approach for trimming single
 // characters from a string
 template<typename T>
 void rtrim(basic_string<T>& s, T c)
 {
    if (s.empty( ))
       return;
    typename basic_string<T>::iterator p;
    for (p = s.end( ); p != s.begin( ) && *--p == c;);
    if (*p != c)
       p++;
    s.erase(p, s.end( ));
 }
 int main( ) {
    string s = "Great!!!!";
    wstring ws = L"Super!!!!";
    rtrim(s, '!');
    rtrim(ws, L'!');
    cout << s << '\n';
    wcout << ws << L'\n';
 }
 #+end_src

*** trimming whitespace
 #+begin_src c++
 #include <string>
 #include <iostream>
 #include <cctype>
 #include <cwctype>
 using namespace std;
 template<typename T, typename F>
 void rtrimws(basic_string<T>& s, F f) {
    if (s.empty( ))
       return;
    typename basic_string<T>::iterator p;
    for (p = s.end( ); p != s.begin( ) && f(*--p););
    if (!f(*p))
       p++;
    s.erase(p, s.end( ));
 }
 // Overloads to make cleaner calling for client code
 void rtrimws(string& s) {
    rtrimws(s, isspace);
 }
 void rtrimws(wstring& ws) {
    rtrimws(ws, iswspace);
 }
 int main( ) {
    string s = "zing        ";
    wstring ws = L"zong        ";
    rtrimws(s);
    rtrimws(ws);
    cout << s << "|\n";
    wcout << ws << L"|\n";
 }
 #+end_src

*** Using Boost's string trim functions
#+begin_src c++
#include <iostream>
#include <string>
#include <boost/algorithm/string.hpp>
using namespace std;
using namespace boost;
int main( ) {
   string s1 = "      leading spaces?";
   trim_left(s1); // Trim the original
   string s2 = trim_left_copy(s1); // Trim, but leave original intact
   cout << "s1 = " << s1 << endl;
   cout << "s2 = " << s2 << endl;
   s1 = "YYYYboostXXX";
   s2 = trim_copy_if(s1, is_any_of("XY")); // Use a predicate to
   trim_if(s1, is_any_of("XY"));
   cout << "s1 = " << s1 << endl;
   cout << "s2 = " << s2 << endl;
   s1 = "1234 numbers 9876";
   s2 = trim_copy_if(s1, is_digit( ));
   cout << "s1 = " << s1 << endl;
   cout << "s2 = " << s2 << endl;
   // Nest calls to trim functions if you like
   s1 = "    ****Trim!***     ";
   s2 = trim_copy_if(trim_copy(s1), is_any_of("*"));
   cout << "s1 = " << s1 << endl;
   cout << "s2 = " << s2 << endl;
}
#+end_src

* conditional compilation using predifined macros

#+begin_src cpp
#ifdef _WIN32
# include <windows.h>
#else // Not Windows - assume we're on Unix
# include <sys/stat.h>
#endif
bool is_directory(const char* path)
{
#ifdef _WIN32
      // Windows implementation
#else
      // Unix implementation
#endif
}
#+end_src

On Windows, all the toolsets except the Cygwin port of GCC define the macro
_WIN32; macros defined automatically in this way are known as predefined macros.

* QT
* vector
** minimum and max element of  vector
#+begin_src c++
// min_element/max_element example
#include <iostream>     // std::cout
#include <algorithm>    // std::min_element, std::max_element

bool myfn(int i, int j) { return i<j; }

struct myclass {
  bool operator() (int i,int j) { return i<j; }
} myobj;

int main () {
  int myints[] = {3,7,2,5,6,4,9};

  // using default comparison:
  std::cout << "The smallest element is " << *std::min_element(myints,myints+7) << '\n';
  std::cout << "The largest element is "  << *std::max_element(myints,myints+7) << '\n';

  // using function myfn as comp:
  std::cout << "The smallest element is " << *std::min_element(myints,myints+7,myfn) << '\n';
  std::cout << "The largest element is "  << *std::max_element(myints,myints+7,myfn) << '\n';

  // using object myobj as comp:
  std::cout << "The smallest element is " << *std::min_element(myints,myints+7,myobj) << '\n';
  std::cout << "The largest element is "  << *std::max_element(myints,myints+7,myobj) << '\n';

  return 0;
}
#+end_src
** sort
#+begin_src c++
// sort algorithm example
#include <iostream>     // std::cout
#include <algorithm>    // std::sort
#include <vector>       // std::vector

bool myfunction (int i,int j) { return (i<j); }

struct myclass {
  bool operator() (int i,int j) { return (i<j);}
} myobject;

int main () {
  int myints[] = {32,71,12,45,26,80,53,33};
  std::vector<int> myvector (myints, myints+8);               // 32 71 12 45 26 80 53 33

  // using default comparison (operator <):
  std::sort (myvector.begin(), myvector.begin()+4);           //(12 32 45 71)26 80 53 33

  // using function as comp
  std::sort (myvector.begin()+4, myvector.end(), myfunction); // 12 32 45 71(26 33 53 80)

  // using object as comp
  std::sort (myvector.begin(), myvector.end(), myobject);     //(12 26 32 33 45 53 71 80)

  // print out content:
  std::cout << "myvector contains:";
  for (std::vector<int>::iterator it=myvector.begin(); it!=myvector.end(); ++it)
    std::cout << ' ' << *it;
  std::cout << '\n';

  return 0;
}
#+end_src 

* read from STDIN
** read number

#+begin_src c++
int n, m;
cin >> n >> m;  //reads a string "6 6" ==> n = 6, m = 6
#+end_src

* useful resources
https://cpbook.net/#downloads
https://github.com/ksaveljev/UVa-online-judge
http://felix-halim.net/
https://github.com/dipu-bd/UVA-Arena
http://dipu-bd.github.io/UVA-Arena/
https://github.com/search?q=topic%3Aproblem-solving&type=Repositories
** professinal cpp book code
http://www.wrox.com/WileyCDA/WroxTitle/Professional-C-3rd-Edition.productCd-1118858050,descCd-DOWNLOAD.html
