* defining global variables

A variable that is defined globally in Lisp is called a top-level definition. We can create new top-level definitions with the defparameter function:

#+begin_src 
> (defparameter *small* 1)
*SMALL*
> (defparameter *big* 100)
*BIG*
#+end_src 

* defparameter vs defvar

When you set the value of a global variable using defparameter, any value previously stored in the variable will be overwritten:

#+begin_src 
> (defparameter *foo* 5)
FOO
> *foo*
5
> (defparameter *foo* 6)
FOO
> *foo*
6
#+end_src 

As you can see, when we redefine the variable *foo*, its value changes.

Another command that you can use for declaring global variables, called defvar, won’t overwrite previous values of a global variable:

#+begin_src 
> (defvar *foo* 5)
FOO
> *foo*
5
> (defvar *foo* 6)
FOO
> *foo*
5
#+end_src

* Defining Local Variables in Lisp 

#+begin_src 

> (let ((a 5)
         (b 6))
     (+ a b))
  11
#+end_src 

* Defining Local Functions in Lisp 
We define local functions using the flet command. The flet command has the
following structure:

#+begin_src 
 (flet ((function_name (arguments)
          ...function body...))
   ...body...)
#+end_src 

Here is an example:
#+begin_src 
 > (flet ((f (n)
             (+ n 10)))
     (f 5))
  15
#+end_src 

A single flet command can be used to declare multiple local functions at once.
Simply add multiple function declarations in the first part of the command:

#+begin_src 
 > (flet ((f (n)
            (+ n 10))
          (g (n)
            (- n 3)))
    (g (f 5)))
  12
#+end_src 

To make function names available in defined functions, we can use the labels
command. It’s identical in its basic structure to the flet command. Here’s an
example:

#+begin_src 
 > (labels ((a (n)
              (+ n 5))
            (b (n)
               (+ (a n) 6)))
    (b 10))
  21
#+end_src 

* List functions
** The cons function
If you want to link any two pieces of data in your Lisp program (regardless of
type), the usual way to do that is with the cons function.

#+begin_src 
> (cons 'chicken 'cat)
(CHICKEN . CAT)
#+end_src 

As you can see, cons returns a single object, the cons cell, represented by
parentheses and a dot between the two connected items. Don’t confuse this with a
regular list. The dot in the middle makes this a cons cell, just linking those
two items together.

If instead of another piece of data, we attach the symbol nil on the right side
of the list, something special happens:

#+begin_src 
> (cons 'chicken 'nil)
(CHICKEN)
The previous example can also be written like this:
> (cons 'chicken ())
(CHICKEN)
#+end_src 

** The car and cdr Functions 
Lists are just long chains of two-item cells.

#+begin_src 
The car function is used for getting the thing out of the first slot of a cell:
> (car '(pork beef chicken))
PORK
#+end_src 

The cdr function is used to grab the value out of the second slot, or the
remainder of a list:

#+begin_src 
> (cdr '(pork beef chicken))
(BEEF CHICKEN)
#+end_src 

** The list Function 
For convenience, Common Lisp has many functions built on top of the basic
three—cons, car, and cdr. A useful one is the list function, which does the
dirty work of creating all the cons cells and builds our list all at once:

#+begin_src 
> (list 'pork 'beef 'chicken)
(PORK BEEF CHICKEN)
#+end_src

** building lists
#+begin_src lisp
>(cons 'a '(b c d))
(A B C D)
; we build up lists by consing new elements onto an empty list.
> (cons 'a (cons 'b nil))
(A B)

; the list function is just a more convenient way of consing
; several things onto nil
> (list 'a 'b)
(A B)
#+end_src

* Truth
In Common lisp , the symbol t is the default representation of truth.
#+begin_src lisp
> (listp '(a b c))
T
#+end_src 

Falsity in Common Lisp is represented by nil, the empty list.

#+begin_src lisp
> (listp 27)
NIL
#+end_src 

* Misc
** display string

We can display a string using a function called princ:

#+begin_src 
> (princ "Tutti Frutti")
 Tutti Frutti
 "Tutti Frutti"
#+end_src

** code mode vs data mode
Whenever you type something into the Lisp REPL, the compiler assumes that you’re
entering a command you want to execute. In other words, Lisp always assumes that
you’re writing code and defaults to code mode.


As you might imagine, any stuff written in data mode is treated as data. This
means the computer will not try to “execute” it, which allows us to have
information in our code that’s just plain old data.

Let’s take a look at data mode in action. We’ll enter the same form that we
entered in code mode in the previous example, with one difference:
#+begin_src 
> '(expt 2 3)
(expt 2 3)
#+end_src 

** assignment
In Common Lisp the most general assignment operator is setf.

#+begin_src lisp
> (setf *glob* 98)
98
> (let ((n 10))
       (setf n 2)
       n)
2
#+end_src 

When, the first argument to setf is symbol that is not the name of
a local variable, it is taken  to be a global variable:

#+begin_src lisp
> (setf x (list 'a 'b 'c))
(A B C)
#+end_src 

The first argument to setf can be an expression as well as variable name.
In such cases, the value of the second argument is inserted in the place
referred to by the first:
#+begin_src lisp
> (setf (car x) 'n)
N
> x
(N B C)
#+end_src 

You can give any number of arguments to setf.

#+begin_src lisp
(setf a b
      c d
      e f)
; is equivalent to three separate calls to setf in sequence:
(setf a b)
(setf c d)
(setf e f)
#+end_src 

* example
** ~member~ function implementation
   The Common Lisp function member tests whether something is an
element of a list.

#+begin_src lisp
(defun our-member(obj lst)
	   (if (null lst)
	       nil
	       (if (eql (car lst) obj)
		   lst
		   (our-member obj (cdr lst)))))
#+end_src 
