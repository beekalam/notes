* defining global variables

A variable that is defined globally in Lisp is called a top-level definition. We
can create new top-level definitions with the defparameter function:

#+begin_src 
> (defparameter *small* 1)
*SMALL*
> (defparameter *big* 100)
*BIG*
#+end_src 

* defparameter vs defvar

When you set the value of a global variable using defparameter, any value
previously stored in the variable will be overwritten:

#+begin_src 
> (defparameter *foo* 5)
FOO
> *foo*
5
> (defparameter *foo* 6)
FOO
> *foo*
6
#+end_src 

As you can see, when we redefine the variable *foo*, its value changes.

Another command that you can use for declaring global variables, called defvar,
won’t overwrite previous values of a global variable:

#+begin_src 
> (defvar *foo* 5)
FOO
> *foo*
5
> (defvar *foo* 6)
FOO
> *foo*
5
#+end_src

* Defining Local Variables in Lisp 

#+begin_src 

> (let ((a 5)
         (b 6))
     (+ a b))
  11
#+end_src 

* Defining Local Functions in Lisp 
We define local functions using the flet command. The flet command has the
following structure:

#+begin_src 
 (flet ((function_name (arguments)
          ...function body...))
   ...body...)
#+end_src 

Here is an example:
#+begin_src 
 > (flet ((f (n)
             (+ n 10)))
     (f 5))
  15
#+end_src 

A single flet command can be used to declare multiple local functions at once.
Simply add multiple function declarations in the first part of the command:

#+begin_src 
 > (flet ((f (n)
            (+ n 10))
          (g (n)
            (- n 3)))
    (g (f 5)))
  12
#+end_src 

To make function names available in defined functions, we can use the labels
command. It’s identical in its basic structure to the flet command. Here’s an
example:

#+begin_src 
 > (labels ((a (n)
              (+ n 5))
            (b (n)
               (+ (a n) 6)))
    (b 10))
  21
#+end_src

* Lists
** property lists
A plist is a list where every other element, starting with the first, is a
symbol that describes what the next element in the list is.

#+begin_src lisp
CL-USER> (list :a 1 :b 2 :c 3)
(:A 1 :B 2 :C 3)
;; using GETF to return the value in a plist
CL-USER> (getf (list :a 1 :b 2 :c 3) :a)
1
CL-USER> (getf (list :a 1 :b 2 :c 3) :c)
3
#+end_src 

** List functions
*** The cons function
 If you want to link any two pieces of data in your Lisp program (regardless of
 type), the usual way to do that is with the cons function.

 #+begin_src 
 > (cons 'chicken 'cat)
 (CHICKEN . CAT)
 #+end_src 

 As you can see, cons returns a single object, the cons cell, represented by
 parentheses and a dot between the two connected items. Don’t confuse this with a
 regular list. The dot in the middle makes this a cons cell, just linking those
 two items together.

 If instead of another piece of data, we attach the symbol nil on the right side
 of the list, something special happens:

 #+begin_src 
 > (cons 'chicken 'nil)
 (CHICKEN)
 The previous example can also be written like this:
 > (cons 'chicken ())
 (CHICKEN)
 #+end_src 

*** The car and cdr Functions 
 Lists are just long chains of two-item cells.

 #+begin_src 
 The car function is used for getting the thing out of the first slot of a cell:
 > (car '(pork beef chicken))
 PORK
 #+end_src 

 The cdr function is used to grab the value out of the second slot, or the
 remainder of a list:

 #+begin_src 
 > (cdr '(pork beef chicken))
 (BEEF CHICKEN)
 #+end_src 

*** The list Function 
 For convenience, Common Lisp has many functions built on top of the basic
 three—cons, car, and cdr. A useful one is the list function, which does the
 dirty work of creating all the cons cells and builds our list all at once:

 #+begin_src 
 > (list 'pork 'beef 'chicken)
 (PORK BEEF CHICKEN)
 #+end_src

*** building lists
 #+begin_src lisp
 >(cons 'a '(b c d))
 (A B C D)
 ; we build up lists by consing new elements onto an empty list.
 > (cons 'a (cons 'b nil))
 (A B)

 ; the list function is just a more convenient way of consing
 ; several things onto nil
 > (list 'a 'b)
 (A B)
 #+end_src

*** remove from lists
 The function remove, takes an object and  a list
 and returns a new list containing everything butt
 that object:
 #+begin_src lisp
 > (setf lst '(c a r a t))
 (C A R A T)
 > (remove 'a lst)
 (C R T)
 ; the original list is untouched
 > lst
 (C A R A T)
 #+end_src

*** iteration 
 #+begin_src lisp
 (defun our-length (lst)
   (let ((len 0))
     (dolist (obj lst)
       (setf len (+ len 1)))
     len))

 (our-length (list 'a 'b 'c 'd)) ;4

 #+end_src 
 Here ~dolist~ takes an argument of the form (variable expresion),
 followed by a body of expressions. The body will be evaluated  with
 variable bound to successive elements of the list returned by expression.
 so the loop above says, for each obj in lst, increment len.

* Truth
** intro
In Common lisp , the symbol t is the default representation of truth.
#+begin_src lisp
> (listp '(a b c))
T
#+end_src 

Falsity in Common Lisp is represented by nil, the empty list.

#+begin_src lisp
> (listp 27)
NIL
#+end_src
** the four disguises of ()
Not only does the empty list evaluate to false, but it is the only false value
in Common Lisp. Any value not equivalent to an empty list will be considered a
true value.
 

#+begin_src lisp
(eq '() nil)  ==> T  ;; 1
(eq '() ())   ==> T  ;; 2
(eq '() 'nil) ==> T  ;; 3
#+end_src 

 1. There is a constant named ~nil~ that evaluates to itself and allows you to
omit the quotation mark.
 2. The second case is a natural by-product of how Common Lisp parses an empty form.
 3. is due to a requirement in the Common Lisp spec that says that () and nil 
should be treated the same.

* conditionals
** if
*** intro

#+begin_src lisp

> (if (= (+ 1 2) 3)
      'yup
      'nope)
YUP

> (if (= (+ 1 2) 4)
      'yup
      'nope)
NOPE
;;;;;;;;;;;;;;;;;;;;;;;;;;;
> (if '(1)
      'the-list-has-stuff-in-it
      'the-list-is-empty)
THE-LIST-HAS-STUFF-IN-IT

> (if '()
      'the-list-has-stuff-in-it
      'the-list-is-empty)

THE-LIST-IS-EMPTY
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
> (if (oddp 5)
      'odd-number
      'even-number)
ODD-NUMBER
#+end_src

*** evalua multiple expressions in ~if~
 for cases when you really want to do more than one thing, you can use a special
 command, progn, to wedge in extra commands in a single expression. With progn,
 only the last evaluation is returned as the value of the full expression. In
 this next example, for instance, we use the command to set a special global
 variable directly inside our conditional branch.

#+begin_src lisp

> (defvar *number-was-odd* nil)

> (if (oddp 5)
      (progn (setf *number-was-odd* t)
             'odd-number)
      'even-number)

ODD-NUMBER

> *number-was-odd*
T
#+end_src

** The ~when~ and ~unless~ alternatives
 Since it’s kind of a pain to use progn every time you want to do multiple things
 inside an if, Lisp has several other commands that include an implicit progn.
 The most basic of these are when and unless:
 #+begin_src lisp
 > (defvar *number-is-odd* nil)
 > (when (oddp 5)
         (setf *number-is-odd* t)
         'odd-number)
 ODD-NUMBER

 > *number-is-odd*
 T

 > (unless (oddp 4)
           (setf *number-is-odd* nil)
           'even-number)
 EVEN-NUMBER

 > *number-is-odd*
 NIL
 #+end_src 

 With when, all the enclosed expressions are evaluated when the condition is
 true. With unless, all the enclosed expressions are evaluated when the condition
 is false.
** cond
The cond form is the classic way to do branching in Lisp. Through the liberal
use of parentheses, it allows for an implicit progn, can handle more than one
branch, and can even evaluate several conditions in succession.

#+begin_src lisp

> (defvar *arch-enemy* nil)
 > (defun pudding-eater (person)
        (cond ((eq person 'henry) (setf *arch-enemy* 'stupid-lisp-alien)
                                   '(curse you lisp alien - you ate my pudding))
               ((eq person 'johnny) (setf *arch-enemy* 'useless-old-johnny)
                                   '(i hope you choked on my pudding johnny))
               (t                  '(why you eat my pudding stranger ?))))


  > (pudding-eater 'johnny)
  (I HOPE YOU CHOKED ON MY PUDDING JOHNNY)
  > *arch-enemy*
  JOHNNY
  > (pudding-eater 'george-clooney)
  (WHY YOU EAT MY PUDDING STRANGER ?)
#+end_src

** branching with case
#+begin_src lisp
> (defun pudding-eater (person)
         (case person
              ((henry)   (setf *arch-enemy* 'stupid-lisp-alien)
                         '(curse you lisp alien - you ate my pudding))
              ((johnny)  (setf *arch-enemy* 'useless-old-johnny)
                         '(i hope you choked on my pudding johnny))
              (otherwise '(why you eat my pudding stranger ?))))
#+end_src

* comparing
** EQ function
 Symbols should always be compared to other symbols with eq:

 #+begin_src lisp 
 > (defparameter *fruit* 'apple)

 *FRUIT*

 > (cond ((eq *fruit* 'apple) 'its-an-apple)
         ((eq *fruit* 'orange) 'its-an-orange))

 ITS-AN-APPLE
 #+end_src 

 The eq function is the simplest of all the Lisp comparison functions, and it’s also very fast.
** EQUAL

 If you’re not dealing with two symbols, just use equal. This command will tell
 you when two things are isomorphic, meaning they “look the same.” It works for
 the whole suite of basic Lisp datatypes, as shown here:

 #+begin_src lisp
 ;;comparing symbols
 > (equal 'apple 'apple)
 T

 ;;comparing lists
 T

 ;;Identical lists created in different ways still compare as the same
 > (equal '(1 2 3) (cons 1 (cons 2 (cons 3))))
 T

 ;;comparing integers
 > (equal 5 5)
 T

 ;;comparing floating point numbers
 > (equal 2.5 2.5)
 T

 ;;comparing strings
 > (equal "foo" "foo")
 T

 ;;comparing characters
 > (equal #\a #\a)
 T
 #+end_src 

 As you can see, most items in Lisp can be effectively compared with equal,
 including strings and characters (which are discussed in the next chapter).
** EQL
 The eql command is similar to the eq command, but unlike eq, it also handles
 comparisons of numbers and characters:

 #+begin_src lisp
 ;;comparing symbols
 > (eql 'foo 'foo)
 T

 ;;comparing numbers
 > (eql 3.4 3.4)
 T

 ;;comparing characters
 > (eql #\a #\a)
 T
 #+end_src

** EQLP
The equalp command is essentially the same as the equal command, except that it
can handle some difficult comparison cases with a bit of extra sophistication.
For instance, it can compare strings with different capitalizations and can
compare integers against floating-point numbers:

#+begin_src lisp
;;comparing strings with different CAPS
> (equalp "Bob Smith" "bob smith")
T
;;comparing integers against floating point numbers
> (equalp 0 0.0)
T
#+end_src

* printing
#+begin_src lisp
> (progn (print "this")
         (print "is")
         (print "a")
         (print "test"))

"this"
"is"
"a"
"test"

;The print function causes each item to be printed on a separate line. Now, let’s
;try prin1:

> (progn (prin1 "this")
         (prin1 "is")
         (prin1 "a")
         (prin1 "test"))
"this""is""a""test"
#+begin_src 

As you can see, prin1 does not put the printed items on separate lines. To be
precise, the print and prin1 commands are the same in every way, except that
print will start a new line before printing a value. Additionally, print places
a space character at the end of the printed value.


* Misc
** display string

We can display a string using a function called princ:

#+begin_src 
> (princ "Tutti Frutti")
 Tutti Frutti
 "Tutti Frutti"
#+end_src

** code mode vs data mode
Whenever you type something into the Lisp REPL, the compiler assumes that you’re
entering a command you want to execute. In other words, Lisp always assumes that
you’re writing code and defaults to code mode.


As you might imagine, any stuff written in data mode is treated as data. This
means the computer will not try to “execute” it, which allows us to have
information in our code that’s just plain old data.

Let’s take a look at data mode in action. We’ll enter the same form that we
entered in code mode in the previous example, with one difference:
#+begin_src 
> '(expt 2 3)
(expt 2 3)
#+end_src 

** assignment
In Common Lisp the most general assignment operator is setf.

#+begin_src lisp
> (setf *glob* 98)
98
> (let ((n 10))
       (setf n 2)
       n)
2
#+end_src 

When, the first argument to setf is symbol that is not the name of
a local variable, it is taken  to be a global variable:

#+begin_src lisp
> (setf x (list 'a 'b 'c))
(A B C)
#+end_src 

The first argument to setf can be an expression as well as variable name.
In such cases, the value of the second argument is inserted in the place
referred to by the first:
#+begin_src lisp
> (setf (car x) 'n)
N
> x
(N B C)
#+end_src 

You can give any number of arguments to setf.

#+begin_src lisp
(setf a b
      c d
      e f)
; is equivalent to three separate calls to setf in sequence:
(setf a b)
(setf c d)
(setf e f)
#+end_src 

* example
** ~member~ function implementation
   The Common Lisp function member tests whether something is an
element of a list.

#+begin_src lisp
(defun our-member(obj lst)
	   (if (null lst)
	       nil
	       (if (eql (car lst) obj)
		   lst
		   (our-member obj (cdr lst)))))
#+end_src

** list size

#+begin_src lisp
> (defun my-length (list)
     (if list
         (1+ (my-length (cdr list)))
         0))

> (my-length '(list with four symbols))
4
#+end_src

** format

#+begin_src lisp
  ;The ~a directive is the aesthetic directive; it means to
  ;consume one argument and output it in a human-readable form.
  CL-USER> (format t "~a" "Dixie Chicks")
  Dixie Chicks
  NIL

  ;;The ~t directive is for tabulating. The ~10t tells FORMAT to emit enough
  ;;spaces to move to the tenth column before processing the next ~a. A ~t doesn't
  ;;consume any arguments.

  CL-USER> (format t "~a:~10t~a" :artist "Dixie Chicks")
  ARTIST:   Dixie Chicks
  NIL

#+end_src 

