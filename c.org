#+TITLE:   c recipes 
#+AUTHOR:  Mohammad Reza Mansouri
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+STARTUP: overview
* data types
** OVERFLOW IN char AND UNSIGNED char DATA TYPES

Overflow means you are carrying out an operation such that the value either
exceeds the maximum value or is less than the minimum value of the data type.

Program

#+begin_src 
// the program gives maximum and minimum values of data type
#include <stdio.h>
main()
{
  char i,j ;
  i = 1;
  while (i > 0) // A
  {
    j = i; // B
    i++; // C
  }
  printf ("the maximum value of char is %d\n",j);
  printf ("the value of char after overflow is %d\n",i);
}
#+end_src
** char representations
If you declared C as a character as

char c;

then you can assign A as follows:

#+begin_src c
c = 'A';
c = 65;
c = '\x41';   // Hexadecimal representation
c = '\101';   // Octal representation
#+end_src 

You cannot write c = ‘A’ because ‘A’ is interpreted as a string.
* preprocessor
** undef
If you want to nullify the effect of the define directive and specify a new value, then you can use the undef directive.
#+begin_src c
#include <stdio.h>
#define VAL 40;      //A
#undef VAL           //B
#define VAL 40       //C
main()
{
    printf ("%d\n", VAL);   //D
}
#+end_src

** ifdef
The ifdef directive makes substitutions based on whether a particular identifier is defined.

Suppose we have three files:
#+begin_src c
file1.h
#define USD 1

file2.h
#define UKP 1

file3
#include <stdio.h>
#include <file1.h>       //A
#ifdef USD                  // B
       #define currency_rate 46     //C
#endif                //D

#ifdef UKP                  // E
   #define currency_rate 100 //F
#endif                //G
main()
{
    int rs;
    rs = 10 * currency_rate;  //H
    printf ("%d\n", rs);
}
#+end_src 

** ifndef
#ifndef is used to check whether a particular symbol is defined.

Suppose wse have three files:

#+begin_src c
file1.h
#define USD 1

file2.h
#define UKP 1

file3
#include <stdio.h>
#include <file1.h>      //A

#ifndef USD                   // B
       #define currency_rate 100     //C
#endif                //D

#ifndef UKP                  // E
   #define currency_rate 46 //F
#endif                //G
main()
{
    int rs;
    rs = 10 * currency_rate;  //H
    printf ("%d\n", rs);
}
#+end_src 

** if
#if allows you to define more generalized conditions. Multiple conditions, which are connected by relational operators such as AND(&&), OR(||), are allowed.
Suppose we have three files:
#+begin_src c
file1.h
#define USD 1

file2.h
#define UKP 1

file3
#include <stdio.h>
#include <file1.h>                //A

#if ((1>0) &&(defined (USD))      // B
       #define currency_rate 46                     //C
#endif                       //D

#if (defined (UKP))                     // E
   #define currency_rate 100 //F
#endif                       //G
main()
{
    int rs;
    rs = 10 * currency_rate; //H
    printf ("%d\n", rs);
}
#+end_src

** ifelif

ifelif allows us to take one action if there are multiple decision points. For
example, if you want to take the currency rate of 1 if USD and UKP are not
defined, you can write the following program.

Suppose we have three files:
#+begin_src c
file1.h
#define USD 1

file2.h
#define UKP 1

file3
#include <stdio.h>
#include <file1.h>             //A

#if (defined (USD))                  // B
     #define currency_rate 46
#elif (defined (UKP))
     #define currency_rate 100       //C
#else
     # define currency_rate 1        //D
#endif

main()
{
    int rs;
    rs = 10 * currency_rate;         //H
    printf ("%d\n", rs);
}
#+end_src 

** ERROR DIRECTIVE

The error directive is used to specify an error message for a specific situation. In the following program, the error message is displayed if USD and UKP are not defined.
Suppose we have three files:
#+begin_src c
file1.h
#define USD 1

file2.h
#define UKP 1

file3
#include <stdio.h>
#include <file1.h>                 //A

#if !defined (USD) || !defined (UKP)     // B
#error "ERROR: NO_CURRENCY rate is specified." //C
#endif

main()
{
    int rs;
    rs = 10 * currency_rate;        //D
    printf ("%d\n", rs);
}
#+end_src 

** #line

The #line directive allows you to define arbitrary line numbers for the source
lines. Normally, the compiler counts lines starting at line number 1; using the
#line directive, you can specify an arbitrary line number at any point. The
compiler then uses that line number for subsequent counts.

#+begin_src c
#include <stdio.h>
main()
{
    printf("A\n");          //A

     #line100               //H
    printf("B\n");          //B
    printf("C FILE %s LINE %d\n", __FILE__, __LINE__ );//C
     #line200               //K

    printf("D\n");          //D
    printf("E\n");          //E
}
#+end_src 

Explanation

The statement H indicates the #line directive.
The #line number in statement B is taken as 100 and for statement C, it is taken as 101.
The #line number in statement D is taken as 200 and for statement E, it is taken as 201.
If you introduce any error in statement B then the compiler will display the error at #line number 100.
C has provided two special identifiers: __FILE__ and __LINE__, which indicate the file name of the source file and the current line number, respectively.

Point to Remember
#line is used to indicate line numbers which can be used for debugging.

* printf
** Program/Example
The general form of a placeholder is:
    % flags field-width precision prefix type-identifier.
** Type-identifiers
The type-identifiers are as follows:
  d, i Signed integers
  o Unsigned integers displayed in octal form.
  u Unsigned integers in decimal form.
  x Unsigned integers in hexadecimal form, and the hexadecimal characters a, b, c, d, e, and f printed in lowercase.
  X Unsigned integer in hexadecimal form, and the hexadecimal characters A, B, C, D, E, and F printed in uppercase.
  c Any value converted to unsigned char and displayed; c is used mainly for printing characters.
  s The argument is converted to a character array and is printed; the last null in the string is not printed.
  f Floating point.
  e, E Floating point displayed in exponential form. It will have one digit to
    the left of the decimal point; the number of digits on the right side of the
    decimal point depends on the required precision.

  g, G The value can be printed in floating point or exponential form. The
      exponential form is used if the exponent is less than –1 or if the exponent
      causes more places than required by the specified precision; the decimal point
      appears only if it is followed by a digit.

  n This indicates to print the number of characters that are printed so far by printf.
  p It indicates an additional argument pointer to void; the value of the pointer is converted to a sequence of characters.

** Type prefixes
  h It can appear before type indicators d, i, o, u, x, and X. It indicates that
    the value to be displayed should be interpreted as short; for example, short
    integer (hd) and short unsigned integer (hu).

  l It can appear before type-identifiers d, i, o, u, x, and X. It indicates
    that the value to be displayed should be interpreted as long; for example,
    long integer (hd) and long unsigned integer (hu).

  l, L Available for type-identifiers e, E, f, g, and G. It indicates that a
        value should be indicated as long double.

** Field-width
 1. *Field-width* indicates the least number of columns that will be allocated to
    the output. For example, if you write %4d to i and the value of i is 10,
    then 4 columns are allocated for i and 2 blank are added on left side of
    value of i. So the output is bb10. Here, b indicates blank. 

 2. If the value is more than the specified column, field-width is ignored and
    the number of columns used is equal to the number of columns required by the
    arguments. So if i is 12345 then 5 columns are used, even if %4d is
    specified.

 3. In any circumstance, the output width is not shortened, because of field-width.

 4. If you specify * instead of field-width then you have to specify additional
    arguments. For example,
#+begin_src c
printf ("%*d\n", 5, 20);     // A
printf ("%*d\n", 20, 5);     // B
 #+end_src 
 In A, 5 is substituted for * and it indicates putting the value 20 in 5 columns.
 In B, 20 is substituted for * and it indicates putting the value 5 in 20 columns.

** Precision
 1. Precision indicates the minimum number of digits printed for type integers d, i, o, u, x, and X. For example,
#+begin_src c
i.    printf("%10.4d\n", 35)
#+end_src 

 2. Here 10 is the field-width and 4 is the precision, so 10 columns are used
    for the 4-digit output. To make 35 into 4 digits, two 0s are added to the
    left side to make it 0035. To print 0035 in 10 columns, blanks are added to
    make the output bbbbbb0035.

 3. For floating arguments, precision indicates how many digits are printed
    after decimal points. If precision is more than the number of digits on the
    right side of the decimal point, 0s are added to the right side.

 4. If precision indicates too few digits, then it is ignored and the number of
    digits are printed as necessary.

** Flags
 1. Flag characters are used to give directives for the output. You can use multiple flag characters in any order.

 2. The flag characters are as follows:
    — Indicates that output is left justified.
          printf("%-10.4d\n", 25)
      It causes the number to be printed as 0025bbbbbb. Thus, blanks are added to the right side.
      In the absence of a flag, it is printed as bbbbbb0025.
      + Indicates that i number is printed using a sign character (+ or —).
        printf("%+d\n", -25);
        printf("%+d\n", 25);
      It causes printing as
      -25
      +25
      <space> Indicates a space for positive values so that positive values and negative values are aligned. For example,
      printf("% d\n", 25);
      printf("% d", 25);
      It causes printing in the form of
      b25
      25
      In the first case, blank is displayed.

      − # Indicates that the value should be converted to another form before
          displaying. For example, for hexadecimal values you can indicate 0X; for the
          floating data type, # indicates that the decimal point should always be
          included in the output.

      0 Used with whole and real numbers, 0 causes 0s to be padded to complete
        the field width. If the precision is specified as 0, then this flag is
        ignored; if the 0 and – flags are both specified, the 0 flag is ignored.
* scanf
** Introduction

The scanf placeholder consists of % at the beginning and a type indicator at the
end. Apart from that it can have *, a maximum field-width indicator, and a type
indicator modifier, for example,

    %10.2f,%10d

** Type indicators
d, i Used for signed integers; the expected argument should be a pointer to int.
o Used for unsigned int expected's value. It should be an integer in octal form.
U Unsigned integer in decimal form.
X, X Unsigned integer in hexadecimal form.
E, E, f, g, G Floating-point values.
S Character string. It matches a sequence of non-whitespace characters terminated by an end-of-line or end-of-file character. The additional argument should be a pointer to char and should point to an area that is large enough to hold the input string as well as the NULL terminator.
C Matches the number of characters according to a specified field-width. If no width is specified then a single character is assumed. The additional argument must be a pointer to char; the area pointed to should be large enough to hold the specified number of characters.
N Does not read any input but writes the number of characters so far in the target variable.
Use of *
The * is used to suppress input. For example, with %*d, if your input consists of 5 values and you want to ignore the middle 3 values, you can write:
scanf(" %d %*d %*d%*d %d ", &i, &j)
So, if your input is
10 20 30 40 50
it will get the value 10 and j will get the value 50. This is useful when you are getting the input from a file.
Field-width
It indicates the maximum number of characters that are read into the variables.
* array
** ADDRESS OF EACH ELEMENT IN AN ARRAY

Each element of the array has a memory address. The following program prints an array limit value and an array element address.

#+begin_src c
#include <stdio.h>
void printarr(int a[]);
main()
{
    int a[5];
    for(int i = 0;i<5;i++)
    {
        a[i]=i;
    }
    printarr(a);
}
void printarr(int a[])
{
    for(int i = 0;i<5;i++)
    {
        printf("value in array %d\n",a[i]);
    }
}
void printdetail(int a[])
{
    for(int i = 0;i<5;i++)
    {
        printf("value in array %d and address is %16lu\n",a[i],&a[i]);
\\ A
    }
}
#+end_src 

** ACCESSING AN ARRAY USING POINTERS
You can access an array element by using a pointer. For example, if an array stores integers, then you can use a pointer to integer to access array elements.
#+begin_src c
#include <stdio.h>
void printarr(int a[]);
void printdetail(int a[]);
main()
{
    int a[5];
    for(int i = 0;i<5;i++)
    {
        a[i]=i;
    }
    printdetail(a);
}
void printarr(int a[])
{
    for(int i = 0;i<5;i++)
    {
        printf("value in array %d\n",a[i]);
    }
}
void printdetail(int a[])
{
    for(int i = 0;i<5;i++)
    {
        printf("value in array %d and address is %8u\n",a[i],&a[i]);
    }
}
void print_usingptr(int a[]) \\ A
{
    int *b;    \\ B
    b=a;               \\ C
    for(int i = 0;i<5;i++)
    {
        printf("value in array %d and address is %16lu\n",*b,b); \\ D
        b=b+2; \\E
    }
}
#+end_src

** POINTER ARRAYS
You can define a pointer array similarly to an array of integers. In the pointer array, the array elements store the pointer that points to integer values.
#+begin_src c
#include <stdio.h>
void printarr(int *a[]);
void printarr_usingptr(int *a[]);
int *a[5];
main()
{

    int i1=4,i2=3,i3=2,i4=1,i5=0;
    a[0]=&i1;
    a[1]=&i2;
    a[2]=&i3;
    a[3]=&i4;
    a[4]=&i5;

    printarr(a);
    printarr_usingptr(a);
}
void printarr(int *a[])
{
    printf("Address        Address in array         Value\n");
    for(int  j=0;j<5;j++)
    {
        printf("%16u           %16u                 %d\n",  a[j],(a[j] - a[0]),*a[j]);
    }
}
void printarr_usingptr(int *a[])
{
    int j=0;
    printf("using pointer\n");
    for( j=0;j<5;j++)
    {
        printf("value of elements   %d %16lu %16lu\n",**a,*a,a);
        a++;
    }
}
#+end_src

* character strings
** Character String Literals (String Constants)
A string literal, also termed a string constant, is anything enclosed in double quotation
marks.
Character string constants are placed in the static storage class, which means that if you use
a string constant in a function, the string is stored just once and lasts for the duration of the
program, even if the function is called several times. 
** Character String Arrays and Initialization 
When you define a character string array, you must let the compiler know how much space
is needed. One way is to specify an array size large enough to hold the string. The following
declaration initializes the array m1 to the characters of the indicated string:

#+begin_src c
 const char m1[40] = "Limit yourself to one line's worth.";
#+end_src

The const indicates the intent to not alter this string.
This form of initialization is short for the standard array initialization form:
#+begin_src c
 const char m1[40] = { 'L',
 'i', 'm', 'i', 't', ' ', 'y', 'o', 'u', 'r', 's', 'e', 'l',
 'f', ' ', 't', 'o', ' ', 'o', 'n', 'e', ' ',
 'l', 'i', 'n', 'e', '\", 's', ' ', 'w', 'o', 'r',
 't', 'h', '.', '\0'
 };
#+end_src

Letting the compiler compute the size of the array works only if you initialize the array. If you
create an array you intend to fill later, you need to specify the size when you declare it. When
you do declare an array size, the array size must evaluate to an integer. Prior to the advent of
variable length arrays (VLAs) with C99, the size had to be an integer constant, which includes
the possibility of an expression formed from constant integer values. 
#+begin_src c
int n = 8;
 char cookies[1]; // valid
 char cakes[2 + 5]; // valid, size is a constant expression
 char pies[2*sizeof(long double) + 1]; // valid
 char crumbs[n]; // invalid prior to C99, a VLA after C99
#+end_src

The name of a character array, like any array name, yields the address of the first element of
the array. Therefore, the following holds:

#+begin_src c
 char car[10] = "Tata";
 car == &car[0] , *car == 'T', and *(car+1) == car[1] == 'a'
#+end_src
 
Indeed, you can use pointer notation to set up a string. For example, Listing 11.1uses the
following declaration:

#+begin_src c
 const char * pt1 = "Something is pointing at me.";
#+end_src
 
This declaration is very nearly the same as this one:

#+begin_src c
 const char ar1[] = "Something is pointing at me.";
#+end_src

The declarations amount to saying that both pt1 and ar1 are addresses of strings. In both
cases, the quoted string itself determines the amount of storage set aside for the string.
Nonetheless, the forms are not identical. 

Note the closing null character. Without it, you have a character array, but not a string. 

** Array Versus Pointer 
What is the difference, then, between an array and a pointer form? The array form ( ar1[] )
causes an array of 29 elements (one for each character plus one for the terminating '\0') to
be allocated in the computer memory. Each element is initialized to the corresponding character
of the string literal. Typically, what happens is that the quoted string is stored in a data
segment that is part of the executable file; when the program is loaded into memory, so is that
string. The quoted string is said to be in static memory. *But the memory for the array is allocated
only after the program begins running.* At that time, the quoted string is copied into the
array. Note that, at this time, there are two copies of the string. One is the
string literal in static memory, and one is the string stored in the ar1 array.

Hereafter, the compiler will recognize the name ar1 as a synonym for the address of the first
array element, &ar1[0]. One important point here is that in the array form, ar1 is an address
constant. You can’t change ar1, because that would mean changing the location (address)
where the array is stored. You can use operations such as ar1+1 to identify the next element in
an array, but ++ar1 is not allowed. The increment operator can be used only with the names of
variables (or, more generally, modifiable lvalues), not with constants.

The pointer form ( *pt1) also causes 29 elements in static storage to be set aside for the string.
In addition, once the program begins execution, it sets aside one more storage location for the
pointer variable pt1 and stores the address of the string in the pointer variable. This variable
initially points to the first character of the string, but the value can be changed. Therefore, you
can use the increment operator. For instance, ++pt1 would point to the second character ( o ).
A string literal is considered to be const data. Because pt1 points to that data, it should be
declared as pointing to const data. This doesn’t mean you can’t change the value of pt1 (i.e.,
where it points), but it does mean you can’t use pt1 to change the data itself. If you copy a
string literal to an array, on the other hand, you are free to change the data unless you choose
to declare the array as const . 
In short, initializing the array copies a string from static storage to the array, whereas initializing
the pointer merely copies the address of the string. Listing 11.3illustrates these points. 
#+begin_src c
 // addresses.c -- addresses of strings
 #define MSG "I'm special."
 #include <stdio.h>
 int main()
 {
 char ar[] = MSG;
 const char *pt = MSG;
 printf("address of \"I'm special\": %p \n", "I'm special");
 printf(" address ar: %p\n", ar);
 printf(" address pt: %p\n", pt);
 printf(" address of MSG: %p\n", MSG);
 printf("address of \"I'm special\": %p \n", "I'm special");
 return 0;
 } 
#+end_src

Here’s the output from one system:
 address of "I'm special": 0x100000f0c
 address ar: 0x7fff5fbff8c7
 address pt: 0x100000ee0
 address of MSG: 0x100000ee0
 address of "I'm special": 0x100000f0c 

What does this show? First, pt and MSG are the same address, while ar is a different address,
just as promised. Second, although the string literal "I'm special." occurs twice in the
printf() statements, the compiler chose to use one storage location, but not the same address
as MSG. The compiler has the freedom to store a literal that’s used more than once in one or
more locations. Another compiler might choose to represent all three occurrences of "I'm
special." with a single storage location. Third, the part of memory used for static data is
different from that used for dynamic memory, the memory used for ar. Not only are the values 
different, but this particular compiler even uses a different number of bits to represent the two
kinds of memory.
Are the differences between array and pointer representations of strings important? Often they
are not, but it depends on what you try to do. Let’s look further into the matter. 

** Array and pointer differences
Let’s examine the differences between initializing a character array to hold a string and initializing
a pointer to point to a string. (By “pointing to a string,” we really mean pointing to the
first character of a string.) For example, consider these two declarations:
#+begin_src c
 char heart[] = "I love Tillie!";
 const char *head = "I love Millie!";
#+end_src

The chief difference is that the array name heart is a constant, but the pointer head is a variable.
What practical difference does this make?
First, both can use array notation:
#+begin_src c
 for (i = 0; i < 6; i++)
 putchar(heart[i]);
 putchar('\n');
 for (i = 0; i < 6; i++)
 putchar(head[i]));
 putchar('\n');
#+end_src

This is the output:
 I love
 I love

Next, both can use pointer addition:
#+begin_src c
 for (i = 0; i < 6; i++)
 putchar(*(heart + i));
 putchar('\n');
 for (i = 0; i < 6; i++)
 putchar(*(head + i));
 putchar('\n');
#+end_src

Again, the output is as follows:
 I love
 I love

Only the pointer version, however, can use the increment operator:
#+begin_src c
 while (*(head) != '\0') /* stop at end of string */
 putchar(*(head++)); /* print character, advance pointer */ 
#+end_src

This produces the following output:
 I love Millie!

Suppose you want head to agree with heart. You can say

 head = heart; /* head now points to the array heart */

This makes the head pointer point to the first element of the heart array.
However, you cannot say

 heart = head; /* illegal construction */

The situation is analogous to x = 3; versus 3 = x;. The left side of the assignment statement
must be a variable or, more generally, a modifiable lvalue, such as *p_int. Incidentally, head
= heart; does not make the Millie string vanish; it just changes the address stored in head .
Unless you’ve saved the address of "I love Millie!" elsewhere, however, you won’t be able
to access that string when head points to another location.

There is a way to alter the heart message—go to the individual array elements:

 heart[7]= 'M';
 or
 *(heart + 7) = 'M';

The elements of an array are variables (unless the array was declared as const), but the name is
not a variable.

Let’s go back to a pointer initialization that doesn’t use the const modifier:

 char * word = "frame";

Can you use the pointer to change this string?

 word[1] = 'l'; // allowed??

Your compiler may allow this, but, under the current C standard, the behavior for such an
action is undefined. Such a statement could, for example, lead to memory access errors. The
reason is that, as mentioned before, a compiler can choose to represent all identical string literals
with a single copy in memory. For example, the following statements could all refer to a
single memory location of string "Klingon" :

 char * p1 = "Klingon";
 p1[0] = 'F'; // ok?
 printf("Klingon");
 printf(": Beware the %ss!\n", "Klingon");

That is, the compiler can replace each instance of "Klingon" with the same address. If the
compiler uses this single-copy representation and allows changing p1[0] to 'F', that would 
affect all uses of the string, so statements printing the string literal "Klingon" would actually
display "Flingon" :

 Flingon: Beware the Flingons!

In fact, in the past, several compilers did behave this rather confusing way, whereas others
produced programs that abort. Therefore, the recommended practice for initializing a pointer to
a string literal is to use the const modifier:

 const char * pl = "Klingon"; // recommended usage

Initializing a non- const array with a string literal, however, poses no such problems, because
the array gets a copy of the original string.
In short, don’t use a pointer to a string literal if you plan to alter the string. 
** Arrays of character Strings
#+begin_src c
// arrchar.c -- array of pointers, array of strings
#include <stdio.h>
#define SLEN 40
#define LIM 5
int main(void)
{
const char *mytalents[LIM] = {
"Adding numbers swiftly",
"Multiplying accurately", "Stashing data",
"Following instructions to the letter",
"Understanding the C language"
};
char yourtalents[LIM][SLEN] = {
"Walking in a straight line",
"Sleeping", "Watching television",
"Mailing letters", "Reading email"
};
int i;
puts("Let's compare talents.");
printf ("%-36s %-25s\n", "My Talents", "Your Talents");
for (i = 0; i < LIM; i++)
printf("%-36s %-25s\n", mytalents[i], yourtalents[i]);
printf("\nsizeof mytalents: %zd, sizeof yourtalents: %zd\n",
sizeof(mytalents), sizeof(yourtalents));
return 0;
#+end_src

** Pointers and Strings
#+begin_src c
/* p_and_s.c -- pointers and strings */
#include <stdio.h>
int main(void)
{
    const char * mesg = "Don't be a fool!";
    const char * copy;
    copy = mesg;
    printf("%s\n", copy);
    printf("mesg = %s; &mesg = %p; value = %p\n",
    mesg, &mesg, mesg);
    printf("copy = %s; &copy = %p; value = %p\n",
    copy, &copy, copy);
    return 0; 
}
#+end_src
Looking at this program, you might think that it makes a copy of the string "Don't be a
fool!" , and your first glance at the output might seem to confirm this guess:
Don't be a fool!
mesg = Don't be a fool!; &mesg = 0x0012ff48; value = 0x0040a000
copy = Don't be a fool!; &copy = 0x0012ff44; value = 0x0040a000
** string input
*** alternatives to gets
The fgets() Function (and fputs() )
Here is how fgets() differs from gets() :
 -  It takes a second argument indicating the maximum number of
   characters to read. If thisargument has the value n , fgets() reads
   up to n-1 characters or through the newline character, whichever
   comes first.
 -  If fgets() reads the newline, it stores it in the string, unlike
   gets() , which discards it.
 - It takes a third argument indicating which file to read. To read
   from the keyboard, use
stdin (for standard input ) as the argument; this identifier is defined in stdio.h .

Because the fgets() function includes the newline as part of the
string (assuming the input line fits), it’s often paired with fputs()
, which works like puts() , except that it doesn’t auto- matically
append a newline. It takes a second argument to indicate which file to
write to. For the computer monitor we can use stdout (for standard
output) as an argument. Listing 11.7 illustrates how fgets() and
fputs() behave.

#+begin_src c
/* fgets1.c -- using fgets() and fputs() */
#include <stdio.h>
#define STLEN 14
int main(void)
{
    char words[STLEN];
    puts("Enter a string, please.");
    fgets(words, STLEN, stdin);
    printf("Your string twice (puts(), then fputs()):\n");
    puts(words);
    fputs(words, stdout);
    puts("Enter another string, please.");
    fgets(words, STLEN, stdin);
    printf("Your string twice (puts(), then fputs()):\n");
    puts(words);
    fputs(words, stdout);
    puts("Done.");
    return 0;
}
#+end_src

The fgets() function returns a pointer to char . If all goes well, it just returns the same address
that was passed to it as the first argument. If the function encounters end-of-file, however,
it returns a special pointer called the null pointer .

#+begin_src c
/* fgets2.c -- using fgets() and fputs() */
#include <stdio.h>
#define STLEN 10
int main(void)
{
    char words[STLEN];
    puts("Enter strings (empty line to quit):");
    while (fgets(words, STLEN, stdin) != NULL && words[0] != '\n')
    fputs(words, stdout);
    puts("Done.");
    return 0;
}
#+end_src

*** scanf() function
If you use the %s format, the string runs up to (but not including)
the next whitespace character (blank, tab, or newline). If you specify
a field width, as in %10s , the scanf() collects up to 10 characters
or up to the first whitespace character, whichever comes first.

scanf() function returns an integer value that equals the number of items
successfully read or returns EOF if it encounters the end of file.

#+begin_src c
/* scan_str.c -- using scanf() */
#include <stdio.h>
int main(void)
{
    char name1[11], name2[11];
    int count;
    printf("Please enter 2 names.\n");
    count = scanf("%5s %10s",name1, name2);
    printf("I read the %d names %s and %s.\n",
    count, name1, name2);
    return 0;
}
#+end_src
#+begin_src
Here are three runs:
Please enter 2 names.
Jesse Jukes
I read the 2 names Jesse and Jukes.
Please enter 2 names.
Liza Applebottham
I read the 2 names Liza and Applebotth.
Please enter 2 names.
Portensia Callowit
I read the 2 names Porte and nsia.
#+end_src

In the first example, both names fell within the allowed size limits. In the second example,
only the first 10 characters of Applebottham were read because we used a %10s format. In the
third example, the last four letters of Portensia went into name2 because the second call to
scanf() resumed reading input where the first ended; in this case, that was still inside the
word Portensia.

** string output
** Null character and Null pointer
Null character and null pointer both appear in Listing 11.9 . Conceptually, these two nulls are
different from one another. The null character, or '\0' , is the character used to mark the end
of a C string. It’s the character whose code is zero.
The null pointer, or NULL , has a value that doesn’t correspond to a valid address of data.
So the null character is an integer type, while the null pointer is a pointer type.
Also, while the null character, being a character, is one
byte, the null pointer, being an address, typically is four bytes.
** string length example
#+begin_src c
// Function to count the number of characters in a string

#include <stdio.h>

int  stringLength (const char  string[])
{
    int  count = 0;

    while ( string[count] != '\0' )
        ++count;

    return count;
}

int main (void)
{
    int   stringLength (const char  string[]);
    const char  word1[] = { 'a', 's', 't', 'e', 'r', '\0' };
    const char  word2[] = { 'a', 't', '\0' };
    const char  word3[] = { 'a', 'w', 'e', '\0' };

    printf ("%i   %i   %i\n", stringLength (word1),
             stringLength (word2), stringLength (word3));

    return 0;
}
#+end_src

** concatenation of strings example
#+begin_src c
#include <stdio.h>

int main (void)
{
    void  concat (char  result[], const char  str1[], const char  str2[]);
    const char  s1[] = { "Test " };
    const char  s2[] = { "works." };
    char  s3[20];

    concat (s3, s1, s2);

    printf ("%s\n", s3);

    return 0;
}

// Function to concatenate two character strings

void concat (char  result[], const char  str1[], const char  str2[])
{
    int  i, j;

    // copy str1 to result

    for ( i = 0;  str1[i] != '\0';  ++i )
        result[i] = str1[i];

    // copy str2 to result

    for ( j = 0;  str2[j] != '\0';  ++j )
        result[i + j] = str2[j];

    // Terminate the concatenated string with a null character

    result [i + j] = '\0';
}
#+end_src

** startsWith
#+begin_src c
int startsWith(const char *string, const char *prefix) {
  while(*prefix) {
    if(*prefix++ != *string++) {
      return 0;
    }
  }
  return 1;
}
#+end_src

** equalStrings example

#+begin_src c
// Function to determine if two strings are equal

#include <stdio.h>
#include <stdbool.h>

bool equalStrings (const char  s1[], const char  s2[])
{
    int  i = 0;
    bool areEqual;

    while ( s1[i] == s2 [i]  &&
                 s1[i] != '\0' &&  s2[i] != '\0' )
        ++i;

    if ( s1[i] == '\0'  &&  s2[i] == '\0' )
       areEqual = true;
    else
       areEqual = false;

    return areEqual;
}


int main (void)
{
     bool  equalStrings (const char  s1[], const char  s2[]);
     const char  stra[] = "string compare test";
     const char  strb[] = "string";

     printf ("%i\n", equalStrings (stra, strb));
     printf ("%i\n", equalStrings (stra, stra));
     printf ("%i\n", equalStrings (strb, "string"));

     return 0;
}
#+end_src

** read string with scanf

#+begin_src c
//  Program to illustrate the %s scanf format characters

#include <stdio.h>

int main (void)
{
    char  s1[81], s2[81], s3[81];

    printf ("Enter text:\n");

    scanf ("%s%s%s", s1, s2, s3);

    printf ("\ns1 = %s\ns2 = %s\ns3 = %s\n", s1, s2, s3);
    return 0;
}
#+end_src

** reading lines of code

#+begin_src c
#include <stdio.h>

int main (void)
{
    int   i;
    char  line[81];
    void  readLine (char  buffer[]);

    for ( i = 0; i < 3; ++i )
    {
        readLine (line);
        printf ("%s\n\n", line);
    }

    return 0;
}

// Function to read a line of text from the terminal

void  readLine (char  buffer[])
{
    char  character;
    int   i = 0;

    do
    {
        character = getchar ();
        buffer[i] = character;
        ++i;
    }
    while ( character != '\n' );

    buffer[i - 1] = '\0';
}
#+end_src

** Initializing and Displaying Character Strings
C permits a character array to be initialized by simply specifying a
constant character string rather than a list of individual
characters. So, for example, the statement

char  word[] = { "Hello!" };

can be used to set up an array of characters called word with the
initial characters ’H’, ’e’, ’l’, ’l’, ’o’, ’!’, and ’\0’,
respectively. You can also omit the braces when initializing character
arrays in this manner. So, the statement

char word[] =  "Hello!";

is perfectly valid. Either statement is equivalent to the statement

Click here to view code image

char  word[] = { 'H', 'e', 'l', 'l', 'o', '!', '\0' };

If you’re explicitly specifying the size of the array, make certain
you leave enough space for the terminating null character. So, in

char  word[7] = { "Hello!" };

the compiler has enough room in the array to place the terminating null character. However, in

char  word[6] = { "Hello!" };

the compiler can’t fit a terminating null character at the end of the
array, and so it doesn’t put one there (and it doesn’t complain about
it either).
** Counting words

#+begin_src c
//  Function to determine if a character is alphabetic

#include <stdio.h>
#include <stdbool.h>

bool alphabetic (const char  c)
{
    if  ( (c >= 'a'  &&  c <= 'z') || (c >= 'A'  &&  c <= 'Z') )
       return true;
    else
       return false;
}

/* Function to count the number of words in a string */

int  countWords (const char  string[])
{
    int   i, wordCount = 0;
    bool  lookingForWord = true, alphabetic (const char  c);

    for ( i = 0;  string[i] != '\0';  ++i )
        if ( alphabetic(string[i]) )
        {
            if ( lookingForWord )
            {
                ++wordCount;
                lookingForWord = false;
            }
        }
        else
            lookingForWord = true;

    return wordCount;
}

int main (void)
{
    const char  text1[] = "Well, here goes.";
    const char  text2[] = "And here we go... again.";
    int   countWords (const char  string[]);

    printf ("%s - words = %i\n", text1, countWords (text1));
    printf ("%s - words = %i\n", text2, countWords (text2));

    return 0;
}
#+end_src

** Converting a String to its Integer Equivalent
  
#+begin_src c
// Function to convert a string to an integer

#include <stdio.h>

int  strToInt (const char  string[])
{
    int  i, intValue, result = 0;

    for  ( i = 0; string[i] >= '0' && string[i] <= '9'; ++i )
    {
        intValue = string[i] - '0';
        result = result * 10 + intValue;
    }

    return result;
}

int main (void)
{
    int  strToInt (const char  string[]);

    printf ("%i\n", strToInt("245"));
    printf ("%i\n", strToInt("100") + 25);
    printf ("%i\n", strToInt("13x5"));

    return 0;
}
#+end_src

** duplicate string(glibc 6)

#+begin_src c
char * __strdup (const char *s)
{
  size_t len = strlen (s) + 1;
  void *new = malloc (len);

  if (new == NULL)
    return NULL;

  return (char *) memcpy (new, s, len);
}
#+end_src

** lowercase
#+begin_src c
void lowercase (str)
    char *str;
{
    char ch;

    while (ch = *str) {
        if ((ch >= 'A') && (ch <= 'Z'))
            ch += 040;
        *str++ = ch;
    }
}
#+end_src

** null string
#+begin_src c
/*
 * null
 * check for null string
 */

boolean null (s)
    register char *s;
{
    register char c;

    if (!s)
	return(FALSE);
    while ((c = *s++) != '\0')
	if ((c != ' ') && (c != '\t'))
	    return(FALSE);
    return(TRUE);
}
#+end_src

** parse unsigned
#+begin_src c

/*
 * parse_unsigned
 * Parse an unsigned number.
 * If number starts with '0x', interpret as hexadecimal.
 * If number starts with '0', interpret as octal.
 * Anything else is assigned to be unsigned decimal.
 * Returns -1 on error.
 */

ulong parse_unsigned(buff)
    register char *buff;
{
    register char c;
    register ulong num;
    char *startptr;

    buff = (char *) deblank(buff);
    num = 0;
    c = *buff++;
    if (c == '0') {

	/*
	 * If '0x', we've parsed a hexadecimal number
	 */
	if ((*buff == 'x') || (*buff == 'X')) {
	    buff++;
	    c = cvu(*buff++);
	    startptr = buff;
	    while (((c >= '0') && (c <= '9')) || ((c >= 'A') && (c <= 'F'))) {
		if ((c >= '0') && (c <= '9')) 
		    num = num*16 + (c - '0');
		else
		    num = num*16 + (c - '7');
		c = cvu(*buff++);
	    }
	    if ((buff == startptr) || (term_char(c) == FALSE))
		return(-1);
	    return(num);
	}
	
	/*
	 * Check for an octal number, or just zero.
	 */
	startptr = buff-1;
	while ((c >= '0') && (c <= '7')) {
	    num = num*8 + (c - '0');
	    c = *buff++;
	}
	if (buff == startptr || (term_char(c) == FALSE))
	    return(-1);
	return(num);
    }

    /*
     * No leading zero, looks like a positive decimal number.
     */
    startptr = buff;
    while ((c >= '0') && (c <= '9')) {
	num = num*10 + (c - '0');
	c = *buff++;
    }
    if ((buff == startptr) || (term_char(c) == FALSE))
	return(-1);
    return(num);
}
#+end_src

** strtoupper
#+begin_src c
/*
 * Upper case a string
 */
void strtoupper(source)
    char *source;
{
    char *c;

    for (c = source; *c; c++)
	if (islower(*c))
	    *c = toupper(*c);
}
#+end_src

** strncat
#+begin_src c
void strncat (char *s1, char const *s2, ulong max)
{
     while (*s1)
         s1++;
     while ((max-- > 1) && (*s2)) {
         *s1 = *s2;
         s1++;
         s2++;
     }
     *s1 = 0;
}
#+end_src

** strcmp

#+begin_src c
/*
 * strcmp
 * case sensitive string match
 * returns an integer <,=,> 0 depending on whether s1 is <,=,> s2
 */

int strcmp (const char *s1, const char *s2)
{
    if ((!s1 && s2) || (s1 && !s2)) /* no match if only one ptr is NULL */
	return (int) (s1 - s2);	/* if one of these is NULL it will be the
				   lesser of the two values and therefore
				   we'll get the proper sign in the int */

    if (s1 == s2)		/* match if both ptrs the same (e.g. NULL) */
	return 0;

    while (*s1 == *s2++)
	if (*s1++ == '\0')
	     return 0;

    return *(unsigned char *)s1 - *(unsigned char *)--s2;
}
#+end_src

** strncpy
#+begin_src c
/*
 * copy at most 'max - 1' characters, always null terminate
 */
void strncpy (dst, src, max)
    char *dst;
    char *src;
    ulong max;
{
    while ((max-- > 1) && (*src)) {
	*dst = *src;
	dst++;
	src++;
    }
    *dst = '\0';
}
#+end_src

* storage classes, Linkage & memory management
** Storage classes
 C provides several different models, or storage classes , for storing data in memory.
 You can describe an object in terms of its storage duration , which is how long it stays in
 memory. You can describe an identifier used to access the object by its scope and its linkage ,
 which together indicate which parts of a program can use it. The different storage classes offer
 different combinations of scope, linkage, and storage duration.

** scope
 A C variable has one of the following scopes: block scope, function scope,
 function prototype scope, or file scope .

 *Function scope* applies just to labels used with goto statements. This means that even if a label
 first appears inside an inner block in a function, its scope extends to the whole function.

 *Function prototype scope* runs from the point the variable is defined to the end of the proto-
 type declaration.
 #+begin_src c
 void use_a_VLA(int n, int m, ar[n][m]);
 #+end_src 

 If you use names in the brackets, they have to be names declared earlier in the prototype.

 A variable with its definition placed outside of any function has file scope . A variable with file
 scope is visible from the point it is defined to the end of the file containing the definition.

** linkage
 A C variable has one of the following linkages: external linkage,internal linkage, or no linkage.

 Variables with block scope, function scope, or function proto- type scope have
 no linkage. That means they are private to the block, function, or prototype in
 which they are defined. A variable with file scope can have either internal or
 external linkage. A variable with external linkage can be used anywhere in a
 multifile program. A variable with internal linkage can be used anywhere in a
 single translation unit.

 The C Standard uses “file scope with internal linkage” to describe scope limited to one transla-
 tion unit (a source code file plus its included header files) and “file scope with external linkage”
 to describe scope that, at least potentially, extends to other translation units.

 So how can you tell whether a file scope variable has internal or external linkage? You look to
 see if the storage class specifier static is used in the external definition:

 #+begin_src c
 int giants = 5;
 static int dodgers = 3;
 int main()
 {
 ...
 }
 ...
 #+end_src 
 The variable giants can be used by other files that are part of the same program. The dodgers
 variable is private to this particular file, but can be used by any function in the file.

** Storage Duration
 A C object has one of the following four storage
 durations: static storage duration, thread storage duration, automatic storage duration, or allo-
 cated storage duration .

 If an object has static storage duration, it exists throughout program execution. Variables with
 file scope have static storage duration.

 An object with thread storage duration exists from
 when it’s declared until the thread terminates.

 Variables with block scope normally have automatic storage duration. These variables have
 memory allocated for them when the program enters the block in which they are defined, and
 the memory is freed when the block is exited.

 Variable-length arrays provide a slight exception in that they exist from the point of declara-
 tion to the end of the block rather than from the beginning of the block to the end.

** Static Variables with External Linkage
A static variable with external linkage has file scope, external linkage, and static storage dura-
tion. This class is sometimes termed the external storage class , and variables of this type are
called external variables . You create an external variable by placing a defining declaration
outside of any function. As a matter of documentation, an external variable can additionally
be declared inside a function that uses it by using the extern keyword.
#+begin_src c
  int Errupt;       /* externally defined variable */
  double Up[100];   /* externally defined array */ 
  extern char Coal; /* mandatory declaration if Coal defined in another file */
  void next(void);
  int main(void)
  {
     extern int Erupt;     /* optional declaration ... */
     extern double Up[]; /* optional declaration ... */
  }
  void next(void)
  {
  }
#+end_src 

** Initializing External Variables
Like automatic variables, external variables can be initialized explicitly. Unlike automatic vari-
ables, external variables are initialized automatically to zero if you don’t initialize them. This
rule applies to elements of an externally defined array, too. Unlike the case for automatic vari-
ables, you can use only constant expressions to initialize file scope variables:
#+begin_src c
int x = 10;   // ok, 10 is constant
int y = 3 + 20; //ok ,  a constant expression
size_t z = sizeof(int); //ok, a constant expression
int x2 = 2 * x;        //not ok, x is a variable
#+end_src 

** Static Variables with Internal Linkage
Variables of this storage class have static storage duration, file scope, and internal linkage. You
create one by defining it outside of any function (just as with an external variable) with the
storage class specifier static :
#+begin_src c
static int svil = 1;
int main(void)
{
#+end_src 

The ordinary external variable can
be used by functions in any file that’s part of the program, but the static variable with internal
linkage can be used only by functions in the same file.

#+begin_src c
int traveler = 1;
// external linkage
static int stayhome = 1; // internal linkage
int main()
{
extern int traveler; // use global traveler
extern int stayhome; // use global stayhome
...
#+end_src 

Both traveler and stayhome are global for this particular translation unit, but only traveler
can be used by code in other translation units.

** Storage Classes and Functions
Functions, too, have storage classes. A function can be either external (the default) or static.
An external function can be accessed by functions in other files, but a
static function can be used only within the defining file.
#+begin_src c
double gamma(double); /* external by default */
static double beta(int, int);
extern double delta(double, int);
#+end_src 

The functions gamma() and delta() can be used by functions in other files that are part of the
program, but beta() cannot. Because this beta() is restricted to one file

** Type qualifiers
*** The const Type Qualifier
#+begin_src c
const int nochange; /* qualifies m as being constant */
nochange = 12; /* not allowed */
#+end_src 

*** Using const with Pointers and Parameter Declarations
Using the const keyword when declaring a simple variable and an array is pretty easy. Pointers
are more complicated because you have to distinguish between making the pointer itself const
and making the value that is pointed to const . The declaration
#+begin_src c
const float * pf; /* pf points to a constant float value */
#+end_src 

establishes that pf points to a value that must remain constant. The value of pf itself can
be changed. For example, it can be set to point at another const value. In contrast, the
declaration
#+begin_src c
float * const pt; /* pt is a const pointer */
#+end_src 

says that the pointer pt itself cannot have its value changed. It must always point to the same
address, but the pointed-to value can change. Finally, the declaration
#+begin_src c
const float * const ptr;
#+end_src 

means both that ptr must always point to the same location and that the value stored at the
location must not change.
There is a third location in which you can place const :
#+begin_src c
float const * pfc; // same as const float * pfc;
#+end_src 

*** Type The volatile Type Qualifier
 The volatile qualifier tells the compiler that a variable can have its value altered by agencies
 other than the program.

*** The restrict Type Qualifier
The restrict keyword enhances computational support by giving the compiler permission
to optimize certain kinds of code. It can be applied only to pointers, and it indicates that a
pointer is the sole initial means of accessing a data object.

* File Input/Output
** mode
To bring some regularity to the handling of text files, C provides two ways of accessing a
file: binary mode and text mode.

** Levels of I/O
In addition to selecting the view of a file, you can, in most cases, choose between two levels of
I/O (that is, between two levels of handling access to files). Low-level I/O uses the fundamental
I/O services provided by the operating system. Standard high-level I/O uses a standard package
of C library functions and stdio.h header file definitions. The C standard supports only the
standard I/O package because there is no way to guarantee that all operating systems can be
represented by the same low-level I/O model.

** getc and putc functions
The two functions getc() and putc() work very much like getchar() and putchar() . The
difference is that you must tell these newcomers which file to use. So the following old standby
means “get a character from the standard input”:
ch = getchar();
However, this statement means “get a character from the file identified by fp ”:
ch = getc(fp);
Similarly, this statement means “put the character ch into the file identified by the FILE
pointer fpout ”:
putc(ch, fpout);

** End of File
A program reading data from a file needs to stop when it reaches the end of the file. How can
a program tell if it has reached the end? The getc() function returns the special value EOF if it
tries to read a character and discovers it has reached the end of the file.
#+begin_src c
// good design #1
int ch;
// int to hold EOF
FILE * fp;
fp = fopen("wacky.txt", "r");
ch = getc(fp);
// get initial input
while (ch != EOF)
{
  putchar(ch);
  // process input
  ch = getc(fp); // get next input
}
#+end_src

** The fclose() Function
The fclose(fp) function closes the file identified by fp , flushing buffers as needed. For a
program less casual than this one, you would check to see whether the file had been closed
successfully. The function fclose() returns a value of 0 if successful, and EOF if not:
#+begin_src c
if (fclose(fp) != 0)
printf("Error in closing file %s\n", argv[1]);
#+end_src 

** fseek() and ftell()
The fseek() function enables you to treat a file like an array and move directly to any partic-
ular byte in a file opened by fopen() .

The first of the three arguments to fseek() is a FILE pointer to the file being searched. The
file should have been opened by using fopen() .
The second argument to fseek() is called the offset . This argument tells how far to move from
the starting point (see the following list of mode starting points). The argument must be a long
value. It can be positive (move forward), negative (move backward), or zero (stay put).

#+begin_src c
/* reverse.c -- displays a file in reverse order */
#include <stdio.h>
#include <stdlib.h>
#define CNTL_Z '\032'
/* eof marker in DOS text files */
#define SLEN 81
int main(void)
{
  char file[SLEN];
  char ch;
  FILE *fp;
  long count, last;
  puts("Enter the name of the file to be processed:");
  scanf("%80s", file);
  if ((fp = fopen(file,"rb")) == NULL)
  {
    /* read-only mode */
    printf("reverse can't open %s\n", file);
    exit(EXIT_FAILURE);
  }
  fseek(fp, 0L, SEEK_END);
  /* go to end of file */
  last = ftell(fp);
  for (count = 1L; count <= last; count++)
  {
    fseek(fp, -count, SEEK_END); /* go backward */
    ch = getc(fp);
    if (ch != CNTL_Z && ch != '\r') /* MS-DOS files */
      putchar(ch);
  }
  putchar('\n');
  fclose(fp);
  return 0;
}
#+end_src 

The first of the three arguments to fseek() is a FILE pointer to the file being searched. The
file should have been opened by using fopen() .
The second argument to fseek() is called the offset . This argument tells how far to move from
the starting point (see the following list of mode starting points). The argument must be a long
value. It can be positive (move forward), negative (move backward), or zero (stay put).

The third argument is the mode, and it identifies the starting point. Since the ANSI standard,
the stdio.h header file specifies the following manifest constants for the mode:

| Mode     | Measures  | Offset   | From |
|----------+-----------+----------+------|
| SEEK_SET | Beginning | of       | file |
| SEEK_CUR | Current   | position |      |
| SEEK_END | End       | of       | file |

Here are some sample function calls, where fp is a file pointer:

#+begin_src c
fseek(fp, 0L, SEEK_SET); // go to the beginning of the file
fseek(fp, 10L, SEEK_SET); // go 10 bytes into the file
fseek(fp, 2L, SEEK_CUR); // advance 2 bytes from the current position
fseek(fp, 0L, SEEK_END); // go to the end of the file
fseek(fp, -10L, SEEK_END); // back up 10 bytes from the end of the file
#+end_src 
The value returned by fseek() is 0 if everything is okay, and -1 if there is an error, such as
attempting to move past the bounds of the file.
The ftell() function is type long , and it returns the current file location. Under ANSI C, it is
declared in stdio.h . As originally implemented in Unix, ftell() specifies the file position by
returning the number of bytes from the beginning, with the first byte being byte 0, and so on.

| Function call                      | Effect                                                    |
|------------------------------------+-----------------------------------------------------------|
| fseek(file , 0L        ,SEEK_SET)  | Go to the beginning of the file.                          |
| fseek(file , 0L        , SEEK_CUR) | Stay at the current position.                             |
| fseek(file , 0L        , SEEK_END) | Go to the file’s end.                                     |
| fseek(file , 0L        , SEEK_END) | Go to the file’s end.pos is a value returned by ftell() . |

@page@583

** examples
*** count the number of characters in a file
#+begin_src c
/* count.c -- using standard I/O */
#include <stdio.h>
#include <stdlib.h> // exit() prototype
int main(int argc, char *argv[])
{
  int ch;
  // place to store each character as read
  FILE *fp;
  // "file pointer"
  unsigned long count = 0;
  if (argc != 2)
  {
    printf("Usage: %s filename\n", argv[0]);
    exit(EXIT_FAILURE);
  }
  if ((fp = fopen(argv[1], "r")) == NULL)
  {
    printf("Can't open %s\n", argv[1]);
    exit(EXIT_FAILURE);
  }
  while ((ch = getc(fp)) != EOF)
  {
    putc(ch,stdout); // same as putchar(ch);
    count++;
  }
  fclose(fp);
  printf("File %s has %lu characters\n", argv[1], count);
  return 0;
}
#+end_src 

* libusb example

#+begin_src cpp
#include <iostream>
#include <libusb-1.0/libusb.h>
using namespace std;

void printdev(libusb_device *dev); //prototype of the function

int main() {
	libusb_device **devs; //pointer to pointer of device, used to retrieve a list of devices
	libusb_context *ctx = NULL; //a libusb session
	int r; //for return values
	ssize_t cnt; //holding number of devices in list
	r = libusb_init(&ctx); //initialize a library session
	if(r < 0) {
		cout<<"Init Error "<<r<<endl; //there was an error
				return 1;
	}
	libusb_set_debug(ctx, 3); //set verbosity level to 3, as suggested in the documentation
	cnt = libusb_get_device_list(ctx, &devs); //get the list of devices
	if(cnt < 0) {
		cout<<"Get Device Error"<<endl; //there was an error
	}
	cout<<cnt<<" Devices in list."<<endl; //print total number of usb devices
		ssize_t i; //for iterating through the list
	for(i = 0; i < cnt; i++) {
				printdev(devs[i]); //print specs of this device
		}
		libusb_free_device_list(devs, 1); //free the list, unref the devices in it
		libusb_exit(ctx); //close the session
		return 0;
}

void printdev(libusb_device *dev) {
	libusb_device_descriptor desc;
	int r = libusb_get_device_descriptor(dev, &desc);
	if (r < 0) {
		cout<<"failed to get device descriptor"<<endl;
		return;
	}
	cout<<"Number of possible configurations: "<<(int)desc.bNumConfigurations<<"  ";
	cout<<"Device Class: "<<(int)desc.bDeviceClass<<"  ";
	cout<<"VendorID: "<<desc.idVendor<<"  ";
	cout<<"ProductID: "<<desc.idProduct<<endl;
	libusb_config_descriptor *config;
	libusb_get_config_descriptor(dev, 0, &config);
	cout<<"Interfaces: "<<(int)config->bNumInterfaces<<" ||| ";
	const libusb_interface *inter;
	const libusb_interface_descriptor *interdesc;
	const libusb_endpoint_descriptor *epdesc;
	for(int i=0; i<(int)config->bNumInterfaces; i++) {
		inter = &config->interface[i];
		cout<<"Number of alternate settings: "<<inter->num_altsetting<<" | ";
		for(int j=0; j<inter->num_altsetting; j++) {
			interdesc = &inter->altsetting[j];
			cout<<"Interface Number: "<<(int)interdesc->bInterfaceNumber<<" | ";
			cout<<"Number of endpoints: "<<(int)interdesc->bNumEndpoints<<" | ";
			for(int k=0; k<(int)interdesc->bNumEndpoints; k++) {
				epdesc = &interdesc->endpoint[k];
				cout<<"Descriptor Type: "<<(int)epdesc->bDescriptorType<<" | ";
				cout<<"EP Address: "<<(int)epdesc->bEndpointAddress<<" | ";
			}
		}
	}
	cout<<endl<<endl<<endl;
	libusb_free_config_descriptor(config);
}

#+end_src 

compile: ~$ g++ test.cpp -lusb-1.0
http://www.dreamincode.net/forums/topic/148707-introduction-to-using-libusb-10/

* utils functions
  
#+begin_src c

#define _GNU_SOURCE

#ifdef DEBUG
#include <stdio.h>
#endif
#include <stdlib.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <errno.h>
#include <limits.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>

#include "includes.h"
#include "util.h"
#include "table.h"

int util_strlen(char *str)
{
    int c = 0;

    while (*str++ != 0)
        c++;
    return c;
}


BOOL util_strncmp(char *str1, char *str2, int len)
{
    int l1 = util_strlen(str1), l2 = util_strlen(str2);

    if (l1 < len || l2 < len)
        return FALSE;

    while (len--)
    {
        if (*str1++ != *str2++)
            return FALSE;
    }

    return TRUE;
}

BOOL util_strcmp(char *str1, char *str2)
{
    int l1 = util_strlen(str1), l2 = util_strlen(str2);

    if (l1 != l2)
        return FALSE;

    while (l1--)
    {
        if (*str1++ != *str2++)
            return FALSE;
    }

    return TRUE;
}

int util_strcpy(char *dst, char *src)
{
    int l = util_strlen(src);

    util_memcpy(dst, src, l + 1);

    return l;
}

void util_memcpy(void *dst, void *src, int len)
{
    char *r_dst = (char *)dst;
    char *r_src = (char *)src;
    while (len--)
        *r_dst++ = *r_src++;
}

void util_zero(void *buf, int len)
{
    char *zero = buf;
    while (len--)
        *zero++ = 0;
}

int util_atoi(char *str, int base)
{
	unsigned long acc = 0;
	int c;
	unsigned long cutoff;
	int neg = 0, any, cutlim;

	do {
		c = *str++;
	} while (util_isspace(c));
	if (c == '-') {
		neg = 1;
		c = *str++;
	} else if (c == '+')
		c = *str++;

	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
	cutlim = cutoff % (unsigned long)base;
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *str++) {
		if (util_isdigit(c))
			c -= '0';
		else if (util_isalpha(c))
			c -= util_isupper(c) ? 'A' - 10 : 'a' - 10;
		else
			break;
            
		if (c >= base)
			break;

		if (any < 0 || acc > cutoff || acc == cutoff && c > cutlim)
			any = -1;
		else {
			any = 1;
			acc *= base;
			acc += c;
		}
	}
	if (any < 0) {
		acc = neg ? LONG_MIN : LONG_MAX;
	} else if (neg)
		acc = -acc;
	return (acc);
}

char *util_itoa(int value, int radix, char *string)
{
    if (string == NULL)
        return NULL;

    if (value != 0)
    {
        char scratch[34];
        int neg;
        int offset;
        int c;
        unsigned int accum;

        offset = 32;
        scratch[33] = 0;

        if (radix == 10 && value < 0)
        {
            neg = 1;
            accum = -value;
        }
        else
        {
            neg = 0;
            accum = (unsigned int)value;
        }

        while (accum)
        {
            c = accum % radix;
            if (c < 10)
                c += '0';
            else
                c += 'A' - 10;

            scratch[offset] = c;
            accum /= radix;
            offset--;
        }
        
        if (neg)
            scratch[offset] = '-';
        else
            offset++;

        util_strcpy(string, &scratch[offset]);
    }
    else
    {
        string[0] = '0';
        string[1] = 0;
    }

    return string;
}

int util_memsearch(char *buf, int buf_len, char *mem, int mem_len)
{
    int i, matched = 0;

    if (mem_len > buf_len)
        return -1;

    for (i = 0; i < buf_len; i++)
    {
        if (buf[i] == mem[matched])
        {
            if (++matched == mem_len)
                return i + 1;
        }
        else
            matched = 0;
    }

    return -1;
}

int util_stristr(char *haystack, int haystack_len, char *str)
{
    char *ptr = haystack;
    int str_len = util_strlen(str);
    int match_count = 0;

    while (haystack_len-- > 0)
    {
        char a = *ptr++;
        char b = str[match_count];
        a = a >= 'A' && a <= 'Z' ? a | 0x60 : a;
        b = b >= 'A' && b <= 'Z' ? b | 0x60 : b;

        if (a == b)
        {
            if (++match_count == str_len)
                return (ptr - haystack);
        }
        else
            match_count = 0;
    }

    return -1;
}

ipv4_t util_local_addr(void)
{
    int fd;
    struct sockaddr_in addr;
    socklen_t addr_len = sizeof (addr);

    errno = 0;
    if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
    {
#ifdef DEBUG
        printf("[util] Failed to call socket(), errno = %d\n", errno);
#endif
        return 0;
    }

    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INET_ADDR(8,8,8,8);
    addr.sin_port = htons(53);

    connect(fd, (struct sockaddr *)&addr, sizeof (struct sockaddr_in));

    getsockname(fd, (struct sockaddr *)&addr, &addr_len);
    close(fd);
    return addr.sin_addr.s_addr;
}

char *util_fdgets(char *buffer, int buffer_size, int fd)
{
    int got = 0, total = 0;
    do 
    {
        got = read(fd, buffer + total, 1);
        total = got == 1 ? total + 1 : total;
    }
    while (got == 1 && total < buffer_size && *(buffer + (total - 1)) != '\n');

    return total == 0 ? NULL : buffer;
}

static inline int util_isupper(char c)
{
    return (c >= 'A' && c <= 'Z');
}

static inline int util_isalpha(char c)
{
    return ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));
}

static inline int util_isspace(char c)
{
    return (c == ' ' || c == '\t' || c == '\n' || c == '\12');
}

static inline int util_isdigit(char c)
{
    return (c >= '0' && c <= '9');
}

#+end_src

* misc
** endian
#+begin_src c
int endian()
{
    /* 1 ==> big-endian
     * 0 ==> little-endian
     * -1 ==> unknown
     */
    int ret = -1;
    union{
        short s;
        char c[sizeof(short)];
    } un;

    un.s = 0x0102;
//    printf("%s: ", CPU_VENDOR_OS);
    if (sizeof(short) == 2){
        if(un.c[0] == 1 && un.c[1] == 2){
//            printf("big-endian\n");
                ret = 1;
        }else if(un.c[0] == 2 && un.c[1] == 1){
//            printf("little-endian\n");
            ret = 0;
        }else{
//            printf("unkonwn\n");
            ret = -1;
        }
    }

    return ret;
}

#+end_src

* useful functions
** error_exit
#+begin_src c
#include <stdlib.h>
#include <stdio.h>
void error_exit(unsigned int error_n) // Print a last error message
{
  // and exit the program.
  char * error_msg[] = { "Unknown error code.\n",
                        "Insufficient memory.\n",
                        "Illegal memory access.\n" };
  unsigned int arr_len = sizeof(error_msg)/sizeof(char *);
  if ( error_n >= arr_len )
      error_n = 0;
  fputs( error_msg[error_n], stderr );
  exit(1);
}
#+end_src

** swapf
   
#+begin_src c

inline void swapf( float *p1, float *p2 ) // An inline function.
{
  float tmp = *p1; *p1 = *p2; *p2 = tmp;
}
// The function selection_sortf() uses the selection-sort
// algorithm to sort an array of float elements.
// Arguments:
// An array of float, and its length.
// Return value: None.
void selection_sortf( float
{
  register int i, j, mini;
//search for minimum starting index i
  for( i  =0; i < n - 1; ++i)
  {
     mini = i;
     for(j = i + 1; j < n ;++j)
        if(a[j] < a[mini])
           mini = j;
     swapf(a+i, a+mini);  //swap the  mimimum with the element at index i;
  }
  }
#+end_src

** variable number of arguments
#+begin_src c
// the mandatory first argument indicates the number of arguments.
double add( int n, ... )
{
  int i = 0;
  double sum = 0.0;
  va_list argptr;
  va_start( argptr, n );
  for ( i = 0; i < n; ++i )
    sum += va_arg( argptr, double );
  va_end( argptr );
  return sum;
}
#+end_src

** timestamp
#+begin_src c
#include <time.h>
void timestamp()
{
    time_t ltime; /* calendar time */
    ltime=time(NULL); /* get current cal time */
    printf("%s",asctime( localtime(&ltime) ) );
}
#+end_src

* algorithms
** sorting
*** bubble sort
#+begin_src c
#include <stdio.h>
#define MAX 10
void swap(int *x,int *y)
{
   int temp;
   temp = *x;
   *x = *y;
   *y = temp;
}
void bsort(int list[], int n)
{
   int i,j;
   for(i=0;i<(n-1);i++)
      for(j=0;j<(n-(i+1));j++)
             if(list[j] > list[j+1])
                    swap(&list[j],&list[j+1]);
}
void readlist(int list[],int n)
{
   int i;
   printf("Enter the elements\n");
   for(i=0;i<n;i++)
       scanf("%d",&list[i]);
}

void printlist(int list[],int n)
{
   int i;
   printf("The elements of the list are: \n");
   for(i=0;i<n;i++)
      printf("%d\t",list[i]);
}

void main()
{
   int list[MAX], n;
   printf("Enter the number of elements in the list max = 10\n");
   scanf("%d",&n);
   readlist(list,n);
   printf("The list before sorting is:\n");
   printlist(list,n);
   bsort(list,n);
   printf("The list after sorting is:\n");
   printlist(list,n);
}
#+end_src

*** quick sort

In the quick sort method, an array a[1],…..,a[n] is sorted by selecting some
value in the array as a key element. We then swap the first element of the list
with the key element so that the key will be in the first position. We then
determine the key's proper place in the list. The proper place for the key is
one in which all elements to the left of the key are smaller than the key, and
all elements to the right are larger.

To obtain the key's proper position, we traverse the list in both directions
using the indices i and j, respectively. We initialize i to that index that is
one more than the index of the key element. That is, if the list to be sorted
has the indices running from m to n, the key element is at index m, hence we
initialize i to (m+1). The index i is incremented until we get an element at the
ith position that is greater than the key value. Similarly, we initialize j to n
and go on decrementing j until we get an element with a value less than the
key's value.

We then check to see whether the values of i and j have crossed each other. If
not, we interchange the elements at the key (mth)position with the elements at
the jth position. This brings the key element to the jth position, and we find
that the elements to its left are less than it, and the elements to its right
are greater than it. Therefore we can split the list into two sublists. The
first sublist is composed of elements from the mth position to the (j–1)th
position, and the second sublist consists of elements from the (j+1)th position
to the nth position. We then repeat the same procedure on each of the sublists
separately.

Choice of the key

We can choose any entry in the list as the key. The choice of the first entry is
often a poor choice for the key, since if the list has already been sorted,
there will be no element less than the first element selected as the key. So,
one of the sublists will be empty. So we choose a key near the center of the
list in the hope that our choice will partition the list in such a manner that
about half of the elements will end up on one side of the key, and half will end
up on the other.

Therefore the function getkeyposition is

#+begin_src c
int getkeyposition(int i,j)
{
   return(( i+j )/ 2);
}
#+end_src 
The choice of the key near the center is also arbitrary, so it is not necessary
to always divide the list exactly in half. It may also happen that one sublist
is much larger than the other. So some other method of selecting a key should be
used. A good way to choose a key is to use a random number generator to choose
the position of the next key in each activation of quick sort. Therefore, the
function getkeyposition is:

#+begin_src c
int getkeyposition(int i,j)
{
   return(random number in the range of i to j);
}
#+end_src 

#+begin_src c
#include <stdio.h>
#define MAX 10
void swap(int *x,int *y)
{
   int temp;
   temp = *x;
   *x = *y;
   *y = temp;
}
int getkeyposition(int i,int j )
{
   return((i+j) /2);
}
void qsort(int list[],int m,int n)
{
   int key,i,j,k;
   if( m < n)
   {
      k = getkeyposition(m,n);
      swap(&list[m],&list[k]);
      key = list[m];
      i = m+1;
      j = n;
      while(i <= j)
      {
         while((i <= n) && (list[i] <= key))
                i++;
         while((j >= m) && (list[j] > key))
                j-;
         if( i < j)
                swap(&list[i],&list[j]);
      }
      swap(&list[m],&list[j]);
      qsort(list[],m,j-l);
      qsort(list[],j+1,n);
   }
}
void readlist(int list[],int n)
{
   int i;
   printf("Enter the elements\n");
   for(i=0;i<n;i++)
       scanf("%d",&list[i]);
}
void printlist(int list[],int n)
{
   int i;
   printf("The elements of the list are: \n");
   for(i=0;i<n;i++)
       printf("%d\t",list[i]);
}

void main()
{
   int list[MAX], n;
   printf("Enter the number of elements in the list max = 10\n");
   scanf("%d",&n);
   readlist(list,n);
   printf("The list before sorting is:\n");
   printlist(list,n);
   qsort(list,0,n-1);
   printf("\nThe list after sorting is:\n");
   printlist(list,n);
}
#+end_src 
Example
Input
Enter the number of elements in the list, max = 10
10
Enter the elements
7
99
23
11
65
43
23
21
21
77
Output
The list before sorting is:
The elements of the list are:
7 99 23 11 65 43 23 21 21 77
The list after sorting is:
The elements of the list are:
7 11 21 21 23 23 43 65 77 99

*** merge sort
This is another sorting technique having the same average-case and worst-case
time complexities, but requiring an additional list of size n.

The technique that we use is the merging of the two sorted lists of size m and n
to form a single sorted list of size (m + n). Given a list of size n to be
sorted, instead of viewing it to be one single list of size n, we start by
viewing it to be n lists each of size 1, and merge the first list with the
second list to form a single sorted list of size 2.

Similarly, we merge the third and the fourth lists to form a second single
sorted list of size 2, and so on. This completes one pass. We then consider the
first sorted list of size 2 and the second sorted list of size 2, and merge them
to form a single sorted list of size 4.

Similarly, we merge the third and the fourth sorted lists, each of size 2, to
form the second single sorted list of size 4, and so on. This completes the
second pass.

In the third pass, we merge these adjacent sorted lists, each of size 4, to form
sorted lists of size 8. We continue this process until we finally obtain a
single sorted list of size n as shown next.

To carry out this task, we require a function to merge the two sorted lists of
size m and n to form a single sorted list of size (m + n). We also require a
function to carry out one pass of the list to merge the adjacent sorted lists of
the specified size. This is because we have to carry out repeated passes of the
given list.

In the first pass, we merge the adjacent lists of size 1. In the second pass, we
merge the adjacent lists of size 2, and so on. Therefore, we will call this
function by varying the size of the lists to be merged.

#+begin_src c
#include <stdio.h>
#define MAX 10
void merge(int list[],int list1[],int k,int m,int n)
{
    int i,j;
   i=k;
   j = m+1;
   while( i <= m && j <= n)
   {
      if(list[i] <= list[j])
      {
             list1[k] = list[i];
         i++;
         k++;
      }
      else
      {
            list1[k] = list[j];
         j++;
         k++;
      }
   }
   while(i <= m)
   {
         list1[k] = list[i];
      i++;
      k++;
   }
   while (i <= n )
   {
         list1[k] = list[j];
      j++;
      k++;
   }
}

void mpass( int list[],int list1[],int l,int n)
{
   int i;
   i = 0;
   while( i <= (n-2*l+1))
   {
      merge(list,list1,i,(i+l-1),(i+2*l-1));
      i = i + 2*l;
   }
   if((i+l-1) < n)
       merge(list,list1,i,(i+l-1),n);
   else
       while (i <= n )
       {
              list1[i] = list[i];
              i++;
       }
   }
   void msort(int list[], int n )
   {
      int l;
      int list1[MAX];
      l =1;
      while (l <= n )
      {
         mpass(list,list1,l,n);
         l = l*2;
         mpass(list1,list,l,n);
         l = l*2;
      }
   }

   void readlist(int list[],int n)
   {
      int i;
      printf("Enter the elements\n");
      for(i=0;i<n;i++)
          scanf("%d",&list[i]);
   }

   void printlist(int list[],int n)
   {
      int i;
      printf("The elements of the list are: \n");
      for(i=0;i<n;i++)
          printf("%d\t",list[i]);
   }

void main()
{
   int list[MAX], n;
   printf("Enter the number of elements in the list max = 10\n");
   scanf("%d",&n);
   readlist(list,n);
   printf("The list before sorting is:\n");
   printlist(list,n);
   msort(list,n-1);
   printf("The list after sorting is:\n");
   printlist(list,n);
}
#+end_src 
Example
Input
Enter the number of elements in the list, max = 10
10
Enter the elements
11
2
45
67
33
22
11
0
34
23
Output
The list before sorting has the following elements:
11 2 45 67 33 22 11 0 34 23
The list after sorting has the following elements:
0 2 11 11 22 23 33 34 45 67

*** HEAPSORT
Heapsort is a sorting technique that sorts a contiguous list of length n with
O(n log2 (n)) comparisons and movement of entries, even in the worst case. Hence
it achieves the worst-case bounds better than those of quick sort, and for the
contiguous list, it is better than merge sort, since it needs only a small and
constant amount of space apart from the list being sorted.

Heapsort proceeds in two phases. First, all the entries in the list are arranged
to satisfy the heap property, and then the top of the heap is removed and
another entry is promoted to take its place repeatedly. Therefore, we need a
function that builds an initial heap to arrange all the entries in the list to
satisfy the heap property. The function that builds an initial heap uses a
function that adjusts the ith entry in the list, whose entries at 2i and 2i + 1
positions already satisfy the heap property in such a manner that the entry at
the ith position in the list will also satisfy the heap property.

#+begin_src c
#include <stdio.h>
#define MAX 10
void swap(int *x,int *y)
{
   int temp;
   temp = *x;
   *x = *y;
   *y = temp;
}

void adjust( int list[],int i, int n)
{
   int j,k,flag;
   k = list[i];
   flag = 1;
   j = 2 * i;
   while(j <= n && flag)
   {
      if(j < n && list[j] < list[j+1])
      j++;
      if( k >= list[j])
               flag =0;
      else
      {
         list[j/2] = list[j];
         j = j *2;
      }
   }
   list [j/2] = k;
}

void build_initial_heap( int list[], int n)
{
   int i;
   for(i=(n/2);i>=0;i-)
       adjust(list,i,n-1);
}

void heapsort(int list[],int n)
{
   int i;
   build_initial_heap(list,n);
   for(i=(n-2); i>=0;i-)
   {
      swap(&list[0],&list[i+1]);
      adjust(list,0,i);
   }
}

void readlist(int list[],int n)
{
   int i;
   printf("Enter the elements\n");
   for(i=0;i<n;i++)
       scanf("%d",&list[i]);
}

void printlist(int list[],int n)
{
   int i;
   printf("The elements of the list are: \n");
   for(i=0;i<n;i++)
       printf("%d\t",list[i]);
}

void main()
{
   int list[MAX], n;
   printf("Enter the number of elements in the list max = 10\n");
   scanf("%d",&n);
   readlist(list,n);
   printf("The list before sorting is:\n");
   printlist(list,n);
   heapsort(list,n);
   printf("The list after sorting is:\n");
   printlist(list,n);
}
#+end_src 

Example

Input
Enter the number of elements in the list, max = 10
10
Enter the elements
56
1
34
42
90
66
87
12
21
11

Output
The list before sorting is:
The elements of the list are:
56 1 34 42 90 66 87 12 21 11
The list after sorting is:
The elements of the list are:
1 11 12 21 34 42 56 66 87 90
** HASHING FUNCTIONS
Some of the methods of defining a hash function are discussed in the following paragraphs.

- Modular Arithmetic
In modular arithmetic, first the key is converted to an integer, then it is
divided by the size of the index range, and the remainder is taken to be the
hash value. The spread achieved depends very much on the modulus. If the modulus
is the power of small integers such as 2 or 10, then many keys tend to map into
the same index, while other indices remain unused. The best choice for the
modulus is often, but not always, a prime number, which usually has the effect
of spreading the keys quite uniformly.

 - Truncation
Truncation ignores part of the key, and uses the remainder directly as the hash
value (using numeric code to represent non-numeric field data). If the keys, for
example, are eight-digit numbers and the hash table has 1000 entries, then the
first, second, and fifth digits from the right side might make the hash value.
So, 62538194 maps to 394. It is a fast method, but it often fails to distribute
keys evenly.

 - Folding
In folding, the identifier is partitioned into several parts, all but the last
part being of the same length. These parts are then added together to obtain the
hash value. For example, an eight-digit integer can be divided into groups of
three, three, and two digits. The groups are then added together, and truncated,
if necessary, to be in the proper range of indices. So 62538149 maps to 625 +
381 + 94 = 1100, truncated to 100. Since all information in the key can affect
the value of the function, folding often achieves a better spread of indices
than truncation.

 - Mid-square method
In this method, the identifier is squared (using numeric code to represent non-
numeric field data), and then the appropriate number of bits from the middle of
the square are used to get the hash value. Since the middle bits of the square
usually depend on all the characters in the identifier, it is expected that
different identifiers will result in different values. The number of middle bits
that we select depends on table size. Therefore, if r is the number of middle
bits used to form the hash value, then the table size will be 2r. So when we use
the mid- square method, the table size should be a power of 2.

#+begin_src c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define SIZE 50
#define MAX 10
typedef struct node
{
    char symbol[MAX];
    int value;
    struct node *next;
} entry;
typedef entry *entry_ptr;

int hash_value(char * name)
{
    int sum=0;
    while( *name != '\0')
    {
        sum += *name;
        name++;
    }
    return(sum % SIZE);
}
void initialize( entry_ptr table[])
{
    int i=0;
    for(i=0; i<SIZE; i++)
        table[i] = NULL;
}
void insert( entry_ptr table[], char *name, int val)
{
    int h, flag = 1;
    entry_ptr temp;
    h = hash_value(name);
    temp = table[h];
    while( temp != NULL && flag )
    {
        if( strcmp(temp->symbol,name) == 0)
        {
            printf("The symbol %s is already present in the table\n",name);
                   flag =0;;
        }
        temp=temp->next;
    }
    if(flag)
    {
        temp = (entry_ptr) malloc(sizeof( entry));
        if(temp == NULL)
        {
            printf("ERRRR .......\n");
            exit(0);
        }
        strcpy(temp->symbol,name);
        temp->value = val;
        temp->next = table[h];
        table[h]=temp;
    }
}
void retrieve( entry_ptr table[],char *name)
{
    int h,flag =1;
    entry_ptr temp;
    h = hash_value(name);
    temp = table[h];
    while( temp != NULL && flag)
    {
        if( strcmp(temp->symbol,name) == 0)
        {
            printf("The symbol %s is present in the table and having value = %d\n",
                   name,temp->value);
            flag =0;
        }
        temp=temp->next;
    }
    if(flag == 1)
        printf("The symbol %s is not present in the table \n",name);
}
void main()
{
    entry_ptr table[SIZE];
    char name[MAX];
    int value,n;
    initialize(table);
    do
    {
        do
        {
            printf("Enter the symbol and value pair to be inserted\n");
            scanf("%s %d",name,&value);
            insert(table,name,value);
            printf("Enter 1 to continue\n");
            scanf("%d",&n);
        }
        while(n == 1);
        do
        {
            printf("Enter the symbol whose value is to be retrieved\n");
            scanf("%s",name);
            retrieve(table,name);
            printf("Enter 1 to continue\n");
            scanf("%d",&n);
        }while( n == 1);
        printf("Eneter 1 to continue\n");
        scanf("%d",&n);
    }while(n == 1);
}
#+end_src

** stack
*** Array Implementation of a Stack

When an array is used to implement a stack, the push and pop operations are
realized by using the operations available on an array. The limitation of an
array implementation is that the stack cannot grow and shrink dynamically as per
the requirement.

Program
A complete C program to implement a stack using an array appears here:

#+begin_src c
#include <stdio.h>
#define MAX 10 /* The maximum size of the stack */
#include <stdlib.h>

void push(int stack[], int *top, int value)
{
   if(*top < MAX )
   {
      *top = *top + 1;
      stack[*top] = value;
   }
  else
  {
      printf("The stack is full can not push a value\n");
      exit(0);
   }
}

void pop(int stack[], int *top, int * value)
{
   if(*top >= 0 )
   {
       *value = stack[*top];
      *top = *top - 1;
   }
   else
   {
      printf("The stack is empty can not pop a value\n");
      exit(0);
   }
}

void main()
{
   int stack[MAX];
   int top = -1;
   int n,value;
   do
   {
      do
      {
            printf("Enter the element to be pushed\n");
         scanf("%d",&value);
         push(stack,&top,value);
            printf("Enter 1 to continue\n");
         scanf("%d",&n);
      } while(n == 1);

      printf("Enter 1 to pop an element\n");
      scanf("%d",&n);
      while( n == 1)
      {
            pop(stack,&top,&value);
         printf("The value poped is %d\n",value);
            printf("Enter 1 to pop an element\n");
            scanf("%d",&n);
      }
      printf("Enter 1 to continue\n");
      scanf("%d",&n);
   } while(n == 1);
}
#+end_src

Example
Enter the element to be pushed
10
Enter 1 to continue
1
Enter the element to be pushed
20
Enter 1 to continue
0
Enter 1 to pop an element
1
The value popped is 20
Enter 1 to pop an element
0
Enter 1 to continue
1
Enter the element to be pushed
40
Enter 1 to continue
1
Enter the element to be pushed
50
Enter 1 to continue
0
Enter 1 to pop an element
1
The value popped is 50
Enter 1 to pop an element
1
The value popped is 40 Enter 1 to pop an element
1
The value popped is 10 Enter 1 to pop an element
0
Enter 1 to continue
0
*** Implementation of a Stack Using Linked Representation
#+begin_src c
# include <stdio.h>
# include <stdlib.h>
struct node
{
   int data;
   struct node *link;
};
struct node *push(struct node *p, int value)
{
   struct node *temp;
   temp=(struct node *)malloc(sizeof(struct node));
       /* creates new node
       using data value
       passed as parameter */
   if(temp==NULL)
   {
      printf("No Memory available Error\n");
      exit(0);
   }
   temp->data = value;
   temp->link = p;
   p = temp;
   return(p);
}

struct node *pop(struct node *p, int *value)
{
   struct node *temp;
   if(p==NULL)
   {
      printf(" The stack is empty can not pop Error\n");
      exit(0);
   }
   *value = p->data;
   temp = p;
   p = p->link;
   free(temp);
   return(p);
}

void main()
{
   struct node *top = NULL;
   int n,value;
   do
   {
      do
      {
            printf("Enter the element to be pushed\n");
         scanf("%d",&value);
         top = push(top,value);
         printf("Enter 1 to continue\n");
         scanf("%d",&n);
      } while(n == 1);

      printf("Enter 1 to pop an element\n");
      scanf("%d",&n);
      while( n == 1)
      {
            top = pop(top,&value);
         printf("The value poped is %d\n",value);
            printf("Enter 1 to pop an element\n");
            scanf("%d",&n);
      }
      printf("Enter 1 to continue\n");
      scanf("%d",&n);
   } while(n == 1);
}

#+end_src

*** APPLICATIONS OF STACKS( expression evaluation)
Introduction

One of the applications of the stack is in expression evaluation. A complex
assignment statement such as a = b + c*d/e–f may be interpreted in many
different ways. Therefore, to give a unique meaning, the precedence and
associativity rules are used. But still it is difficult to evaluate an
expression by computer in its present form, called the infix notation. In infix
notation, the binary operator comes in between the operands. A unary operator
comes before the operand. To get it evaluated, it is first converted to the
postfix form, where the operator comes after the operands. For example, the
postfix form for the expression a*(b–c)/d is abc–*d/. A good thing about postfix
expressions is that they do not require any precedence rules or parentheses for
unique definition. So, evaluation of a postfix expression is possible using a
stack-based algorithm.

Program
Convert an infix expression to prefix form.
#+begin_src c
#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define N 80

typedef enum {FALSE, TRUE} bool;

#include "stack.h"
#include "queue.h"

#define NOPS 7

char operators [] = "()^/*+-";
int priorities[] = {4,4,3,2,2,1,1};
char associates[] = " RLLLL";

char t[N]; char *tptr = t; // this is where prefix will be saved.
int getIndex( char op ) {
    /*
     * returns index of op in operators.
     */
    int i;
    for( i=0; i<NOPS; ++i )
        if( operators[i] == op )
               return i;
    return -1;
}
int getPriority( char op ) {
    /*
     * returns priority of op.
     */
    return priorities[ getIndex(op) ];
}

char getAssociativity( char op ) {
    /*
     * returns associativity of op.
     */
    return associates[ getIndex(op) ];
}

void processOp( char op, queue *q, stack *s ) {
    /*
     * performs processing of op.
     */
    switch(op) {
       case ')':
              printf( "\t S pushing )...\n" );
              sPush( s, op );
              break;
       case '(':
              while( !qEmpty(q) ) {
                     *tptr++ = qPop(q);
                     printf( "\tQ popping %c...\n", *(tptr-1) );
              }
              while( !sEmpty(s) ) {
                     char popop = sPop(s);
                     printf( "\tS popping %c...\n", popop );
                     if( popop == ')' )
                            break;
                     *tptr++ = popop;
              }
              break;
       default: {
              int priop;    // priority of op.
              char topop;   // operator on stack top.
              int pritop;   // priority of topop.
              char asstop;  // associativity of topop.
              while( !sEmpty(s) ) {
                     priop = getPriority(op);
                     topop = sTop(s);
                     pritop = getPriority(topop);
                     asstop = getAssociativity(topop);
if( pritop < priop || (pritop == priop && asstop == 'L')
    || topop == ')' ) // IMP.
                      break;
                 while( !qEmpty(q) ) {
                        *tptr++ = qPop(q);
                 printf( "\tQ popping %c...\n", *(tptr-1) );
                 }
                 *tptr++ = sPop(s);
                 printf( "\tS popping %c...\n", *(tptr-1) );
         }
         printf( "\tS pushing %c...\n", op );
         sPush( s, op );
         break;
      }
   }
}
bool isop( char op ) {
    /*
     * is op an operator?
     */
    return (getIndex(op) != -1);
}

char *in2pre( char *str ) { /*
     * returns valid infix expr in str to prefix.
     */
    char *sptr;
    queue q = {NULL};
    stack s = NULL;
    char *res = (char *)malloc( N*sizeof(char) );
    char *resptr = res;
    tptr = t;
    for( sptr=str+strlen(str)-1; sptr!=str-1; -sptr ) {
       printf( "processing %c tptr-t=%d...\n", *sptr, tptr-t );
       if( isalpha(*sptr) ) // if operand.
              qPush( &q, *sptr );
       else if( isop(*sptr) )      // if valid operator.
              processOp( *sptr, &q, &s );
       else if( isspace(*sptr) )    // if whitespace.
              ;
       else {
              fprintf( stderr, "ERROR:invalid char %c.\n", *sptr );
              return "";
       }
   }
   while( !qEmpty(&q) ) {
       *tptr++ = qPop(&q);
       printf( "\tQ popping %c...\n", *(tptr-1) );
   }
   while( !sEmpty(&s) ) {
       *tptr++ = sPop(&s);
       printf( "\tS popping %c...\n", *(tptr-1) );
   }
   *tptr = 0;
   printf( "t=%s.\n", t );
   for( -tptr; tptr!=t-1; -tptr ) {
      *resptr++ = *tptr;
   }
   *resptr = 0;

   return res;
}

int main() {
    char s[N];

    puts( "enter infix freespaces max 80." );
    gets(s);
    while(*s) {
       puts( in2pre(s) );
       gets(s);
    }

   return 0;
}
#+end_src

** queue
*** Array Implementation of a queue 

 When an array is used to implement a queue, then the insert and delete
 operations are realized using the operations available on an array. The
 limitation of an array implementation is that the queue cannot grow and shrink
 dynamically as per the requirement.

 Program
 A complete C program to implement a queue by using an array is shown here:

 #+begin_src c
 #include <stdio.h>
 #define MAX 10 /* The maximum size of the queue */
 #include <stdlib.h>

 void insert(int queue[], int *rear, int value)
 {
    if(*rear < MAX-1)
    {
       *rear= *rear +1;
       queue[*rear] = value;
    }
    else
    {
       printf("The queue is full can not insert a value\n");
       exit(0);
    }
 }

 void delete(int queue[], int *front, int rear, int * value)
 {
    if(*front == rear)
    {
       printf("The queue is empty can not delete a value\n");
       exit(0);
    }
    *front = *front + 1;
    *value = queue[*front];
 }

 void main()
 {
    int queue[MAX];
    int front,rear;
    int n,value;
    front=rear=(-1);
    do
    {
       do
       {
             printf("Enter the element to be inserted\n");
          scanf("%d",&value);
          insert(queue,&rear,value);
          printf("Enter 1 to continue\n");
             scanf("%d",&n);
       } while(n == 1);

       printf("Enter 1 to delete an element\n");
       scanf("%d",&n);
       while( n == 1)
       {
             delete(queue,&front,rear,&value);
          printf("The value deleted is %d\n",value);
             printf("Enter 1 to delete an element\n");
          scanf("%d",&n);
       }
       printf("Enter 1 to continue\n");
       scanf("%d",&n);
    } while(n == 1);
 }
 #+end_src

 Example
 Input and Output
 Enter the element to be inserted
 10
 Enter 1 to continue
 1
 Enter the element to be inserted
 20
 Enter 1 to continue
 1
 Enter the element to be inserted
 30
 Enter 1 to continue
 0
 Enter 1 to delete an element
 1
 The value deleted is 10
 Enter 1 to delete an element
 1
 The value deleted is 20
 Enter 1 to delete an element
 0
 Enter 1 to continue
 1
 Enter the element to be inserted
 40
 Enter 1 to continue
 1
 Enter the element to be inserted
 50
 Enter 1 to continue
 0
 Enter 1 to delete an element
 1
 The value deleted is 30
 Enter 1 to delete an element
 1
 The value deleted is 40
 Enter 1 to delete an element
 0
 Enter 1 to continue
 0
*** CIRCULAR QUEUES
Introduction

The problem with the previous implementation is that the insert function gives a
queue-full signal even if a considerable portion is free. This happens because
the queue has a tendency to move to the right unless the ‘front’ catches up with
the ‘rear’ and both are reset to 0 again (in the delete procedure). To overcome
this problem, the elements of the array are required to shift one position left
whenever a deletion is made. But this will make the deletion process
inefficient. Therefore, an efficient way of overcoming this problem is to
consider the array to be circular

#+begin_src c
#include <stdio.h>
#define MAX 10 /* The maximum size of the queue */
#include <stdlib.h>

void insert(int queue[], int *rear, int front, int value)
{
   *rear= (*rear +1) % MAX;
   if(*rear == front)
   {
      printf("The queue is full can not insert a value\n");
      exit(0);
   }
   queue[*rear] = value;
}

void delete(int queue[], int *front, int rear, int * value)
{
   if(*front == rear)
   {
      printf("The queue is empty can not delete a value\n");
      exit(0);
   }
   *front = (*front + 1) % MAX;
   *value = queue[*front];
}

void main()
{
   int queue[MAX];
   int front,rear;
   int n,value;
   front=0; rear=0;
   do
   {
      do
      {
            printf("Enter the element to be inserted\n");
         scanf("%d",&value);
         insert(queue,&rear,front,value);
         printf("Enter 1 to continue\n");
         scanf("%d",&n);
      } while(n == 1);

   printf("Enter 1 to delete an element\n");
   scanf("%d",&n);
   while( n == 1)
   {
       delete(queue,&front,rear,&value);
      printf("The value deleted is %d\n",value);
       printf("Enter 1 to delete an element\n");
      scanf("%d",&n);
   }
   printf("Enter 1 to continue\n");
   scanf("%d",&n);
   } while(n == 1);
}
#+end_src

*** IMPLEMENTATION OF A QUEUE USING LINKED REPRESENTATION
#+begin_src c
# include <stdio.h>
# include <stdlib.h>
struct node
{
   int data;
   struct node *link;
};

void insert(struct node **front, struct node **rear, int value)
{
   struct node *temp;
   temp=(struct node *)malloc(sizeof(struct node));
       /* creates new node
       using data value
       passed as parameter */
   if(temp==NULL)
   {
      printf("No Memory available Error\n");
      exit(0);
   }
   temp->data = value;
   temp->link=NULL;
   if(*rear == NULL)
   {
      *rear = temp;
      *front = *rear;
   }
   else
   {
      (*rear)->link = temp;
      *rear = temp;
   }
}

void delete(struct node **front, struct node **rear, int *value)
{
   struct node *temp;
   if((*front == *rear) && (*rear == NULL))
   {
      printf(" The queue is empty cannot delete Error\n");
      exit(0);
   }
   *value = (*front)->data;
   temp = *front;
   *front = (*front)->link;
   if(*rear == temp)
   *rear = (*rear)->link;
   free(temp);
}

void main()
{
   struct node *front=NULL,*rear = NULL;
   int n,value;
   do
   {
      do
      {
            printf("Enter the element to be inserted\n");
         scanf("%d",&value);
         insert(&front,&rear,value);
         printf("Enter 1 to continue\n");
         scanf("%d",&n);
      } while(n == 1);

      printf("Enter 1 to delete an element\n");
      scanf("%d",&n);
      while( n == 1)
      {
            delete(&front,&rear,&value);
            printf("The value deleted is %d\n",value);
            printf("Enter 1 to delete an element\n");
            scanf("%d",&n);
      }
      printf("Enter 1 to continue\n");
      scanf("%d",&n);
   } while(n == 1);
}
#+end_src

*** priority queue
#+begin_src c
# include <stdio.h>
# include <stdlib.h>
struct node
{
   int data;
   int priority;
   struct node *link;
};
void insert(struct node **front, struct node **rear, int value, int priority)
{
   struct node *temp,*temp1;
   temp=(struct node *)malloc(sizeof(struct node));
      /* creates new node using data value
   passed as parameter */
   if(temp==NULL)
   {
      printf("No Memory available Error\n");
      exit(0);
   }
   temp->data = value;
   temp->priority = priority;
   temp->link=NULL;
   if(*rear == NULL) /* This is the first node */
   {
      *rear = temp;
      *front = *rear;
   }
   else
   {
      if((*front)->priority < priority)
             /* the element to be inserted has
      highest priority hence should
             be the first element*/
      {
            temp->link = *front;
            *front = temp;
      }
      else
            if( (*rear)->priority > priority)
                   /* the element to be inserted has
                   lowest priority hence should
                   be the last element*/
            {
                  (*rear)->link = temp;
                  *rear = temp;
            }

      else
      {
                  temp1 = *front;
                  while((temp1->link)->priority >= priority)
     /* find the position and insert the new element */
                          temp1=temp1->link;
             temp->link = temp1->link;
             temp1->link = temp;
             }
}
void delete(struct node **front, struct node **rear, int *value, int *priority)
{
   struct node *temp;
   if((*front == *rear) && (*rear == NULL))
   {
      printf(" The queue is empty cannot delete Error\n");
      exit(0);
   }
   *value = (*front)->data;
   *priority = (*front)->priority;
   temp = *front;
   *front = (*front)->link;
   if(*rear == temp)
       *rear = (*rear)->link;
   free(temp);
}

void main()
{
   struct node *front=NULL,*rear = NULL;
   int n,value, priority;
   do
   {
   do
   {
         printf("Enter the element to be inserted and its priority\n");
     scanf("%d %d",&value,&priority);
     insert(&front,&rear,value,priority);
     printf("Enter 1 to continue\n");
     scanf("%d",&n);
   } while(n == 1);

   printf("Enter 1 to delete an element\n");
   scanf("%d",&n);
   while( n == 1)
   {
         delete(&front,&rear,&value,&priority);
         printf("The value deleted is %d\ and its priority is %d \n",
                value,priority);
         printf("Enter 1 to delete an element\n");
      scanf("%d",&n);
    }
    printf("Enter 1 to delete an element\n");
    scanf("%d",&n);
  }  while( n == 1)
}
#+end_src

** linked lists
*** first intro
**** Introduction

 When dealing with many problems we need a dynamic list, dynamic in the sense
 that the size requirement need not be known at compile time. Thus, the list may
 grow or shrink during runtime. A linked list is a data structure that is used to
 model such a dynamic list of data items, so the study of the linked lists as one
 of the data structures is important.

**** Concept

 An array is represented in memory using sequential mapping, which has the
 property that elements are fixed distance apart. But this has the following
 disadvantage: It makes insertion or deletion at any arbitrary position in an
 array a costly operation, because this involves the movement of some of the
 existing elements.

 When we want to represent several lists by using arrays of varying size, either
 we have to represent each list using a separate array of maximum size or we have
 to represent each of the lists using one single array. The first one will lead
 to wastage of storage, and the second will involve a lot of data movement.

 So we have to use an alternative representation to overcome these disadvantages.
 One alternative is a linked representation. In a linked representation, it is
 not necessary that the elements be at a fixed distance apart. Instead, we can
 place elements anywhere in memory, but to make it a part of the same list, an
 element is required to be linked with a previous element of the list. This can
 be done by storing the address of the next element in the previous element
 itself. This requires that every element be capable of holding the data as well
 as the address of the next element. Thus every element must be a structure with
 a minimum of two fields, one for holding the data value, which we call a data
 field, and the other for holding the address of the next element, which we call
 link field.

 Therefore, a linked list is a list of elements in which the elements of the list
 can be placed anywhere in memory, and these elements are linked with each other
 using an explicit link field, that is, by storing the address of the next
 element in the link field of the previous element.
**** example
 #+begin_src c
 # include <stdio.h>
 # include <stdlib.h>
 struct node
 {
     int data;
     struct node *link;
 };
 struct node *insert(struct node *p, int n)
 {
     struct node *temp;
     /* if the existing list is empty then insert a new node as the
 starting node */
     if(p==NULL)
     {
         /* creates new node data value passes as parameter */
         p=(struct node *)malloc(sizeof(struct node));
        
         if(p==NULL)
         {
             printf("Error\n");
             exit(0);
         }
         p-> data = n;
         p-> link = p; /* makes the pointer pointing to itself because it is a circular list*/
     }
     else
     {
         temp = p;
         /* traverses the existing list to get the pointer to the last node of it */
         while (temp-> link != p)
             temp = temp-> link;
         temp-> link = (struct node *)malloc(sizeof(struct node)); 
         /* creates new node using data value passes as parameter and puts its
              address in the link field of last node of the existing list*/
         if(temp -> link == NULL)
         {
             printf("Error\n");
             exit(0);
         }
         temp = temp-> link;
         temp-> data = n;
         temp-> link = p;
     }
     return (p);
 }
 void printlist ( struct node *p )
 {
     struct node *temp;
     temp = p;
     printf("The data values in the list are\n");
     if(p!= NULL)
     {
         do
         {
             printf("%d\t",temp->data);
             temp=temp->link;
         } while (temp!= p);
     }
     else
         printf("The list is empty\n");
 }

 void main()
 {
     int n;
     int x;
     struct node *start = NULL ;
     printf("Enter the nodes to be created \n");
     scanf("%d",&n);
     while ( n -- > 0 )
     {
         printf( "Enter the data values to be placed in a node\n");
         scanf("%d",&x);
         start = insert ( start, x );
     }
     printf("The created list is\n");
     printlist ( start );
 }
 #+end_src
 
*** INSERTING A NODE BY USING RECURSIVE PROGRAMS

A linked list is a recursive data structure. A recursive data structure is a
data structure that has the same form regardless of the size of the data. You
can easily write recursive programs for such data structures.

#+begin_src c
# include <stdio.h>
# include <stdlib.h>
struct node
{
    int data;
    struct node *link;
};
struct node *insert(struct node *p, int n)
{
    struct node *temp;
    if(p==NULL)
    {
        p=(struct node *)malloc(sizeof(struct node));
        if(p==NULL)
        {
            printf("Error\n");
            exit(0);
        }
        p-> data = n;
        p-> link = NULL;
    }
    else
        p->link = insert(p->link,n);/* the while loop replaced by
recursive call */
    return (p);
}
void printlist ( struct node *p )
{
    printf("The data values in the list are\n");
    while (p!= NULL)
    {
        printf("%d\t",p-> data);
        p = p-> link;
    }
}
void main()
{
    int n;
    int x;
    struct node *start = NULL ;
    printf("Enter the nodes to be created \n");
    scanf("%d",&n);
    while ( n-- > 0 )
    {
        printf( "Enter the data values to be placed in a node\n");
        scanf("%d",&x);
        start = insert ( start, x );
    }
    printf("The created list is\n");
    printlist ( start );
}

#+end_src

*** SORTING AND REVERSING A LINKED LIST
#+begin_src c
# include <stdio.h>
# include <stdlib.h>
struct node
{
   int data;
   struct node *link;
};
struct node *insert(struct node *p, int n)
{
   struct node *temp;
   if(p==NULL)
   {
      p=(struct node *)malloc(sizeof(struct node));
      if(p==NULL)
      {
            printf("Error\n");
         exit(0);
      }
      p-> data = n;
      p-> link = NULL;
   }
   else
   {
      temp = p;
      while (temp-> link!= NULL)
      temp = temp-> link;
      temp-> link = (struct node *)malloc(sizeof(struct node));
      if(temp -> link == NULL)
      {
            printf("Error\n");
         exit(0);
      }
       temp = temp-> link;
       temp-> data = n;
       temp-> link = null;
      }
      return(p);
}

void printlist ( struct node *p )
{
      printf("The data values in the list are\n");
      while (p!= NULL)
      {
            printf("%d\t",p-> data);
         p = p-> link;
      }
}

/* a function to sort reverse list */
struct node *reverse(struct node *p)
{
   struct node *prev, *curr;
   prev = NULL;
   curr = p;
   while (curr != NULL)
   {
      p = p-> link;
      curr-> link = prev;
      prev = curr;
      curr = p;
   }
   return(prev);
}
/* a function to sort a list */
struct node *sortlist(struct node *p)
{
   struct node *temp1,*temp2,*min,*prev,*q;
   q = NULL;
   while(p != NULL)
   {
         prev = NULL;
      min = temp1 = p;
      temp2 = p -> link;
      while ( temp2 != NULL )
      {
              if(min -> data > temp2 -> data)
         {
                     min = temp2;
                     prev = temp1;
         }
         temp1 = temp2;
         temp2 = temp2-> link;
      }
      if(prev == NULL)
             p = min -> link;
      else
             prev -> link = min -> link;
      min -> link = NULL;
      if( q == NULL)
      q = min; /* moves the node with lowest data value in the list
pointed to by p to the list
   pointed to by q as a first node*/
         else
         {
            temp1 = q;
            /* traverses the list pointed to by q to get pointer to its
last node */
            while( temp1 -> link != NULL)
                         temp1 = temp1 -> link;
            temp1 -> link = min; /* moves the node with lowest data value
in the list pointed to
   by p to the list pointed to by q at the end of list pointed by
   q*/
      }
   }
   return (q);
}

void main()
{
      int n;
      int x;
      struct node *start = NULL ;
      printf("Enter the nodes to be created \n");
      scanf("%d",&n);
      while ( n- > 0 )
      {
              printf( "Enter the data values to be placed in a
node\n");
         scanf("%d",&x);
         start = insert ( start,x);
      }
      printf("The created list is\n");
      printlist ( start );
      start = sortlist(start);
      printf("The sorted list is\n");
      printlist ( start );
      start = reverse(start);
      printf("The reversed list is\n");
      printlist ( start );
}

#+end_src

*** DELETING THE SPECIFIED NODE IN A SINGLY LINKED LIST

To delete a node, first we determine the node number to be deleted (this is
based on the assumption that the nodes of the list are numbered serially from 1
to n). The list is then traversed to get a pointer to the node whose number is
given, as well as a pointer to a node that appears before the node to be
deleted. Then the link field of the node that appears before the node to be
deleted is made to point to the node that appears after the node to be deleted,
and the node to be deleted is freed. Figures 20.5 and 20.6 show the list before
and after deletion, respectively.
#+begin_src c
# include <stdio.h>
# include <stdlib.h>
struct node *delet ( struct node *, int );
int length ( struct node * );
struct node
{
   int data;
   struct node *link;
};
struct node *insert(struct node *p, int n)
{
   struct node *temp;
   if(p==NULL)
   {
      p=(struct node *)malloc(sizeof(struct node));
      if(p==NULL)
      {
            printf("Error\n");
         exit(0);
      }
      p-> data = n;
      p-> link = NULL;
   }
   else
   {
      temp = p;
      while (temp-> link != NULL)
       temp = temp-> link;
       temp-> link = (struct node *)malloc(sizeof(struct node));
      if(temp -> link == NULL)
      {
            printf("Error\n");
         exit(0);
      }
      temp = temp-> link;
      temp-> data = n;
      temp-> link = NULL;
      }
      return (p);
}

void printlist ( struct node *p )
{
      printf("The data values in the list are\n");
      while (p!= NULL)
      {
            printf("%d\t",p-> data);
         p = p-> link;
      }
}

void main()
{
   int n;
   int x;
   struct node *start = NULL;
   printf("Enter the nodes to be created \n");
   scanf("%d",&n);
   while ( n- > 0 )
   {
       printf( "Enter the data values to be placed in a node\n");
      scanf("%d",&x);
      start = insert ( start, x );
   }
   printf(" The list before deletion id\n");
   printlist ( start );
   printf("% \n Enter the node no \n");
   scanf ( " %d",&n);
   start = delet (start , n );
   printf(" The list after deletion is\n");
   printlist ( start );
}

   /* a function to delete the specified node*/
struct node *delet ( struct node *p, int node_no )
{

   struct node *prev, *curr ;
   int i;

   if (p == NULL )
   {
      printf("There is no node to be deleted \n");
   }
   else
   {
      if ( node_no > length (p))
      {
            printf("Error\n");
      }
      else
      {
            prev = NULL;
            curr = p;
            i = 1 ;
            while ( i < node_no )
            {
                  prev = curr;
                  curr = curr-> link;
                  i = i+1;
            }
            if ( prev == NULL )
            {
                  p = curr -> link;
                  free ( curr );
            }
            else
            {
               prev -> link = curr -> link ;
               free ( curr );
            }
      }
   }
   return(p);
}
/* a function to compute the length of a linked list */
int length ( struct node *p )
{
   int count = 0 ;
   while ( p != NULL )
   {
      count++;
      p = p->link;
   }
   return ( count ) ;
}

#+end_src

*** INSERTING A NODE AFTER THE SPECIFIED NODE IN A SINGLY LINKED LIST

To insert a new node after the specified node, first we get the number of the
node in an existing list after which the new node is to be inserted. This is
based on the assumption that the nodes of the list are numbered serially from 1
to n. The list is then traversed to get a pointer to the node, whose number is
given. If this pointer is x, then the link field of the new node is made to
point to the node pointed to by x, and the link field of the node pointed to by
x is made to point to the new node.
#+begin_src c
# include <stdio.h>
   # include <stdlib.h>
   int length ( struct node * );
   struct node
   {
      int data;
      struct node *link;
   };

   /* a function which appends a new node to an existing list used for
building a list */
   struct node *insert(struct node *p, int n)
   {
      struct node *temp;
      if(p==NULL)
      {
          p=(struct node *)malloc(sizeof(struct node));
         if(p==NULL)
         {
                 printf("Error\n");
            exit(0);
         }
         p-> data = n;
         p-> link = NULL;
      }
      else
      {
         temp = p;
         while (temp-> link != NULL)
                temp = temp-> link;
         temp-> link = (struct node *)malloc(sizeof(struct node));
        if(temp -> link == NULL)
         {
                 printf("Error\n");
            exit(0);
         }
         temp = temp-> link;
         temp-> data = n;
         temp-> link= NULL;
      }
      return (p);
   }
   /* a function which inserts a newly created node after the specified
node */
   struct node * newinsert ( struct node *p, int node_no, int value )
   {
      struct node *temp, * temp1;
      int i;
      if ( node_no <= 0 || node_no > length (p))
      {
              printf("Error! the specified node does not exist\n");
         exit(0);
      }
      if ( node_no == 0)
      {
         temp = ( struct node * )malloc ( sizeof ( struct node ));
         if ( temp == NULL )
         {
                 printf( " Cannot allocate \n");
                 exit (0);
         }
         temp -> data = value;
         temp -> link = p;
         p = temp ;
   }
   else
   {
       temp = p ;
      i = 1;
      while ( i < node_no )
      {
            i = i+1;
            temp = temp-> link ;
      }
      temp1 = ( struct node * )malloc ( sizeof(struct node));
      if ( temp == NULL )
      {
            printf ("Cannot allocate \n");
            exit(0)
      }
      temp1 -> data = value ;
      temp1 -> link = temp -> link;
      temp -> link = temp1;
   }
   return (p);
   }

   void printlist ( struct node *p )
   {
      printf("The data values in the list are\n");
      while (p!= NULL)
      {
         printf("%d\t",p-> data);
         p = p-> link;
      }
   }
   void main ()
   {
      int n;
      int x;
      struct node *start = NULL;
      printf("Enter the nodes to be created \n");
      scanf("%d",&n);
      while ( n- > 0 )
      {
         printf( "Enter the data values to be placed in a node\n");
         scanf("%d",&x);
         start = insert ( start, x );
      }
      printf(" The list before deletion is\n");
      printlist ( start );
      printf(" \n Enter the node no after which the insertion is to be
done\n");
      scanf ( " %d",&n);
      printf("Enter the value of the node\n");
      scanf("%d",&x);
      start = newinsert(start,n,x);
      printf("The list after insertion is \n");
      printlist(start);
   }
#+end_src

*** INSERTING A NEW NODE IN A SORTED LIST

To insert a new node into an already sorted list, we compare the data value of
the node to be inserted with the data values of the nodes in the list starting
from the first node. This is continued until we get a pointer to the node that
appears immediately before the node in the list whose data value is greater than
the data value of the node to be inserted.

Here is a complete program to insert an element in a sorted list of elements using the linked list representation so that after insertion, it will remain a sorted list.
#+begin_src c
# include <stdio.h>
# include <stdlib.h>
struct node
{
  int data;
  struct node *link;
};
struct node *insert(struct node *, int);
struct node *sinsert(struct node*, int );
void printlist ( struct node * );
struct node *sortlist(struct node *);

struct node *insert(struct node *p, int n)
{
   struct node *temp;
   if(p==NULL)
   {
      p=(struct node *)malloc(sizeof(struct node));
      if(p==NULL)
      {
   printf("Error\n");
           exit(0);
      }
      p-> data = n;
      p-> link = NULL;
   }
   else
   {
      temp = p;
      while (temp-> link!= NULL)
     temp = temp-> link;
      temp-> link = (struct node *)malloc(sizeof(struct node));
      if(temp -> link == NULL)
      {
   printf("Error\n");
          exit(0);
       }
     temp = temp-> link;
       temp-> data = n;
       temp-> link = NULL;
       }
      return (p);
}

void printlist ( struct node *p )
{
      printf("The data values in the list are\n");
      while (p!= NULL)
      {
   printf("%d\t",p-> data);
         p = p-> link;
      }
   }

/* a function to sort a list */
struct node *sortlist(struct node *p)
{
   struct node *temp1,*temp2,*min,*prev,*q;
   q = NULL;
   while(p != NULL)
   {
   prev = NULL;
      min = temp1 = p;
      temp2 = p -> link;
      while ( temp2 != NULL )
      {
         if(min -> data > temp2 -> data)
              {
         min = temp2;
                 prev = temp1;
               }
               temp1 = temp2;
               temp2 = temp2-> link;
            }
      if(prev == NULL)
            p = min -> link;
            else
            prev -> link = min -> link;
            min -> link = NULL;
            if( q == NULL)
            q = min; /* moves the node with lowest data value in the list
pointed to by p to the list
   pointed to by q as a first node*/
            else
            {
               temp1 = q;
               /* traverses the list pointed to by q to get pointer to its
last node */
               while( temp1 -> link != NULL)
               temp1 = temp1 -> link;
               temp1 -> link = min; /* moves the node with lowest data value
in the list pointed to
   by p to the list pointed to by q at the end of list pointed by
   q*/
         }
      }
      return (q);
   }

   /* a function to insert a node with data value n in a sorted list
pointed to by p*/
   struct node *sinsert(struct node *p, int n)
   {
      struct node *curr, *prev;
      curr =p;
      prev = NULL;
     while(curr ->data < n)
           {
                        prev = curr;
                  curr = curr->link;
           }
   if ( prev == NULL) /* the element is to be inserted at the start of
the list because
                   it is less than the data value of the first node*/
       {
            curr = (struct node *) malloc(sizeof(struct node));
            if( curr == NULL)
              {
                printf("error cannot allocate\n");
                exit(0);
              }
           curr->data = n;
           curr->link = p;
           p = curr;
       }
       else
        {
            curr->data = n;
            curr->link = prev->link;
            prev->link = curr;
        }
      return(p);
      }

      void main()
      {
         int n;
         int x;
         struct node *start = NULL ;
         printf("Enter the nodes to be created \n");
         scanf("%d",&n);
         while ( n-- > 0 )
         {
      printf( "Enter the data values to be placed in a node\n");
            scanf("%d",&x);
            start = insert ( start,x);
         }
         printf("The created list is\n");
         printlist ( start );
         start = sortlist(start);
         printf("The sorted list is\n");
         printlist ( start );
         printf("Enter the value to be inserted\n");
         scanf("%d",&n);
         start = sinsert(start,n);
         printf("The list after insertion is\n");
         printlist ( start );
   }

#+end_src

*** MERGING OF TWO SORTED LISTS

Merging of two sorted lists involves traversing the given lists and comparing
the data values stored in the nodes in the process of traversing.

If p and q are the pointers to the sorted lists to be merged, then we compare
the data value stored in the first node of the list pointed to by p with the
data value stored in the first node of the list pointed to by q. And, if the
data value in the first node of the list pointed to by p is less than the data
value in the first node of the list pointed to by q, make the first node of the
resultant/merged list to be the first node of the list pointed to by p, and
advance the pointer p to make it point to the next node in the same list.

If the data value in the first node of the list pointed to by p is greater than
the data value in the first node of the list pointed to by q, make the first
node of the resultant/merged list to be the first node of the list pointed to by
q, and advance the pointer q to make it point to the next node in the same list.

Repeat this procedure until either p or q becomes NULL. When one of the two
lists becomes empty, append the remaining nodes in the non-empty list to the
resultant list.

#+begin_src c
# include <stdio.h>
# include <stdlib.h>
struct node
{
int data;
struct node *link;
};

struct node *merge (struct node *, struct node *);
struct node *insert(struct node *p, int n)
{
   struct node *temp;
   if(p==NULL)
   {
      p=(struct node *)malloc(sizeof(struct node));
      if(p==NULL)
      {
   printf("Error\n");
          exit(0);
      }
      p-> data = n;
      p-> link = NULL;
   }
   else
   {
      temp = p;
      while (temp-> link!= NULL)
      temp = temp-> link;
      temp-> link = (struct node *)malloc(sizeof(struct node));
      if(temp -> link == NULL)
      {
   printf("Error\n");
          exit(0);
      }
     temp = temp-> link;
      temp-> data = n;
      temp-> link = NULL;
      }
      return (p);
   }

   void printlist ( struct node *p )
   {
      printf("The data values in the list are\n");
      while (p!= NULL)
         {
      printf("%d\t",p-> data);
           p = p-> link;
         }
   }
   /* a function to sort a list */
struct node *sortlist(struct node *p)
{
    struct node *temp1,*temp2,*min,*prev,*q;
   q = NULL;
   while(p != NULL)
   {
   prev = NULL;
      min = temp1 = p;
      temp2 = p -> link;
      while ( temp2 != NULL )
      {
   if(min -> data > temp2 -> data)
        {
   min = temp2;
           prev = temp1;
        }
        temp1 = temp2;
        temp2 = temp2-> link;
      }
   if(prev == NULL)
         p = min -> link;
         else
         prev -> link = min -> link;
         min -> link = NULL;
         if( q == NULL)
         q = min; /* moves the node with lowest data value in the list
pointed to by p to the list
   pointed to by q as a first node*/
         else
         {
            temp1 = q;
            /* traverses the list pointed to by q to get pointer to its
last node */
            while( temp1 -> link != NULL)
            temp1 = temp1 -> link;
            temp1 -> link = min; /* moves the node with lowest data value
in the list pointed to
   by p to the list pointed to by q at the end of list pointed by
   q*/
         }
      }
      return (q);
   }

   void main()
   {
      int n;
      int x;
      struct node *start1 = NULL ;
      struct node *start2 = NULL;
      struct node *start3 = NULL;
      /* The following code creates and sorts the first list */
      printf("Enter the number of nodes in the first list \n");
      scanf("%d",&n);
      while ( n-- > 0 )
      {
   printf( "Enter the data value to be placed in a node\n");
         scanf("%d",&x);
         start1 = insert ( start1,x);
      }
      printf("The first list is\n");
      printlist ( start1);
      start1 = sortlist(start1);
      printf("The sorted list1 is\n");
      printlist ( start1 );
      /* the following creates and sorts the second list*/
      printf("Enter the number of nodes in the second list \n");
      scanf("%d",&n);
      while ( n-- > 0 )
      {
         printf( "Enter the data value to be placed in a node\n");
         scanf("%d",&x);
         start2 = insert ( start2,x);
      }
      printf("The second list is\n");
      printlist ( start2);
      start2 = sortlist(start2);
      printf("The sorted list2 is\n");
      printlist ( start2 );
      start3 = merge(start1,start2);
      printf("The merged list is\n");
      printlist ( start3);
   }

   /* A function to merge two sorted lists */
   struct node *merge (struct node *p, struct node *q)
   {
      struct node *r=NULL,*temp;
      if (p == NULL)
           r = q;
      else
      if(q == NULL)
           r = p;
      else
         {
            if (p->data < q->data )
            {
   r = p;
   temp = p;
   p = p->link;
   temp->link = NULL;
              }
             else
              {
   r = q;
   temp =q;
   q =q->link;
   temp->link = NULL;
              }
              while((p!= NULL) && (q != NULL))
              {
                  if (p->data < q->data)
         {
         temp->link =p;
         p = p->link;
         temp =temp->link;
         temp->link =NULL;
         }
                     else
         {
            temp->link =q;
            q = q->link;
            temp =temp->link;
            temp->link =NULL;
            }
      }
         if (p!= NULL)
                 temp->link = p;
         if (q != NULL)
                 temp->link = q;
        }
   return( r) ;
   }
#+end_src

*** ERASING A LINKED LIST
Erasing a linked list involves traversing the list starting from the first node,
freeing the storage allocated to the nodes, and then setting the pointer to the
list to NULL. If p is a pointer to the start of the list, the actions specified
through the following code will erase the list:

#+begin_src c
while(p != NULL)
   {
           temp = p;
           p = p->link;
           free(t);
   }
#+end_src

But a better strategy of erasing a list is to mark all the nodes of the list to
be erased as free nodes without actually freeing the storage of these nodes.
That means to maintain this list, a list of free nodes, so that if a new node is
required it can be obtained from this list of free nodes.

Here is a complete program that erases a list pointed to by p by adding the nodes of a list pointed by p to the free list.

#+begin_src c
# include <stdio.h>
# include <stdlib.h>
struct node
{
int data;
struct node *link;
};
struct node *insert(struct node *, int);
void erase(struct node **,struct node **);
void printlist ( struct node * );

void erase (struct node **p, struct node **free)
{
   struct node *temp;
   temp = *p;
   while (temp->link != NULL)
         temp = temp ->link;
   temp->link = (*free);
   *free = *p;
   *p = NULL;
}

struct node *insert(struct node *p, int n)
{
   struct node *temp;
   if(p==NULL)
   {
      p=(struct node *)malloc(sizeof(struct node));
      if(p==NULL)
      {
   printf("Error\n");
          exit(0);
      }
      p-> data = n;
      p-> link = NULL;
   }
   else
   {
     temp = p;
     while (temp-> link!= NULL)
    temp = temp-> link;
    temp-> link = (struct node *)malloc(sizeof(struct node));
    if(temp -> link == NULL)
    {
  printf("Error\n");
         exit(0);
      }
    temp = temp-> link;
      temp-> data = n;
      temp-> link = NULL;
      }
      return (p);
}

void printlist ( struct node *p )
{
      printf("The data values in the list are\n");
      while (p!= NULL)
      {
   printf("%d\t",p-> data);
         p = p-> link;
      }
   }

   void main()
   {
         int n;
         int x;
         struct node *start = NULL ;
         struct node *free=NULL;

         /* this code will create a free list for the test purpose*/
        printf("Enter the number of nodes in the initial free list \n");
         scanf("%d",&n);
         while ( n-- > 0 )
         {
            printf( "Enter the data values to be placed in a node\n");
            scanf("%d",&x);
            free = insert ( free,x);
         }

            /* this code will create a list to be erased*/
           printf("Enter the number of nodes in the list to be created for
erasing \n");
            scanf("%d",&n);
            while ( n-- > 0 )
            {
               printf( "Enter the data values to be placed in a node\n");
               scanf("%d",&x);
               start = insert ( start,x);
            }
               printf("The free list islist is:\n");
               printlist ( free );
               printf("The list to be erased is:\n");
               printlist ( start);
               erase(&start,&free);
               printf("The free list after adding all the nodes from the list to
be erased is:\n");
               printlist ( free );
   }
#+end_src

*** POLYNOMIAL REPRESENTATION

One of the problems that a linked list can deal with is manipulation of symbolic
polynomials. By symbolic, we mean that a polynomial is viewed as a list of
coefficients and exponents. For example, the polynomial

3x^2+2x+4

can be viewed as list of the following pairs

(3,2),(2,1),(4,0)

#+begin_src c
# include <stdio.h>
# include <stdlib.h>
struct pnode
   {
      int exp;
      double coeff;
      struct pnode *link;
   };

struct pnode *insert(struct pnode *, int,double);
void printlist ( struct pnode * );
struct pnode *polyadd(struct pnode *, struct pnode *);
struct pnode *sortlist(struct pnode *);

struct pnode *insert(struct pnode *p, int e,double c)
{
   struct pnode *temp;
   if(p==NULL)
   {
      p=(struct pnode *)malloc(sizeof(struct pnode));
      if(p==NULL)
      {
         printf("Error\n");
         exit(0);
      }
      p-> exp = e;
      p->coeff = c;
      p-> link = NULL;
   }
   else
   {
      temp = p;
      while (temp-> link!= NULL)
      temp = temp-> link;
      temp-> link = (struct pnode *)malloc(sizeof(struct pnode));
      if(temp -> link == NULL)
      {
   printf("Error\n");
         exit(0);
      }
    temp = temp-> link;
      temp-> exp = e;
      temp->coeff = c;
      temp-> link = NULL;
   }
   return (p);
}

/* a function to sort a list */
struct pnode *sortlist(struct pnode *p)
{
   struct pnode *temp1,*temp2,*max,*prev,*q;
   q = NULL;
   while(p != NULL)
   {
      prev = NULL;
      max = temp1 = p;
      temp2 = p -> link;
      while ( temp2 != NULL )
      {
         if(max -> exp < temp2 -> exp)
              {
         max = temp2;
                 prev = temp1;
               }
               temp1 = temp2;
               temp2 = temp2-> link;
            }
      if(prev == NULL)
            p = max -> link;
            else
            prev -> link = max -> link;
            max -> link = NULL;
            if( q == NULL)
            q = max; /* moves the node with highest data value in the list
pointed to by p to the list
   pointed to by q as a first node*/
         else
         {
            temp1 = q;
            /* traverses the list pointed to by q to get pointer to its
last node */
         while( temp1 -> link != NULL)
         temp1 = temp1 -> link;
         temp1 -> link = max; /* moves the node with highest data value
in the list pointed to
   by p to the list pointed to by q at the end of list pointed by
   q*/

         }
      }
      return (q);
   }
   /* A function to add two polynomials */
   struct pnode *polyadd(struct pnode *p, struct pnode *q)
   {
      struct pnode *r = NULL;
      int e;
      double c;
      while((p!=NULL) && (q != NULL))
               {
                  if(p->exp > q->exp)
                   {
                        r = insert(r,p->exp,p->coeff);
                        p = p->link;
                   }
                   else
                      if(p->exp < q->exp)
                    {
                        r = insert(r,q->exp,q->coeff);
                        q = q->link;
                     }
                     else
   {
      c = p->coeff + q->coeff;
      e = q->exp;
      r = insert( r, e,c);
      p = p->link;
      q = q->link;
            }
   while(p != NULL)
            {
                  r = insert( r, p->exp,p->coeff);
                  p = p->link;
            }
            while(q!=NULL)
            {
                     r = insert( r, q->exp,q->coeff);
                     q = q->link;
            }
   return(r);
   }

   void printlist ( struct pnode *p )
   {
      printf("The polynomial is\n");
      while (p!= NULL)
           {
      printf("%d %lf\t",p-> exp,p->coeff);
               p = p-> link;
         }
   }
   void main()
   {
         int e;
         int n,i;
         double c;
         struct pnode *poly1 = NULL ;
         struct pnode *poly2=NULL;
         struct pnode *result;
         printf("Enter the terms in the polynomial1 \n");
         scanf("%d",&n);
         i=1;
         while ( n-- > 0 )
         {
      printf( "Enter the exponent and coefficient of the term number
%d\n",i);
               scanf("%d %lf",&e,&c);
               poly1 = insert ( poly1,e,c);
         }
        printf("Enter the terms in the polynomial2 \n");
         scanf("%d",&n);
         i=1;
         while ( n-- > 0 )
         {
      printf( "Enter the exponent and coefficient of the term number
%d\n",i);
               scanf("%d %lf",&e,&c);
               poly2 = insert ( poly2,e,c);
         }
         poly1 = sortlist(poly1);
         poly2 = sortlist(poly2);
         printf("The polynomial 1 is\n");
         printlist ( poly1 );
         printf("The polynomial 2 is\n");
         printlist ( poly2 );
        result = polyadd(poly1,poly2);
         printf("The result of addition is\n");
         printlist ( result );
   }
#+end_src

*** REPRESENTATION OF SPARSE MATRICES

The most natural representation is to use two-dimensional array A[m][n] and
access the element of ith row and jth column as A[i][j]. If a large number of
elements of the matrix are zero elements, then it is called a sparse matrix.

Representing a sparse matrix by using a two-dimensional array leads to the
wastage of a substantial amount of space. Therefore, an alternative
representation must be used for sparse matrices. One such representation is to
store only non- zero elements along with their row positions and column
positions. That means representing every non-zero element by using triples (i,
j, value), where i is a row position and j is a column position, and store these
triples in a linear list. It is possible to arrange these triples in the
increasing order of row indices, and for the same row index in the increasing
order of column indices. Each triple (i,j,value) can be represented by using a
node having four fields as shown in the following:

#+begin_src c
Struct snode{
        Int row,col,val;
        Struct snode *next;
        };
#+end_src

#+begin_src c
# include <stdio.h>
# include <stdlib.h>
struct snode
   {
      int row,col,val;
      struct snode *link;
   };

struct snode *insert(struct snode *, int,int,int);
void printlist ( struct snode * );
struct snode *sadd(struct snode *, struct snode *);
//struct pnode *sortlist(struct pnode *);

struct snode *insert(struct snode *p, int r,int c,int val)
{
   struct snode *temp;
   if(p==NULL)
   {
      p=(struct snode *)malloc(sizeof(struct snode));
      if(p==NULL)
      {
   printf("Error\n");
          exit(0);
      }
      p->row = r;
      p->col = c;
      p->val = val;
      p-> link = NULL;
   }
   else
   {
      temp = p;
      while (temp-> link!= NULL)
     temp = temp-> link;
      temp-> link = (struct snode *)malloc(sizeof(struct snode));
      if(temp -> link == NULL)
      {
   printf("Error\n");
          exit(0);
      }
     temp = temp-> link;
      temp-> row = r;
      temp->col= c;
      temp->val=val;
      temp-> link = NULL;
   }
   return (p);
}

/* A function to add two sparse matrices */
struct snode *sadd(struct snode *p, struct snode *q)
{
   struct snode *r = NULL;
   int val;
   while((p!=NULL) && (q != NULL))
            {
               if(p->row < q->row)
               {
                  r = insert(r,p->row,p->col,p->val);
                  p = p->link;
               }
             else
                if(p->row > q->row)
                {
                  r = insert(r,q->row,q->col,q->val);
                  q = q->link;
                }
             else
   if( p->col < q->col)
                {
      r = insert(r,p->row,p->col,p->val);
                  p = p->link;
                }
   else
            if(p->col > q->col)
               {
                  r = insert(r,q->row,q->col,q->val);
                  q = q->link;
               }
             else
             {
               val = p->val + q->val;
               r = insert( r, p->row,p->col,val);
               p = p->link;
               q = q->link;
             }
     }
   while(p != NULL)
            {
                  r = insert( r, p->row ,p->col,p->val);
                  p = p->link;
            }
            while(q!=NULL)
            {
                  r = insert( r, q->row ,q->col,q->val);
                  q = q->link;
            }
   return(r);
   }

   void printlist ( struct snode *p )
   {
      printf("The resultant sparse matrix is\n");
      while (p!= NULL)
           {
      printf("%d %d % d\n",p-> row,p->col,p->val);
               p = p-> link;
        }
   }
   void main()
   {
      int r,n,c,val;
      struct snode *s1 = NULL ;
      struct snode *s2=NULL;
      struct snode *result = NULL;
      printf("Enter the number of non-zero terms in the sparse matrix1 \n");
      scanf("%d",&n);
      printf("Enter the terms in the sparse matrix1 in the increasing
order of row indices and for the same row index in the increasing order of
row indices and for the same row index in the increasing order of column
indices \n");
                while ( n-- > 0 )
         {
      printf( "Enter the row number, column number, and value\n");
              scanf("%d %d%d",&r,&c,&val);
              s1 = insert ( s1,r,c,val);
         }
   printf("Enter the number of non-zero terms in the sparse matrix1 \n");
         scanf("%d",&n);
         printf("Enter the terms in the sparse matrix2 in the increasing
order of row indices and for the same row index in the increasing order of
row indices and for the same row index in the increasing order of column
indices \n");
         while ( n-- > 0 )
         {
      printf( "Enter the row number, column number, and value\n");
              scanf("%d %d%d",&r,&c,&val);
              s2 = insert ( s2,r,c,val);
         }
         result = sadd(s1,s2);
         printf("The result of addition is\n");
         printlist ( result );
   }
#+end_src

*** CIRCULAR LINKED LISTS
#+begin_src c
# include <stdio.h>
# include <stdlib.h>
struct node
{
   int data;
   struct node *link;
};
struct node *insert(struct node *p, int n)
{
   struct node *temp;
   /* if the existing list is empty then insert a new node as the
starting node */
       if(p==NULL)
       {
         p=(struct node *)malloc(sizeof(struct node)); /* creates new
node data value passes
   as parameter */
        if(p==NULL)
        {
                 printf("Error\n");
                 exit(0);
         }
         p-> data = n;
          p-> link = p; /* makes the pointer pointing to itself because it
is a circular list*/
      }
      else
      {
         temp = p;
   /* traverses the existing list to get the pointer to the last node of
it */
         while (temp-> link != p)
                temp = temp-> link;
         temp-> link = (struct node *)malloc(sizeof(struct node)); /*
creates new node using
         data value passes as
         parameter and puts its
         address in the link field
         of last node of the
         existing list*/
         if(temp -> link == NULL)
         {
                  printf("Error\n");
         }
            exit(0);
            temp = temp-> link;
            temp-> data = n;
            temp-> link = p;
         }
         return (p);
   }
   void printlist ( struct node *p )
   {
      struct node *temp;
      temp = p;
      printf("The data values in the list are\n");
      if(p!= NULL)
      {
      do
      {
                printf(%d\t",temp->data);
                temp=temp->link;
      } while (temp!= p)
   }
   else
      printf("The list is empty\n");
   }

   void main()
   {
      int n;
      int x;
      struct node *start = NULL ;
      printf("Enter the nodes to be created \n");
      scanf("%d",&n);
      while ( n- > 0 )
      {
              printf( "Enter the data values to be placed in a
node\n");
         scanf("%d",&x);
         start = insert ( start, x );
      }
      printf("The created list is\n");
      printlist ( start );
   }

#+end_src

*** SPLITTING A LIST WITH 2N NODES INTO TWO SEPARATE AND EQUAL LISTS

If the circular linked list has 10 nodes, then the two lists have 5 nodes each.
The procedure for splitting a circular list with 2n nodes into two equal
circular lists is given here:

#+begin_src c
#include <stdio.h>
#include <stdlib.h>
struct node
{
  int data;
  struct node *link;
};
void split(struct node *p, struct node **q, int n)
{
    struct node *temp;
  int i =1;
  temp = p;
        while( i < n)

                          {
                temp = temp->link;
                i++;
                          }
  *q = temp->link;
  temp->link = p;
          temp = *q;
        while(temp->link != p)
      temp = temp ->link;
  temp->link = *q;
}

   struct node *insert(struct node *p, int n)
   {
   struct node *temp;
   /* if the existing list is empty then insert a new node as the
starting node */
   if(p==NULL)
   {
      p=(struct node *)malloc(sizeof(struct node)); /* creates new node
data value passes
   as parameter */

      if(p==NULL)
      {
   printf("Error\n");
          exit(0);
      }
      p-> data = n;
      p-> link = p; /* makes the pointer point to itself because it is
a circular list*/
       }
       else
       {
         temp = p;
    /* traverses the existing list to get the pointer to the last node of
it */
   while (temp-> link != p)
      temp = temp-> link;
       temp-> link = (struct node *)malloc(sizeof(struct node)); /*
creates new node using
          data value passes as
            parameter and puts its
           address in the link field
           of last node of the
           existing list*/
         if(temp -> link == NULL)
         {
      printf("Error\n");
            exit(0);
         }
         temp = temp-> link;
         temp-> data = n;
         temp-> link = p;
      }
      return (p);
   }

   void printlist ( struct node *p )
   {
    struct node *temp;
     temp = p;
    printf("The data values in the list are\n");
      if(p!= NULL)
             do
               {
               printf("%d\t",temp->data);
               temp=temp->link;
               } while (temp!= p);
      else
            printf("The list is empty\n");
   }

   void main()
   {
         int n,num;
         int x;
         struct node *start = NULL ;
         struct node *start1=NULL;
         printf("Enter the value of n \n");
         scanf("%d",&n);
         num = n;
         n*=2;
         /* this will create a circular list with 2n nodes*/
      while ( n-- > 0 )
         {
      printf( "Enter the data values to be placed in a node\n");
             scanf("%d",&x);
             start = insert ( start, x );
         }
         printf("The created list is\n");
         printlist ( start );
         split(start,&start1,num);
         printf("The first list is:\n");
         printlist(start);
         printf("The second list is:\n");
         printlist(start1);
   }
#+end_src

*** MERGING OF TWO CIRCULAR LISTS

You can merge two lists into one list. The following program merges two circular lists.

#+begin_src c
   # include <stdio.h>
   # include <stdlib.h>
   struct node
   {
   int data;
   struct node *link;
   };

   struct node *insert(struct node *p, int n)
   {
   struct node *temp;
   /* if the existing list is empty then insert a new node as the
starting node */
   if(p==NULL)
   {
      p=(struct node *)malloc(sizeof(struct node)); /* creates new node
data value passes
   as parameter */

        if(p==NULL)
        {
     printf("Error\n");
            exit(0);
        }
         p-> data = n;
         p-> link = p; /* makes the pointer pointing to itself because it
is a circular list*/
      }
      else
      {
         temp = p;
   /* traverses the existing list to get the pointer to the last node of
it */
   while (temp-> link != p)
      temp = temp-> link;
       temp-> link = (struct node *)malloc(sizeof(struct node)); /*
creates new node using
          data value passes as
            parameter and puts its
           address in the link field
           of last node of the
            existing list*/
           if(temp -> link == NULL)
           {
        printf("Error\n");
             exit(0);
           }
           temp = temp-> link;
           temp-> data = n;
           temp-> link = p;
         }
         return (p);
   }
   void printlist ( struct node *p )
   {
    struct node *temp;
     temp = p;
    printf("The data values in the list are\n");
       if(p!= NULL)
       {
         do
               {
               printf("%d\t",temp->data);
               temp=temp->link;
               } while (temp!= p);
       }
   else
         printf("The list is empty\n");
    }
   struct node *merge(struct node *p, struct node *q)
        {
          struct node *temp=NULL;
          struct node *r=NULL;
          r = p;
          temp = p;
          while(temp->link != p)
               temp = temp->link;
          temp->link = q;
          temp = q;
          while( temp->link != q)
              temp = temp->link;
          temp->link = r;
         return(r);
   }

   void main()
   {
         int n;
         int x;
         struct node *start1=NULL ;
         struct node *start2=NULL;
         struct node *start3=NULL;

        /* this will create the first circular list nodes*/
         printf("Enter the number of nodes in the first list \n");
         scanf("%d",&n);
         while ( n-- > 0 )
         {
      printf( "Enter the data value to be placed in a node\n");
              scanf("%d",&x);
              start1 = insert ( start1, x );
         }
         printf("The first list is\n");
         printlist ( start1 );

         /* this will create the second circular list nodes*/
         printf("Enter the number of nodes in the second list \n");
         scanf("%d",&n);
         while ( n-- > 0 )
         {
      printf( "Enter the data value to be placed in a node\n");
             scanf("%d",&x);
             start2 = insert ( start2, x );
         }
         printf("The second list is:\n");
         printlist ( start2 );

         start3 = merge(start1,start2);
         printf("The resultant list is:\n");
         printlist(start3);
   }
#+end_src 

*** REVERSING THE DIRECTION OF LINKS IN A SINGLY LINKED CIRCULAR LIST
You can reverse the direction of links in the circular list. If you do so, each link should be reversed.

#+begin_src c
   # include <stdio.h>
   # include <stdlib.h>
   struct node
   {
   int data;
   struct node *link;
   };
   /* A function to reverse a singly linked circular list */
   struct node *reverselist(struct node *p)
     {
       struct node *temp;
       struct node *prev = NULL;
       struct node *curr;
       if(p != NULL)
       {
       curr = p;
       temp = curr;
       while(curr->link != p)
       {
         curr = curr->link;
                 temp ->link = prev;
                 prev = temp;
                 temp = curr;
              }
      temp ->link = prev;
      p->link = temp;
      p= temp;
      }
      return(p);
   }

   struct node *insert(struct node *p, int n)
   {
   struct node *temp;
   /* if the existing list is empty then insert a new node as the
starting node */
   if(p==NULL)
   {
      p=(struct node *)malloc(sizeof(struct node)); /* creates new node
      data value passes
         as parameter */

              if(p==NULL)
              {
           printf("Error\n");
                  exit(0);
              }
               p-> data = n;
               p-> link = p; /* makes the pointer point to itself because it is
a circular list*/
        }
        else
        {
          temp = p;
      /* traverses the existing list to get the pointer to the last node of
it */
   while (temp-> link != p)
       temp = temp-> link;
         temp-> link = (struct node *)malloc(sizeof(struct node)); /*
creates new node using
          data value passes as
            parameter and puts its
           address in the link field
           of last node of the
           existing list*/
         if(temp -> link == NULL)
         {
      printf("Error\n");
           exit(0);
         }
         temp = temp-> link;
         temp-> data = n;
         temp-> link = p;
        }
        return (p);
   }
   void printlist ( struct node *p )
   {
    struct node *temp;
     temp = p;
    printf("The data values in the list are\n");
    if(p!= NULL)
    {
       do
            {
            printf("%d\t",temp->data);
            temp=temp->link;
            } while (temp!= p);
      }
   else
         printf("The list is empty\n");
   }
   void main()
   {
         int n;
         int x;
         struct node *start = NULL ;
         struct node *start1=NULL;
         /* this will create at circular list */
         printf("Enter the number of nodes in the list \n");
         scanf("%d",&n);
         while ( n-- > 0 )
         {
      printf( "Enter the data value to be placed in a node\n");
              scanf("%d",&x);
              start = insert ( start, x );
         }
         printf("The list is\n");
         printlist ( start );
         start1 = reverselist(start);
         printf("The reversed list is:\n");
         printlist(start1);
   }
#+end_src

* libpcap
** open the default device 

#+begin_src c
	#include <stdio.h>
	#include <pcap.h>

	int main(int argc, char *argv[])
	{
		char *dev, errbuf[PCAP_ERRBUF_SIZE];

		dev = pcap_lookupdev(errbuf);
		if (dev == NULL) {
			fprintf(stderr, "Couldn't find default device: %s\n", errbuf);
			return(2);
		}
		printf("Device: %s\n", dev);
		return(0);
	}
#+end_src

** get the name of the device to open from command line

#+begin_src c
	#include <stdio.h>
	#include <pcap.h>

	int main(int argc, char *argv[])
	{
		 char *dev = argv[1];

		 printf("Device: %s\n", dev);
		 return(0);
	}
#+end_src

** open device for sniffing

The task of creating a sniffing session is really quite simple. For this, we use
pcap_open_live(). The prototype of this function (from the pcap man page) is as
follows:

#+begin_src c
	pcap_t *pcap_open_live(char *device, int snaplen, int promisc, int to_ms,
	    char *ebuf)
#+end_src

The first argument is the device that we specified in the previous section.
snaplen is an integer which defines the maximum number of bytes to be captured
by pcap. promisc, when set to true, brings the interface into promiscuous mode
(however, even if it is set to false, it is possible under specific cases for
the interface to be in promiscuous mode, anyway). to_ms is the read time out in
milliseconds (a value of 0 means no time out; on at least some platforms, this
means that you may wait until a sufficient number of packets arrive before
seeing any packets, so you should use a non-zero timeout). Lastly, ebuf is a
string we can store any error messages within (as we did above with errbuf). The
function returns our session handler.

To demonstrate, consider this code snippet:
#+begin_src c
	 #include <pcap.h>
	 ...
	 pcap_t *handle;

	 handle = pcap_open_live(dev, BUFSIZ, 1, 1000, errbuf);
	 if (handle == NULL) {
		 fprintf(stderr, "Couldn't open device %s: %s\n", dev, errbuf);
		 return(2);
	 }
#+end_src

This code fragment opens the device stored in the strong "dev", tells it to read
however many bytes are specified in BUFSIZ (which is defined in pcap.h). We are
telling it to put the device into promiscuous mode, to sniff until an error
occurs, and if there is an error, store it in the string errbuf; it uses that
string to print an error message.
** filtering traffic

Before applying our filter, we must "compile" it. The filter expression is kept
in a regular string (char array). The syntax is documented quite well in the man
page for tcpdump; I leave you to read it on your own. However, we will use
simple test expressions, so perhaps you are sharp enough to figure it out from
my examples.

To compile the program we call pcap_compile(). The prototype defines it as:

#+begin_src c
	int pcap_compile(pcap_t *p, struct bpf_program *fp, char *str, int optimize, 
	    bpf_u_int32 netmask)
#+end_src

The first argument is our session handle (pcap_t *handle in our previous
example). Following that is a reference to the place we will store the compiled
version of our filter. Then comes the expression itself, in regular string
format. Next is an integer that decides if the expression should be "optimized"
or not (0 is false, 1 is true. Standard stuff.) Finally, we must specify the
network mask of the network the filter applies to. The function returns -1 on
failure; all other values imply success.

After the expression has been compiled, it is time to apply it. Enter
pcap_setfilter(). Following our format of explaining pcap, we shall look at the
pcap_setfilter() prototype:

#+begin_src c
	int pcap_setfilter(pcap_t *p, struct bpf_program *fp)
 #include <pcap.h>
	 ...
	 pcap_t *handle;		/* Session handle */
	 char dev[] = "rl0";		/* Device to sniff on */
	 char errbuf[PCAP_ERRBUF_SIZE];	/* Error string */
	 struct bpf_program fp;		/* The compiled filter expression */
	 char filter_exp[] = "port 23";	/* The filter expression */
	 bpf_u_int32 mask;		/* The netmask of our sniffing device */
	 bpf_u_int32 net;		/* The IP of our sniffing device */

	 if (pcap_lookupnet(dev, &net, &mask, errbuf) == -1) {
		 fprintf(stderr, "Can't get netmask for device %s\n", dev);
		 net = 0;
		 mask = 0;
	 }
	 handle = pcap_open_live(dev, BUFSIZ, 1, 1000, errbuf);
	 if (handle == NULL) {
		 fprintf(stderr, "Couldn't open device %s: %s\n", dev, errbuf);
		 return(2);
	 }
	 if (pcap_compile(handle, &fp, filter_exp, 0, net) == -1) {
		 fprintf(stderr, "Couldn't parse filter %s: %s\n", filter_exp, pcap_geterr(handle));
		 return(2);
	 }
	 if (pcap_setfilter(handle, &fp) == -1) {
		 fprintf(stderr, "Couldn't install filter %s: %s\n", filter_exp, pcap_geterr(handle));
		 return(2);
	 }
#+end_src

This program preps the sniffer to sniff all traffic coming from or going to port 23, in promiscuous mode, on the device rl0.

You may notice that the previous example contains a function that we have not
yet discussed. pcap_lookupnet() is a function that, given the name of a device,
returns one of its IPv4 network numbers and corresponding network mask (the
network number is the IPv4 address ANDed with the network mask, so it contains
only the network part of the address). This was essential because we needed to
know the network mask in order to apply the filter. This function is described
in the Miscellaneous section at the end of the document.
** capturing individual packets with pcap_next

There are two main techniques for capturing packets. We can either capture a
single packet at a time, or we can enter a loop that waits for n number of
packets to be sniffed before being done. We will begin by looking at how to
capture a single packet, then look at methods of using loops. For this we use
pcap_next().

The prototype for pcap_next() is fairly simple:

#+begin_src c
	u_char *pcap_next(pcap_t *p, struct pcap_pkthdr *h)
#+end_src

The first argument is our session handler. The second argument is a pointer to a
structure that holds general information about the packet, specifically the time
in which it was sniffed, the length of this packet, and the length of his
specific portion (incase it is fragmented, for example.) pcap_next() returns a
u_char pointer to the packet that is described by this structure. We'll discuss
the technique for actually reading the packet itself later.

Here is a simple demonstration of using pcap_next() to sniff a packet.

#+begin_src c
	 #include <pcap.h>
	 #include <stdio.h>

	 int main(int argc, char *argv[])
	 {
		pcap_t *handle;			/* Session handle */
		char *dev;			/* The device to sniff on */
		char errbuf[PCAP_ERRBUF_SIZE];	/* Error string */
		struct bpf_program fp;		/* The compiled filter */
		char filter_exp[] = "port 23";	/* The filter expression */
		bpf_u_int32 mask;		/* Our netmask */
		bpf_u_int32 net;		/* Our IP */
		struct pcap_pkthdr header;	/* The header that pcap gives us */
		const u_char *packet;		/* The actual packet */

		/* Define the device */
		dev = pcap_lookupdev(errbuf);
		if (dev == NULL) {
			fprintf(stderr, "Couldn't find default device: %s\n", errbuf);
			return(2);
		}
		/* Find the properties for the device */
		if (pcap_lookupnet(dev, &net, &mask, errbuf) == -1) {
			fprintf(stderr, "Couldn't get netmask for device %s: %s\n", dev, errbuf);
			net = 0;
			mask = 0;
		}
		/* Open the session in promiscuous mode */
		handle = pcap_open_live(dev, BUFSIZ, 1, 1000, errbuf);
		if (handle == NULL) {
			fprintf(stderr, "Couldn't open device %s: %s\n", dev, errbuf);
			return(2);
		}
		/* Compile and apply the filter */
		if (pcap_compile(handle, &fp, filter_exp, 0, net) == -1) {
			fprintf(stderr, "Couldn't parse filter %s: %s\n", filter_exp, pcap_geterr(handle));
			return(2);
		}
		if (pcap_setfilter(handle, &fp) == -1) {
			fprintf(stderr, "Couldn't install filter %s: %s\n", filter_exp, pcap_geterr(handle));
			return(2);
		}
		/* Grab a packet */
		packet = pcap_next(handle, &header);
		/* Print its length */
		printf("Jacked a packet with length of [%d]\n", header.len);
		/* And close the session */
		pcap_close(handle);
		return(0);
	 }
#+end_src

This application sniffs on whatever device is returned by pcap_lookupdev() by
putting it into promiscuous mode. It finds the first packet to come across port
23 (telnet) and tells the user the size of the packet (in bytes). Again, this
program includes a new call, pcap_close(), which we will discuss later (although
it really is quite self explanatory).
** capturing with pcap_loop
The prototype for pcap_loop() is below:

#+begin_src c
	int pcap_loop(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
#+end_src 

The first argument is our session handle. Following that is an integer that
tells pcap_loop() how many packets it should sniff for before returning (a
negative value means it should sniff until an error occurs). The third argument
is the name of the callback function (just its identifier, no parentheses). The
last argument is useful in some applications, but many times is simply set as
NULL. Suppose we have arguments of our own that we wish to send to our callback
function, in addition to the arguments that pcap_loop() sends. This is where we
do it. Obviously, you must typecast to a u_char pointer to ensure the results
make it there correctly; as we will see later, pcap makes use of some very
interesting means of passing information in the form of a u_char pointer. Before
we can provide an example of using pcap_loop(), we must examine the format of
our callback function. We cannot arbitrarily define our callback's prototype;
otherwise, pcap_loop() would not know how to use the function. So we use this
format as the prototype for our callback function:

#+begin_src c
void got_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *packet);
#+end_src 

Let's examine this in more detail. First, you'll notice that the function has a
void return type. This is logical, because pcap_loop() wouldn't know how to
handle a return value anyway. The first argument corresponds to the last
argument of pcap_loop(). Whatever value is passed as the last argument to
pcap_loop() is passed to the first argument of our callback function every time
the function is called. The second argument is the pcap header, which contains
information about when the packet was sniffed, how large it is, etc. The
pcap_pkthdr structure is defined in pcap.h as:

#+begin_src c
	struct pcap_pkthdr {
		struct timeval ts; /* time stamp */
		bpf_u_int32 caplen; /* length of portion present */
		bpf_u_int32 len; /* length this packet (off wire) */
	};
#+end_src

These values should be fairly self explanatory. The last argument is the most
interesting of them all, and the most confusing to the average novice pcap
programmer. It is another pointer to a u_char, and it points to the first byte
of a chunk of data containing the entire packet, as sniffed by pcap_loop().

But how do you make use of this variable (named "packet" in our prototype)? A
packet contains many attributes, so as you can imagine, it is not really a
string, but actually a collection of structures (for instance, a TCP/IP packet
would have an Ethernet header, an IP header, a TCP header, and lastly, the
packet's payload). This u_char pointer points to the serialized version of these
structures. To make any use of it, we must do some interesting typecasting.

First, we must have the actual structures define before we can typecast to them.
The following are the structure definitions that I use to describe a TCP/IP
packet over Ethernet.

#+begin_src c
/* Ethernet addresses are 6 bytes */
#define ETHER_ADDR_LEN	6

	/* Ethernet header */
	struct sniff_ethernet {
		u_char ether_dhost[ETHER_ADDR_LEN]; /* Destination host address */
		u_char ether_shost[ETHER_ADDR_LEN]; /* Source host address */
		u_short ether_type; /* IP? ARP? RARP? etc */
	};

	/* IP header */
	struct sniff_ip {
		u_char ip_vhl;		/* version << 4 | header length >> 2 */
		u_char ip_tos;		/* type of service */
		u_short ip_len;		/* total length */
		u_short ip_id;		/* identification */
		u_short ip_off;		/* fragment offset field */
	#define IP_RF 0x8000		/* reserved fragment flag */
	#define IP_DF 0x4000		/* dont fragment flag */
	#define IP_MF 0x2000		/* more fragments flag */
	#define IP_OFFMASK 0x1fff	/* mask for fragmenting bits */
		u_char ip_ttl;		/* time to live */
		u_char ip_p;		/* protocol */
		u_short ip_sum;		/* checksum */
		struct in_addr ip_src,ip_dst; /* source and dest address */
	};
	#define IP_HL(ip)		(((ip)->ip_vhl) & 0x0f)
	#define IP_V(ip)		(((ip)->ip_vhl) >> 4)

	/* TCP header */
	typedef u_int tcp_seq;

	struct sniff_tcp {
		u_short th_sport;	/* source port */
		u_short th_dport;	/* destination port */
		tcp_seq th_seq;		/* sequence number */
		tcp_seq th_ack;		/* acknowledgement number */
		u_char th_offx2;	/* data offset, rsvd */
	#define TH_OFF(th)	(((th)->th_offx2 & 0xf0) >> 4)
		u_char th_flags;
	#define TH_FIN 0x01
	#define TH_SYN 0x02
	#define TH_RST 0x04
	#define TH_PUSH 0x08
	#define TH_ACK 0x10
	#define TH_URG 0x20
	#define TH_ECE 0x40
	#define TH_CWR 0x80
	#define TH_FLAGS (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)
		u_short th_win;		/* window */
		u_short th_sum;		/* checksum */
		u_short th_urp;		/* urgent pointer */
};
#+end_src

So how does all of this relate to pcap and our mysterious u_char pointer? Well,
those structures define the headers that appear in the data for the packet. So
how can we break it apart? Be prepared to witness one of the most practical uses
of pointers (for all of those new C programmers who insist that pointers are
useless, I smite you).

Again, we're going to assume that we are dealing with a TCP/IP packet over
Ethernet. This same technique applies to any packet; the only difference is the
structure types that you actually use. So let's begin by defining the variables
and compile-time definitions we will need to deconstruct the packet data.

#+begin_src c
/* ethernet headers are always exactly 14 bytes */
#define SIZE_ETHERNET 14

	const struct sniff_ethernet *ethernet; /* The ethernet header */
	const struct sniff_ip *ip; /* The IP header */
	const struct sniff_tcp *tcp; /* The TCP header */
	const char *payload; /* Packet payload */

	u_int size_ip;
	u_int size_tcp;
#+end_src

And now we do our magical typecasting:

#+begin_src c
	ethernet = (struct sniff_ethernet*)(packet);
	ip = (struct sniff_ip*)(packet + SIZE_ETHERNET);
	size_ip = IP_HL(ip)*4;
	if (size_ip < 20) {
		printf("   * Invalid IP header length: %u bytes\n", size_ip);
		return;
	}
	tcp = (struct sniff_tcp*)(packet + SIZE_ETHERNET + size_ip);
	size_tcp = TH_OFF(tcp)*4;
	if (size_tcp < 20) {
		printf("   * Invalid TCP header length: %u bytes\n", size_tcp);
		return;
	}
	payload = (u_char *)(packet + SIZE_ETHERNET + size_ip + size_tcp);
#+end_src

How does this work? Consider the layout of the packet data in memory. The u_char
pointer is really just a variable containing an address in memory. That's what a
pointer is; it points to a location in memory.

For the sake of simplicity, we'll say that the address this pointer is set to is
the value X. Well, if our three structures are just sitting in line, the first
of them (sniff_ethernet) being located in memory at the address X, then we can
easily find the address of the structure after it; that address is X plus the
length of the Ethernet header, which is 14, or SIZE_ETHERNET.

Similarly if we have the address of that header, the address of the structure
after it is the address of that header plus the length of that header. The IP
header, unlike the Ethernet header, does not have a fixed length; its length is
given, as a count of 4-byte words, by the header length field of the IP header.
As it's a count of 4-byte words, it must be multiplied by 4 to give the size in
bytes. The minimum length of that header is 20 bytes.

The TCP header also has a variable length; its length is given, as a number of
4-byte words, by the "data offset" field of the TCP header, and its minimum
length is also 20 bytes.

So let's make a chart:

| variable       | location(in bytes)                                             |
|----------------+----------------------------------------------------------------|
| sniff_ethernet | X                                                              |
| sniff_ip       | X + SIZE_ETHERNET                                              |
| sniff_tcp      | X + SIZE_ETHERNET + {IP HEADER LENGTH }                        |
| payload        | X + SIZE_ETHERNET + {IP Header lengtth} + { TCP header length} |
** get device IP address and net mask

#+begin_src c

int main(int argc, char **argv)
{
  char *dev; /* name of the device to use */
  char *net; /* dot notation of the network address */
  char *mask;/* dot notation of the network mask    */
  int ret;   /* return code */
  char errbuf[PCAP_ERRBUF_SIZE];
  bpf_u_int32 netp; /* ip          */
  bpf_u_int32 maskp;/* subnet mask */
  struct in_addr addr;

  /* ask pcap to find a valid device for use to sniff on */
  dev = pcap_lookupdev(errbuf);

  /* error checking */
  if(dev == NULL)
  {
   printf("%s\n",errbuf);
   exit(1);
  }

  /* print out device name */
  printf("DEV: %s\n",dev);

  /* ask pcap for the network address and mask of the device */
  ret = pcap_lookupnet(dev,&netp,&maskp,errbuf);

  if(ret == -1)
  {
   printf("%s\n",errbuf);
   exit(1);
  }

  /* get the network address in a human readable form */
  addr.s_addr = netp;
  net = inet_ntoa(addr);

  if(net == NULL)/* thanks Scott :-P */
  {
    perror("inet_ntoa");
    exit(1);
  }

  printf("NET: %s\n",net);

  /* do the same as above for the device's mask */
  addr.s_addr = maskp;
  mask = inet_ntoa(addr);

  if(mask == NULL)
  {
    perror("inet_ntoa");
    exit(1);
  }

//....
}
#+end_src

** disset ethernet header

#+begin_src c
// .....
 pcap_t* descr;
   const u_char *packet;
    struct pcap_pkthdr hdr;     /* pcap.h */
    struct ether_header *eptr;  /* net/ethernet.h */
// ....
packet = pcap_next(descr,&hdr);
printf("Ethernet address length is %d\n",ETHER_HDR_LEN);

    /* lets start with the ether header... */
    eptr = (struct ether_header *) packet;

    /* check to see if we have an ip packet */
    if (ntohs (eptr->ether_type) == ETHERTYPE_IP)
    {
        printf("Ethernet type hex:%x dec:%d is an IP packet\n",
                ntohs(eptr->ether_type),
                ntohs(eptr->ether_type));
    }else  if (ntohs (eptr->ether_type) == ETHERTYPE_ARP)
    {
        printf("Ethernet type hex:%x dec:%d is an ARP packet\n",
                ntohs(eptr->ether_type),
                ntohs(eptr->ether_type));
    }else
    {
        printf("Ethernet type %x not IP", ntohs(eptr->ether_type));
        exit(1);
    }
//......
#+end_src

** resources
*** http://www.tcpdump.org/pcap.htm
*** https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
*** http://www.devdungeon.com/content/using-libpcap-c
    
