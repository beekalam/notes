* Tasks
** german anthem
Einigkeit und Recht und Freiheit
Für das deutsche Vaterland!
Danach lasst uns alle streben
Brüderlich mit Herz und Hand!
Einigkeit und Recht und Freiheit
Sind des Glückes Unterpfand;
 |: Blüh' im Glanze dieses Glückes,
  Blühe, deutsches Vaterland! :|
Unity, justice and liberty
For our German fatherland!
For all these let us work and strive
United in hearts and hands!
Unity, justice and liberty
Are the pledges of our land;
 |: Flourish in fortune's blessings,
  Flourish, German fatherland! :|

** Linux Standard Base
Probably the single most relevant standard for a Linux distribution maintainer is the
Linux Standard Base (LSB). The goal of the LSB is to establish a set of standards
designed to enhance the interoperability of applications among different Linux distributions.
** Linux Standard Base Project
http://www.linuxfoundation.org/collaborate/workgroups/lsb
Linux Foundation
http://www.linuxfoundation.org/
** TODO learn some more
  
   [[file:~/Documents/notes/emacs-notes.org::*org-capture][org-capture]]
[[file:~/Documents/notes/problem-solving.org::*Backtracking][Backtracking]]
** TODO update for groups
  
   [[file:~/Documents/notes/ubuntu.org::*Repair%20grub][Repair grub]]
** TODO log to db when shahkar is disconnected
** TODO aaaa
  
   [[file:~/.emacs.d/init.el::'(("t"%20"Todo"%20entry%20(file+headline%20"todo.org"%20"Tasks")]]
** TODO asdfd
  
   [[file:~/.emacs.d/init.el::(setq%20org-default-notes-file%20(concat%20org-directory%20"todo.org"))]]
* Embedded
* memory space
High-performance microprocessors contain complex hardware engines called
Memory Management Units (MMUs). Their purpose is to enable an operating system
to exercise a high degree of management and control over its address space and the
address space it allocates to processes. This control comes in two primary forms: access
rights and memory translation. Access rights allow an operating system to assign specific
memory-access privileges to specific tasks. Memory translation allows an operating
system to virtualize its address space, which has many benefits.
 The Linux kernel takes advantage of these hardware MMUs to create a virtual
memory operating system
* Execution Contexts
 In Linux, we refer to two distinctly separate operational contexts, based on the
environment in which a given thread15 is executing. Threads executing entirely within
the kernel are said to be operating in kernel context. Application programs are said to
operate in user space context. A user space process can access only memory it owns, and
it is required to use kernel system calls to access privileged resources such as file and
device I/O. 
 When an application program executes a system call that
results in a context switch and enters the kernel, it is executing kernel code on behalf
of a process. You will often hear this referred to as process context within the kernel. In
contrast, the interrupt service routine (ISR) handling the IDE drive (or any other ISR,
for that matter) is kernel code that is not executing on behalf of any particular process.
This is typically called interrupt context.
* Processors
* Stand-Alone Processors
Stand-alone processors are processor chips that are dedicated exclusively to the
processing function. As opposed to integrated processors, stand-alone processors
require additional support circuitry for their basic operation. In many cases, this
means a chipset or custom logic surrounding the processor to handle functions such
as DRAM controller, system bus addressing configuration, and external peripheral
devices such as keyboard controllers and serial ports. Stand-alone processors often
offer the highest overall CPU performance.

** Companion Chipsets
Stand-alone processors require support logic to connect to and enable
external peripheral devices such as main system memory (DRAM), ROM or
Flash memory, system buses such as PCI, and other peripherals.  This
support logic often is accomplished by companion chipsets, which may
even be purpose-designed specifically for a family of processors.

*** northbridge , southbridge
northbridge is directly connected to the  processor's high-speed front-side bus (FSB).

* Ich kann alless lyrics
[Verse 1]
Ich nehm' mein Ego, quetsch' es aus
Alle Tränen müssen raus
Betrunken von mir selbst, füll' leere Gläser wieder auf
Leere Gläser wieder aus
Selbst der Wasserwerfer kann mir nichts
Strahle so hell, dass alles regenbogenfarben ist
Wo die Nacht pulsiert, wo jeder was erwartet
Mich niemand wirklich kennt, wirklich niemand auf mich wartet

[Pre-Hook]
Weiß niemand, wo mein Herz schlägt?
Weiß niemand, wo mein Herz schlägt?
Und die Vögel, sie zwitschern immer noch das alte Lied
Ein zahmer singt von Freiheit, ein wilder Vogel fliegt
Und jeder Spruch klingt so wie tausende zuvor
Nicht mehr wert als nur ein Rauschen im Ohr

[Hook]
Mir egal, ich kann alles
Ich kann alles
Ich kann alles
Alles glänzt, was ab jetzt vor mir liegt
Ich kann alles
Ich kann alles
Ich kann alles
Bis ich aufschlag' beweis' ich, dass ich flieg'

[Verse 2]
Ich hab mir alles geglaubt, mir meine Lügen auch
Und dass die Lügen Lügen waren, glaub' ich mir jetzt auch
Wissen ersetzt denken nicht, weiß ich nicht, denke ich
Ich hab mich an mir verblendet, schrieb Geschichte nur in Blindenschrift
Wollte nicht so sein wie sie, wusste, was ich werden muss
Andere Leute werden groß, ich mach' mit dem werden Schluss
Und wenn mich jemand hasst, hab ich immer noch irgendwas
Das der jemand gerne hätte - alles richtig gemacht

[Pre-Hook]
Ich weiß wieder wo mein Herz schlägt
Ich weiß wieder wo mein Herz schlägt
Und die Vögel, sie zwitschern immer noch das alte Lied
Ein zahmer singt von Freiheit, ein wilder Vogel fliegt
Und jeder Spruch klingt so wie tausende zuvor
Nicht mehr wert als nur ein Rauschen im Ohr

[Hook]
Mir egal, ich kann alles
Ich kann alles
Ich kann alles
Alles glänzt, was ab jetzt vor mir liegt
Ich kann alles
Ich kann alles
Ich kann alles
Bis ich aufschlag' beweis' ich, dass ich flieg'

[Bridge]
Schau mich an, ich kann alles
Ich kann nicht viel, nein, alles
Wie viel ich verdien'? Alles!
Mein einziges Ziel? Alles!
Schau mich an, ich kann alles
Hab' mich entschieden gegen alle
Mach' meinen Frieden mit allen
Entschieden zu fliegen, bis ich falle

[Hook] x2
Ich kann alles
Ich kann alles
Ich kann alles
Alles glänzt, was ab jetzt vor mir liegt
Ich kann alles
Ich kann alles
Ich kann alles
Bis ich aufschlag' beweis' ich, dass ich flieg'
* LFS assumes that the root file system (/) is of type ext4. To create an ext4 file system on the LFS partition, run the following:
  
mkfs -v -t ext4 /dev/<xxx>
If you are using an existing swap partition, there is no need to format it. If a new swap partition was created, it will need to be initialized with this command:

mkswap /dev/<yyy>
Replace <yyy> with the name of the swap partition.
* LFS assumes that the root file system (/) is of type ext4. To create an ext4 file system on the LFS partition, run the following:

mkfs -v -t ext4 /dev/<xxx>
If you are using an existing swap partition, there is no need to format it. If a new swap partition was created, it will need to be initialized with this command:

mkswap /dev/<yyy>
Replace <yyy> with the name of the swap partition.
* LFS assumes that the root file system (/) is of type ext4. To create an ext4 file system on the LFS partition, run the following:

mkfs -v -t ext4 /dev/<xxx>
If you are using an existing swap partition, there is no need to format it. If a new swap partition was created, it will need to be initialized with this command:

mkswap /dev/<yyy>
Replace <yyy> with the name of the swap partition.
* LFS assumes that the root file system (/) is of type ext4. To create an ext4 file system on the LFS partition, run the following:

mkfs -v -t ext4 /dev/<xxx>
If you are using an existing swap partition, there is no need to format it. If a new swap partition was created, it will need to be initialized with this command:

mkswap /dev/<yyy>
Replace <yyy> with the name of the swap partition.

============ 
LFS assumes that the root file system (/) is of type
ext4. To create an ext4 file system on the LFS partition, run the
following:

mkfs -v -t ext4 /dev/<xxx> 

If you are using an existing swap
partition, there is no need to format it. If a new swap partition was
created, it will need to be initialized with this command:

mkswap /dev/<yyy>

Replace <yyy> with the name of the swap partition.
export LFS=/mnt/lfs

Create the mount point and mount the LFS file system by running:

mkdir -pv $LFS
mount -v -t ext4 /dev/<xxx> $LFS

If using multiple partitions for LFS (e.g., one for / and another for /usr), mount them using:

mkdir -pv $LFS
mount -v -t ext4 /dev/<xxx> $LFS
mkdir -v $LFS/usr
mount -v -t ext4 /dev/<yyy> $LFS/usr

If you are using a swap partition, ensure that it is enabled using the swapon command:

/sbin/swapon -v /dev/<zzz>
Replace <zzz> with the name of the swap partition

mkdir -v $LFS/sources
Make this directory writable and sticky. “Sticky” means that even if multiple users have write permission on a directory, only the owner of a file can delete the file within a sticky directory. The following command will enable the write and sticky modes:

chmod -v a+wt $LFS/sources
An easy way to download all of the packages and patches is by using wget-list as an input to wget. For example:

wget --input-file=wget-list --continue --directory-prefix=$LFS/sources


mkdir -v $LFS/tools
ln -sv $LFS/tools /
groupadd lfs
useradd -s /bin/bash -g lfs -m -k /dev/null lfs
passwd lfs
chown -v lfs $LFS/tools
chown -v lfs $LFS/sources
su - lfs

cat > ~/.bash_profile << "EOF"
exec env -i HOME=$HOME TERM=$TERM PS1='\u:\w\$ ' /bin/bash
EOF


cat > ~/.bashrc << "EOF"
set +h
umask 022
LFS=/mnt/lfs
LC_ALL=POSIX
LFS_TGT=$(uname -m)-lfs-linux-gnu
PATH=/tools/bin:/bin:/usr/bin
export LFS LC_ALL LFS_TGT PATH
EOF

source ./.bash_profile

The Binutils documentation recommends building Binutils in a dedicated build directory:

mkdir -v build
cd       build

../configure --prefix=/tools            \
             --with-sysroot=$LFS        \
             --with-lib-path=/tools/lib \
             --target=$LFS_TGT          \
             --disable-nls              \
             --disable-werror

If building on x86_64, create a symlink to ensure the sanity of the toolchain:

case $(uname -m) in
  x86_64) mkdir -v /tools/lib && ln -sv lib /tools/lib64 ;;
esac
Install the package:

make install
* this is a capture dump
* this is a new todo?
  what is your name
route add -net 172.16.11.0/24 172.16.12.141
** 
howManyBees = function(hive) {
  var res = 0;
  for(var k in hive){
    var row = hive[k];
    var rev = row.split('').reverse().join('');
    res += (row.match(/bee/g) || []).length;
    res += (rev.match(/bee/g) || []).length;
  }
  var cols = [];
  for(var i = 0; i < hive.length; ++i){
    var col='';
    for(var j = 0; j< hive.length; ++j){
      col += hive[i][j];
    }
    cols.push(col);
  }
  
  for(var k in cols){
    var row = cols[k];
    var rev = row.split('').reverse().join('');
    res += (row.match(/bee/g) || []).length;
    res += (rev.match(/bee/g) || []).length;
  }
  
  return res;
}
* PPP over SSH with linux
PPP over SSH with linux

What?

PPP is an IP point-to-point link protocol that operates over terminals. Usually the terminal is a modem, but any tty will do. SSH creates secure ttys. SSH also has the advantage that it uses a single client->server TCP connection, and thereby NATs cleanly. These properties make it pass easily through firewalls and NAT routers. PPP over SSH is a poor man's VPN.

Why?

Because it can be done. And because sometimes it's quickest way to get the job done. One place it is useful is securing wireless connections. ppp over ssh over 802.11.

How?

PPP over SSH needs to be resilient. The SSH connection needs to connect and reconnect on its own when the connection is lost. To achieve this use SSH's public key authentication method and manually add the key to ssh-agent on the client side before connecting. Then configure ppp to "dial" using ssh, and to redial when the connection is lost. With this configuration SSH will reconnect as long as the client machine does not loose power. This is good enough in most cases; a UPS will make it even more reliable.

SSH will need a login and a public key. For safety this should be a new login on the server, and normal login should be disabled (A '*' in place of the password in /etc/shadow). If the client will be connecting from a static address, use of the public key should be restricted to that address. And that key does not need X11 forwarding, nor ssh agent forwarding. These also should be disabled for that key.

Because the PPP is tunneled over SSH you could use plaintext PPP passwords, but since CHAP is just as easy, do it.

Lastly if the client is in fact a router, IP routes should be setup at either end to point throught the tunnel. These can be hand configured in /etc/network/interfaces or with "/sbin/ip route add ..." commands in ppp-up. But running a routing daemon at both ends of the ppp link works much better. OSPF works well for this.

HOWTO

First configure ssh. Create a new user for SSH to login to.

root@server # adduser --disabled-password ppp-link
Create an ssh key pair on the client.

user@client > ssh-keygen -t rsa -f $HOME/.ssh/ppp_rsa
Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/user/.ssh/ppp_rsa.
Your public key has been saved in /home/user/.ssh/ppp_rsa.pub.
The key fingerprint is:
04:32:f5:c5:0f:94:4b:46:37:d4:00:ab:45:4d:66:ae user@client

Copy the public key (ppp_rsa.pub) to ~ppp-link/.ssh/authorized_keys on the
server. Then add options to the line in authorized_keys to restrict how it can
be used. For example:

ppp-link@server > cat $HOME/.ssh/authorized_keys
from="192.168.168.*",no-port-forwarding,no-X11-forwarding,no-agent-forwarding ssh-rsa AAAB...5+TCM= user@client

removes all the capabilities that aren't needed (port & X11 and ssh-agent
forwarding), and restricts the source IP so that the client must connect from
the 192.168.168.0/24 IP subnet. Restricting the client's IP address is a good
thing, especially if this is a public ssh server. See the AUTHORIZED_KEYS FILE
FORMAT section of the sshd manpage for more ways 'from' can be configured.

At this point ssh should be working. Test it:

user@client > ssh -l ppp-link -i $HOME/.ssh/ppp_rsa server
Enter passphrase for key '/home/user/.ssh/ppp_rsa':
ppp-link@server > exit
logout
Connection to server closed.

Then configure ppp. 

First add secrets for the chap authentication and IP addresses for the endpoints
of the ppp link. You can use a different secret in each direction. This way the
ppp client can authenticate the ppp server. In this example the client machine
has been called "client" and the server "server". They should be replaced with
the actual hostnames (or whatever PPP is configured to use for names).

root@server # echo >>/etc/ppp/chap-secrets <<EOF
client          server  secret1          10.1.1.1
server          client  secret2          10.1.1.2
EOF
Add the same secrets to the chap-secrets file on the client.

root@client # echo >>/etc/ppp/chap-secrets <<EOF
client          server  secret1          10.1.1.1
server          client  secret2          10.1.1.2
EOF
And lastly create a ppp peer configuration file on the client. The name of the file will be the name ppp will be told to call.

root@client # echo >>/etc/ppp/peers/server <<EOF

# use a seperate log file
logfile /var/log/ppp/server.log

# names to use in secret lookup
name client
remotename server

# other side must authenticate to us
auth

# don't allow pap out of paranoia (actually in case we mess up and don't use ssh)
require-chap

# don't accept the default route from the other end. This is useful if we are using
# ppp-over-ssh to reach only certain hosts, since it prevents us from sending everything
# through the ppp link. But if everything should go through the link then "nodefaultroute"
# should be commented out, and the "defaultroute" and "replacedefaultroute" lines uncommented.
nodefaultroute
#defaultroute
#replacedefaultroute

# to switch DNS servers to what server specifies, uncomment "usepeerdns"
# depending on your distribution, you might also have to copy /etc/ppp/resolv.conf 
# to /etc/resolv.conf as part of ppp-up
#usepeerdns

# the magic line: "dial" with ssh. blowfish is faster than 3DES.
pty "/usr/bin/ssh -e none -c blowfish -t -l ppp-link server /usr/sbin/pppd passive"

# give ssh+remote pppd up to 30 seconds to start ppp'ing
connect-delay 30000

# make sure we fit in a single ethernet packet after ssh-encryption/tcp/ip headers
mtu 1200
mru 1200

# after we connect, detach from shell and run in background
updetach

# reconnect if we get disconnected
persist
holdoff 60

# keep trying to connect forever
maxfail 0

EOF
On debian users must be part of the dip group so they can execute pppd

root@client # usermod -G dip user
root@server # usermod -G dip ppp-link
And the log directory needs to be created if it doesn't already exist

root@client # mkdir /var/log/ppp

Now everything is ready. Starting up an ssh-agent (note well: back-ticks, not
single-quotes), and adding the public key to ssh-agent keeps ssh from prompting
for a passphrase each time ppp (re)connects.

user@client > eval `ssh-agent`
Agent pid 12345
user@client > ssh-add $HOME/.ssh/ppp_rsa
Enter passphrase for /home/user/.ssh/ppp_rsa:
Identity added: /home/user/.ssh/ppp_rsa (/home/user/.ssh/ppp_rsa)
user@client > pppd call server
Check that the connection took place and is working as it should

user@client > tail /var/log/ppp/server.log
Using interface ppp0
Connect: ppp0 <--> /dev/pts/10
CHAP peer authentication succeeded for server
Remote message: Welcome to server.
Deflate (15) compression enabled
local  IP address 10.1.1.1
remote IP address 10.1.1.2
user@client > /sbin/ip addr
1: lo:  mtu 16436 qdisc noqueue
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    127.0.0.1/8 brd 127.255.255.255 scope host lo
2: eth0:  mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:01:02:b1:12:5b brd ff:ff:ff:ff:ff:ff
    inet 192.168.168.2/24 brd 192.168.168.255 scope global eth0
3: ppp0:  mtu 1200 qdisc pfifo_fast qlen 3
    link/ppp
    inet 10.1.1.1 peer 10.1.1.2/32 scope global ppp0
user@client > ping -c3 10.1.1.2
PING 10.10.10.2 (10.1.1.2) from 10.1.1.1 : 56(84) bytes of data.
64 bytes from 10.1.1.2: icmp_seq=1 ttl=255 time=50.7 ms
64 bytes from 10.1.1.2: icmp_seq=2 ttl=255 time=26.7 ms
64 bytes from 10.1.1.2: icmp_seq=3 ttl=255 time=29.2 ms

--- 10.1.1.2 ping statistics ---
3 packets transmitted, 3 received, 0% loss, time 2023ms
rtt min/avg/max/mdev = 26.795/35.617/50.768/10.762 ms
Looks good!

tunneling the default route

If the ppp-over-ssh link is being used to create a link to the internet (for
example when securing a wireless link) then the default route must point through
the tunnel. Two things must be true for this to happen: 'nodefaultroute' must be
changed to 'defaultroute' in the ppp peer's configuration, and if there exists a
default route before ppp connects then 'replacedefaultroute' must also be in the
peer's configuration. Without this pppd will not replace the existing default
route. Instead it will log a message to that effect: "not replacing default
route to eth0 [192.168.168.1]". As an added niceity, ppp will restore the
default route when the ppp link is torn down.

In the case of a wireless connection, client usually gets its IP address and
route table from the DHCP server in the wireless router. That DHCP server cannot
be configured not to advertise itself as the default gateway. So both
'defaultroute' and 'replacedefaultroute' are needed.

The DNS server address(es) might also have to be altered if the router also
advertised itself as the DNS server. Again the cleanest way to do this is to
pass the DNS address(es) to client as part of the ppp connection parameters.
'usepeerdns' on the client's peer configuration, and 'ms-dns' in the server's
options configuration file /etc/ppp/options.

OSPF

If other computers need to use client's ppp link, client will be acting as a
router. In this case it is most dynamic to run a routing daemon on client and
server and have then exchange routes over the ppp link. I prefer OSPF for this
since it doesn't send much traffic when no routes change. OSPF can also
advertise a default route, which removes the need to add it manually. Here is a
typical configurations for zebra's ospfd

root@server # cat /etc/zebra/ospfd.conf
hostname server

# ospf on the local LAN
interface eth0
 ip ospf authentication message-digest
 ip ospf message-digest-key 1 md5 secret_phrase_for_lan
exit

# ospf through the ppp tunnel
interface ppp0
 ip ospf network point-to-point
 # binding of key to ppp0 gets lost after ppp0 goes and comes back, so don't use auth
 #ip ospf authentication message-digest
 #ip ospf message-digest-key 1 md5 secret_phrase_for_ppp
exit

router ospf
 ospf router-id 192.168.168.1
 redistribute connected
 #redistribute static
 network 192.168.168.0/24 area 0
 network 10.1.1.1/32 area 0
exit

log file /var/log/zebra/ospfd.log

Unfortunately zebra's ospf looses the md5 key -> ppp0 binding if ppp0 goes down,
so it is not possible to use authentication with ospf on the ppp link. And
unfortunately zebra's ospf needs the name of the ppp link device. If there is
only one tunnel at any time then it is ppp0. If there are multiple tunnels then
ospfd must be reconfigured dynamically as part of the ppp-up process by passing
the appropriate commands to vtysh.

http://nsd.dyndns.org/pppossh/
* hajimi
https://security.rapiditynetworks.com/publications/2016-10-16/hajime.pdf
https://github.com/beekalam/Mirai-Source-Code
** 
https://routerboard.com/rb750g
https://routerboard.com/rb433ah
https://routerboard.com/rb450g

https://www.itbazar.com/all2_P_S_4734321.aspx
** 
۱۳۹۶/۰۲/۰۳
۱۳۹۵/۱۲/۲۶

* writing maintainable software
** Write Short Units of Code
*** intro
Units are the smallest groups of code that can be maintained and executed independ‐
ently. In Java, units are methods or constructors. A unit is always executed as a whole.
It is not possible to invoke just a few lines of a unit. Therefore, the smallest piece of
code that can be reused and tested is a unit.

 - Short Units Are Easy to Test
 - Short Units Are Easy to Analyze
 - Short Units Are Easy to Reuse
*** how to apply
 - Refactoring technique: Extract Method
 - Refactoring technique: Replace Method with Method Object
 - Limit the length of code units to 15 lines of code.
** Write Simple Units of Code
*** intro
 - Limit the number of branch points per unit to 4.
 - Do this by splitting complex units into simpler ones and avoiding complex units altogether.
 - This improves maintainability because keeping the number of branch points low makes units easier to modify and test.
*** How to apply
**** Dealing with Conditional Chains
   - use a Map data structure
   - Replace Conditional with Polymorphism pattern 

* timer1
  https://github.com/samyk/evercookie/
* css

http://kushagragour.in/lab/hint/
https://purecss.io/tools/
https://me.tamin.ir/js/register.js
https://me.tamin.ir/service/secure/registration

* javascript

var complexityText = 'پیچیدگی گذرواژه کافی نیست';
var complexityTextUpperCase = 'گذرواژه باید حداقل شامل یک کاراکتر بزرگ باشد';
var complexityTextLowerCase = 'گذرواژه باید حداقل شامل یک کاراکتر کوچک باشد';
var complexityTextDigit = 'گذرواژه باید شامل عدد باشد';
var complexityTextStartCharAlphabet = 'گذرواژه باید با یک حرف آغاز شود';
var complexityTextLength = 'گذرواژه حداقل باید هشت حرف باشد';
var complexityTextNotContainsSomeFields = 'گذرواژه باید با حروف لاتین بوده و شامل نام، نام خانوادگی و شماره ملی یا کد اتباع خارجی نباشد.';
var complexityTextFirstName = 'پیش از ورود نام امکان ارزیابی گذرواژه وجود ندارد';
var complexityTextlastName = 'پیش از ورود نام خانوادگی امکان ارزیابی گذرواژه وجود ندارد';
var complexityTextNationalCode = 'پیش از ورود کدملی یا شماره اتباع خارجی امکان ارزیابی گذرواژه وجود ندارد';
var complexityTextValidChar = 'فقط از کاراکترهای لاتین مجاز استفاده نمایید. شامل حروف، اعداد و !#$%&* ';

function hasClass(ele, cls) {
    return ele.className.match(new RegExp('(\\s|^)' + cls + '(\\s|$)'));
}

function addClass(ele, cls) {
    if (!this.hasClass(ele, cls))
        ele.className += " " + cls;
}
function removeClass(ele, cls) {
    if (hasClass(ele, cls)) {
        var reg = new RegExp('(\\s|^)' + cls + '(\\s|$)');
        ele.className = ele.className.replace(reg, ' ');
    }
}

function deleteButtonClick() {
    var queueNumber = document.getElementById('queueNumber');
    var nationalCode = document.getElementById('nationalCode');
    window.location.href = 'service/secure/delete-request?nationalCode=' + nationalCode.value + '&queueNumber=' + queueNumber.value;
}

function validateForm() {
    var result = true;
    result = result &
            validateLastName() &
            validateFirstName() &
            validateNationalCode() &
            validateEmail() &
            validatePassword() &
            validateRepeatedPassword() &
            validatePasswordsEquality() &
            validateMobile() &
            validateQuestion1() &
            validateQuestion2() &
            validateQuestion3() &
            validateQuestionEquality() &
//            validateSerialNo() &
//            validateSerialDigit() &
//            validateSerialAlphabet() &
            validateIdNo() &
            validateAnswer1() &
            validateAnswer2() &
            validateAnswer3() &
            validateAnswerEquality() &
//            validateDayOfBirth() &
            validateYearOfBirth();

    console.log(result != 0);
    return result != 0;
}

function validateMobile() {
    var mobile = document.getElementById('mobile');
    removeValidationEffects(mobile)
    if (mobile.value == null || mobile.value.trim() == '') {
        setInvalid(mobile, 'وارد نمودن شماره موبایل اجباری است');
        return false;
    }

    var re = /^[0-9]*$/;
    if (!re.test(mobile.value)) {
        setInvalid(mobile, 'شماره موبایل باید با کاراکترهای لاتین، بدون حرف و سایر کاراکترها وارد شود.');
        return false;
    }

    if (isNaN(mobile.value)) {
        setInvalid(mobile, 'شماره موبایل باید عدد باشد');
        return false;
    }

    if (mobile.value.length < 11) {
        setInvalid(mobile, 'شماره موبایل نادرست است');
        return false;
    }

    var reg = /^[0][9].*$/;
    if (!reg.test(mobile.value)) {
        setInvalid(mobile, 'شماره موبایل باید با عدد 09 شروع شود.');
        return false;
    }


    setValid(mobile);
    return true;
}

//function validateMobile() {
//    var mobile = document.getElementById('mobile');
//    removeValidationEffects(mobile)
//    if (mobile.value == null || mobile.value.trim() == '') {
//        setInvalid(mobile, 'وارد نمودن شماره موبایل اجباری است');
//        return false;
//    }
//
//    var re = /^[0-9]*$/;
//    if (!re.test(mobile.value)) {
//        setInvalid(mobile, 'شماره موبایل باید با کاراکترهای لاتین، بدون حرف و سایر کاراکترها وارد شود.');
//        return false;
//    }
//
//    if (isNaN(mobile.value)) {
//        setInvalid(mobile, 'شماره موبایل باید عدد باشد');
//        return false;
//    }
//
//
//    setValid(mobile);
//    return true;
//}

function validateSerialNo() {
    var serialNo = document.getElementById('serialNo');
    removeValidationEffects(serialNo)
    if (serialNo.value == null || serialNo.value.trim() == '') {
        setInvalid(serialNo, 'وارد نمودن شماره سریال اجباری است');
        return false;
    }

    var re = /^[0-9]*$/;
    if (!re.test(serialNo.value)) {
        setInvalid(serialNo, 'شماره سریال باید با کاراکترهای لاتین، بدون حرف و سایر کاراکترها وارد شود.');
        return false;
    }

    if (isNaN(serialNo.value)) {
        setInvalid(serialNo, 'شماره سریال باید عدد باشد');
        return false;
    }

    setValid(serialNo);
    return true;
}

function validateSerialDigit() {
    var serialDigit = document.getElementById('serialDigit');
    removeValidationEffects(serialDigit)
    if (serialDigit.value == null || serialDigit.value.trim() == '') {
//        setInvalid(serialDigit, 'وارد نمودن شماره سری اجباری است');
//        return false;
        return true;
    }

    var re = /^[0-9]*$/;
    if (!re.test(serialDigit.value)) {
        setInvalid(serialDigit, 'شماره سری باید با کاراکترهای لاتین، بدون حرف و سایر کاراکترها وارد شود.');
        return false;
    }

    if (isNaN(serialDigit.value)) {
        setInvalid(serialDigit, 'شماره سری باید عدد باشد');
        return false;
    }

    setValid(serialDigit);
    return true;
}

function validateIdNo() {
    var idNo = document.getElementById('idNo');
    removeValidationEffects(idNo)
    if (idNo.value == null || idNo.value.trim() == '') {
        setInvalid(idNo, 'وارد نمودن شماره شناسنامه اجباری است');
        return false;
    }

    var re = /^[0-9]*$/;
    if (!re.test(idNo.value)) {
        setInvalid(idNo, 'شماره شناسنامه باید با کاراکترهای لاتین، بدون حرف و سایر کاراکترها وارد شود.');
        return false;
    }

    if (isNaN(idNo.value)) {
        setInvalid(idNo, 'شماره شناسنامه باید عدد باشد');
        return false;
    }
    setValid(idNo);
    return true;
}

function validateLastName() {
    var lastName = document.getElementById('lastName');
    removeValidationEffects(lastName)
    if (lastName.value == null || lastName.value.trim() == '') {
        setInvalid(lastName, 'وارد نمودن نام خانوادگی اجباری است');
        return false;
    }
    setValid(lastName);
    return true;
}
function validateFirstName() {
    var firstName = document.getElementById('firstName');
    removeValidationEffects(firstName);
    if (firstName.value == null || firstName.value.trim() == '') {
        setInvalid(firstName, 'وارد نمودن نام اجباری است');
        return false;
    }
    setValid(firstName);
    return true;
}
function validateNationalCode() {
    var nationalCode = document.getElementById('nationalCode');
    removeValidationEffects(nationalCode);
    if (nationalCode.value == null) {
        setInvalid(nationalCode, 'وارد نمودن کد ملی اجباری است');
        return false;
    }
    if (nationalCode.value.length != 10) {
        setInvalid(nationalCode, 'کد ملی نادرست است');
        return false;
    }
    var re = /^[0-9]*$/;
    if (!re.test(nationalCode.value)) {
        setInvalid(nationalCode, 'کد ملی باید با کاراکترهای لاتین، بدون حرف و سایر کاراکترها وارد شود.');
        return false;
    }

    if (isNaN(nationalCode.value)) {
        setInvalid(nationalCode, 'کد ملی می بایست عدد باشد');
        return false;
    }
    setValid(nationalCode);
    return true;
//    var nationalCode = document.getElementById('nationalCode');
//    removeValidationEffects(nationalCode);
//    if (nationalCode.value == null || nationalCode.value.trim() == '') {
//        setInvalid(nationalCode, 'وارد نمودن کد ملی/اتباع خارجی اجباری است');
//        return false;
//    }
//    if (nationalCode.value.length != 10 && nationalCode.value.length != 13) {
//        setInvalid(nationalCode, 'کد ملی/اتباع خارجی نادرست است');
//        return false;
//    }
//    setValid(nationalCode);
//    return true;
}
function validateEmail() {
    var email = document.getElementById('email');
    removeValidationEffects(email);
    if (email.value == null || email.value.trim() == '') {
        setInvalid(email, 'وارد نمودن ایمیل اجباری است');
        return false;
    }

    var re = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i;
    if (!re.test(email.value)) {
        setInvalid(email, 'آدرس ایمیل وارد شده صحیح نمی باشد');
        return false;
    }

    setValid(email);
    return true;
}

function validateSerialAlphabet() {
    var serialAlphabet = document.getElementById('serialAlphabet');
    removeValidationEffects(serialAlphabet);
    if (serialAlphabet.value == null || serialAlphabet.value.trim() == '') {
//        setInvalid(serialAlphabet, 'وارد نمودن شماره سریال اجباری است');
//        return false;
        return true;
    }

//    var re = '/^[\u0600-\u065F\u066A-\u06EF\u06FA-\u06FF]*$/';
//    if (!re.test(serialAlphabet.value)) {
//        setInvalid(serialAlphabet, 'بخش آغازین شماره سریال باید از حروف فارسی باشد.');
//        return false;
//    }

    setValid(serialAlphabet);
    return true;
}


function validatePassword() {
    var password = document.getElementById('password');
    removeValidationEffects(password);
    if (password.value == null || password.value.trim() == '') {
        setInvalid(password, 'وارد نمودن گذرواژه اجباری است');
        return false;
    }

    if (password.value.length < 8) {
        setInvalid(password, 'گذرواژه حداقل باید هشت حرف باشد');
        return false;
    }
    if (!passwordComplexityStartChar(password.value)) {
        setInvalid(password, complexityTextStartCharAlphabet);
        return false;
    }
    if (!passwordComplexityUpperCase(password.value)) {
        setInvalid(password, complexityTextUpperCase);
        return false;
    }
    if (!passwordComplexityLowerCase(password.value)) {
        setInvalid(password, complexityTextLowerCase);
        return false;
    }
    if (!passwordComplexityDigit(password.value)) {
        setInvalid(password, complexityTextDigit);
        return false;
    }
    if (!passwordComplexityValidChar(password.value)) {
        setInvalid(password, complexityTextValidChar);
        return false;
    }

    var nationalCode = document.getElementById('nationalCode');
    var firstName = document.getElementById('firstName');
    var lastName = document.getElementById('lastName');

    if (nationalCode.value === null || nationalCode.value === '') {
        setInvalid(password, complexityTextNationalCode);
        return false;
    }
    if (firstName.value === null || firstName.value === '') {
        setInvalid(password, complexityTextFirstName);
        return false;
    }
    if (lastName.value === null || lastName.value === '') {
        setInvalid(password, complexityTextlastName);
        return false;
    }

    if (passwordComplexityNotContainsSomeFields(password.value, firstName.value, lastName.value, nationalCode.value)) {
        setInvalid(password, complexityTextNotContainsSomeFields);
        return false;
    }



//    if (password.value.length < 8) {
//        setInvalid(password, 'گذرواژه حداقل باید هشت حرف باشد');
//        return false;
//    }
//
//    if (!passwordComplexity(password.value)) {
//        setInvalid(password, complexityText);
//        return false;
//    }

    setValid(password);
    return true;
}
function validateRepeatedPassword() {
    var repeatedPassword = document.getElementById('repeatedpassword');
    removeValidationEffects(repeatedPassword);
    if (repeatedPassword.value == null || repeatedPassword.value.trim() == '') {
        setInvalid(repeatedPassword, 'وارد نمودن تکرار گذرواژه اجباری است');
        return false;
    }

    if (repeatedPassword.value.length < 8) {
        setInvalid(repeatedPassword, 'گذرواژه حداقل باید هشت حرف باشد');
        return false;
    }
    if (!passwordComplexityStartChar(repeatedPassword.value)) {
        setInvalid(repeatedPassword, complexityTextStartCharAlphabet);
        return false;
    }
    if (!passwordComplexityUpperCase(repeatedPassword.value)) {
        setInvalid(repeatedPassword, complexityTextUpperCase);
        return false;
    }
    if (!passwordComplexityLowerCase(repeatedPassword.value)) {
        setInvalid(repeatedPassword, complexityTextLowerCase);
        return false;
    }
    if (!passwordComplexityDigit(repeatedPassword.value)) {
        setInvalid(repeatedPassword, complexityTextDigit);
        return false;
    }
    if (!passwordComplexityValidChar(repeatedPassword.value)) {
        setInvalid(repeatedPassword, complexityTextValidChar);
        return false;
    }

    var nationalCode = document.getElementById('nationalCode');
    var firstName = document.getElementById('firstName');
    var lastName = document.getElementById('lastName');

    if (nationalCode.value === null || nationalCode.value === '') {
        setInvalid(repeatedPassword, complexityTextNationalCode);
        return false;
    }
    if (firstName.value === null || firstName.value === '') {
        setInvalid(repeatedPassword, complexityTextFirstName);
        return false;
    }
    if (lastName.value === null || lastName.value === '') {
        setInvalid(repeatedPassword, complexityTextlastName);
        return false;
    }

    if (passwordComplexityNotContainsSomeFields(repeatedPassword.value, firstName.value, lastName.value, nationalCode.value)) {
        setInvalid(repeatedPassword, complexityTextNotContainsSomeFields);
        return false;
    }

//    if (repeatedPassword.value.length < 8) {
//        setInvalid(repeatedPassword, 'گذرواژه حداقل باید هشت حرف باشد');
//        return false;
//    }
//
//    if (!passwordComplexity(repeatedPassword.value)) {
//
//        setInvalid(repeatedPassword, complexityText);
//        return false;
//    }

    setValid(repeatedPassword);
    return true;
}

function validatePasswordsEquality() {
    var password = document.getElementById('password');
    var repeatedPassword = document.getElementById('repeatedpassword');
    if (!hasClass(password, 'valid') && !hasClass(repeatedPassword, 'valid')) {
        return false;
    }

    removeValidationEffects(password);
    removeValidationEffects(repeatedPassword);

    var v1 = repeatedPassword.value;
    var v2 = password.value;
    console.log(v1);
    console.log(v2);
    if (v1 !== v2) {
        console.log(password.value);
        console.log(repeatedPassword.value);
        setInvalid(repeatedPassword, 'گدرواژه و تکرار آن یکسان نمی باشد');
        setInvalid(password, 'گدرواژه و تکرار آن یکسان نمی باشد');
        return false;
    }
    setValid(password);
    setValid(repeatedPassword);
    return true;
}

function validateQuestionEquality() {
    var question1 = document.getElementById('question1');
    var question2 = document.getElementById('question2');
    var question3 = document.getElementById('question3');
    if (!hasClass(question1, 'valid') && !hasClass(question2, 'valid') && !hasClass(question3, 'valid')) {
        return false;
    }

    removeValidationEffects(question1);
    removeValidationEffects(question2);
    removeValidationEffects(question3);

    var v1 = question1.value.trim();
    var v2 = question2.value.trim();
    var v3 = question3.value.trim();
    if (v1 === v2 || v1 === v3 || v2 === v3) {
        setInvalid(question1, 'سوالات امنیتی نمیتوانند یکسان باشند.');
        setInvalid(question2, 'سوالات امنیتی نمیتوانند یکسان باشند.');
        setInvalid(question3, 'سوالات امنیتی نمیتوانند یکسان باشند.');
        return false;
    }
    setValid(question1);
    setValid(question2);
    setValid(question3);
    return true;
}

function validateAnswerEquality() {
    var answer1 = document.getElementById('answer1');
    var answer2 = document.getElementById('answer2');
    var answer3 = document.getElementById('answer3');
    if (!hasClass(answer1, 'valid') && !hasClass(answer2, 'valid') && !hasClass(answer3, 'valid')) {
        return false;
    }

    removeValidationEffects(answer1);
    removeValidationEffects(answer2);
    removeValidationEffects(answer3);

    var v1 = answer1.value.trim();
    var v2 = answer2.value.trim();
    var v3 = answer3.value.trim();
    if (v1 === v2 || v1 === v3 || v2 === v3) {
        setInvalid(answer1, 'پاسخ ها نمیتوانند یکسان باشند.');
        setInvalid(answer2, 'پاسخ ها نمیتوانند یکسان باشند.');
        setInvalid(answer3, 'پاسخ ها نمیتوانند یکسان باشند.');
        return false;
    }
    setValid(answer1);
    setValid(answer2);
    setValid(answer3);
    return true;
}

function validateYearOfBirth() {
    var yearOfBirth = document.getElementById('YearOfBirth');
    removeValidationEffects(yearOfBirth)
    if (yearOfBirth.value == null || yearOfBirth.value.trim() == '') {
        setInvalid(yearOfBirth, 'وارد نمودن سال تولد اجباری است');
        return false;
    }

    if (isNaN(yearOfBirth.value)) {
        setInvalid(yearOfBirth, 'سال تولد می بایست عدد باشد');
        return false;
    }

    if (yearOfBirth.value <= 1250 || yearOfBirth.value >= 2000) {
        setInvalid(yearOfBirth, 'سال تولد می بایست عددی بین ۱۲۵۰ تا ۲۰۰۰ باشد');
        return false;
    }

    setValid(yearOfBirth);
    return true;
}

function validateDayOfBirth() {
//    setInvalid(dayOfBirth, 'روز وارد شده معتبر نمیباشد.');
//            return false;
    var monthOfBirth = document.getElementById('MonthOfBirth');
    var dayOfBirth = document.getElementById('DayOfBirth');
    removeValidationEffects(dayOfBirth)
    if (dayOfBirth.value == null || dayOfBirth.value.trim() == '') {
        setInvalid(dayOfBirth, 'وارد نمودن روز تولد اجباری است');
        return false;
    }

    if (monthOfBirth == "07" || monthOfBirth == '08' || monthOfBirth == '09' || monthOfBirth == '10' || monthOfBirth == '11' || monthOfBirth == '12') {
//        if (dayOfBirth == '31') {
        setInvalid(dayOfBirth, 'روز وارد شده معتبر نمیباشد.');
        return false;
//        }
    }
    setValid(dayOfBirth);
    return true;
}

function validateQuestion1() {
    var question1 = document.getElementById('question1');
    removeValidationEffects(question1)
    if (question1.value == null || question1.value.trim() == '') {
        setInvalid(question1, 'وارد نمودن سوال ۱ اجباری است');
        return false;
    }
    setValid(question1);
    return true;
}

function validateQuestion2() {
    var question2 = document.getElementById('question2');
    removeValidationEffects(question2)
    if (question2.value == null || question2.value.trim() == '') {
        setInvalid(question2, 'وارد نمودن سوال ۲ اجباری است');
        return false;
    }
    setValid(question2);
    return true;
}

function validateQuestion3() {
    var question3 = document.getElementById('question3');
    removeValidationEffects(question3)
    if (question3.value == null || question3.value.trim() == '') {
        setInvalid(question3, 'وارد نمودن سوال ۳ اجباری است');
        return false;
    }
    setValid(question3);
    return true;
}

function validateAnswer1() {
    var answer1 = document.getElementById('answer1');
    removeValidationEffects(answer1)
    if (answer1.value == null || answer1.value.trim() == '') {
        setInvalid(answer1, 'وارد نمودن جواب ۱ اجباری است');
        return false;
    }
    setValid(answer1);
    return true;
}

function validateAnswer2() {
    var answer2 = document.getElementById('answer2');
    removeValidationEffects(answer2)
    if (answer2.value == null || answer2.value.trim() == '') {
        setInvalid(answer2, 'وارد نمودن جواب ۲ اجباری است');
        return false;
    }
    setValid(answer2);
    return true;
}

function validateAnswer3() {
    var answer3 = document.getElementById('answer3');
    removeValidationEffects(answer3)
    if (answer3.value == null || answer3.value.trim() == '') {
        setInvalid(answer3, 'وارد نمودن جواب ۳ اجباری است');
        return false;
    }
    setValid(answer3);
    return true;
}

function passwordComplexityLength(password) {

    if (password.length < 8)
        return false;

}

function passwordComplexityStartChar(password) {

    var hasStartCharAlphabetic = /^[A-Za-z].*$/.test(password);
    return hasStartCharAlphabetic === true;

}

function passwordComplexityUpperCase(password) {

    var hasUpperCase = /[A-Z]/.test(password);
    return hasUpperCase === true;

}

function passwordComplexityLowerCase(password) {

    var hasLowerCase = /[a-z]/.test(password);
    return hasLowerCase === true;

}

function passwordComplexityDigit(password) {

    var hasNumbers = /\d/.test(password);
    return hasNumbers === true;

}

function passwordComplexityValidChar(password) {

    var hasNumbers = /^(")?(?:[^\."])(?:(?:[\.])?(?:[\w\-!#$%&'*+\/=?\^_`{|}~]))*$/.test(password);
    return hasNumbers === true;

}

function passwordComplexityNotContainsSomeFields(password, firstName, lastName, nationalCode) {

//    var nationalCode = document.getElementById('nationalCode').value;
//    var firstName = document.getElementById('firstName').value;
//    var lastName = document.getElementById('lastName').value;
//    
//    if (nationalCode === null || nationalCode === ''){
//        return false;
//    }
//    if (hasLastName === null || hasLastName === ''){
//        return false;
//    }
//    if (hasFistNaame === null || hasFistNaame === ''){
//        return false;
//    }

//    var hasNatCode = password.indexOf(nationalCode) !== -1;
//    console.log('hasNatCode');
//    console.log(password.indexOf(nationalCode));
//    console.log(hasNatCode);
//    var hasFistNaame = password.indexOf(firstName) !== -1;
//    console.log('hasFistNaame');
//    console.log(password.indexOf(firstName));
//    console.log(hasFistNaame);
//    var hasLastName = password.indexOf(lastName) !== -1;
//    console.log('hasLastName');
//    console.log(password.indexOf(lastName));
//    console.log(hasLastName);
//    console.log('jam');
//    console.log(hasFistNaame + hasLastName + hasNatCode);
//    console.log('kol');
//    console.log(hasFistNaame + hasLastName + hasNatCode !== 0);
//    return hasFistNaame + hasLastName + hasNatCode !== 0;
    var hasNatCode = password.indexOf(nationalCode);
    if (hasNatCode !== -1)
        return true;
    var hasFistNaame = password.indexOf(firstName);
    if (hasFistNaame !== -1)
        return true;
    var hasLastName = password.indexOf(lastName);
    if (hasLastName !== -1)
        return true;
    return false;
}

function passwordComplexity(password) {

    if (password.length < 8)
        return false;

    var hasUpperCase = /[A-Z]/.test(password);
    var hasLowerCase = /[a-z]/.test(password);
    var hasNumbers = /\d/.test(password);
    return hasUpperCase + hasLowerCase + hasNumbers === 3;

}

function setInvalid(elem, msg) {
    elem.parentNode.setAttribute('data-hint', msg);
    addClass(elem.parentNode, 'hint--left hint--error');
    addClass(elem, 'invalid');
}
function setValid(elem) {
    addClass(elem, 'valid');
}
function removeValidationEffects(elem) {
    removeClass(elem, 'valid');
    removeClass(elem, 'invalid');
    removeClass(elem.parentNode, 'hint--left hint--error');
    elem.parentNode.removeAttribute('data-hint');
}
function myMethod(elem) {
    var country = document.getElementById('country');
    var fetchCity = document.getElementById('fetchCity');
    fetchCity.value = "true";
    setInvalid(country, country.value);
    var theForm = document.forms[0];
    theForm.submit();
}
function showResponse(originalRequest)
{
    setInvalid(country, 'finito');
//    var list = $('city');
//    var xmlString = originalRequest.responseXML;
//    var items = xmlString.getElementsByTagName('labelValueBean');
//    clearList(list);
//    if (items.length > 0)
//    {
//        for (var i = 0; i < items.length; i++)
//        {
//            var node = items[i];
//            var value = "";
//            var label = "";
//            if (node.getElementsByTagName("label")[0].firstChild.nodeValue) {
//                value = node.getElementsByTagName("label")[0].firstChild.nodeValue;
//                label = node.getElementsByTagName("value")[0].firstChild.nodeValue;
//            }
//            addElementToList(list, value, label);
//        }
//    }
//    else
//    {
//        addElementToList(list, "", "-- Select is Empty --");
//    }
}









* android 
./sdkmanager --proxy=http  --no_https --proxy_host=127.0.0.1 --proxy_port=8118 "ndk-bundle"
https://developer.android.com/studio/command-line/sdkmanager.html
https://developer.android.com/ndk/downloads/index.html


.side-menu {
    width: 200px !important;
}

.topbar .topbar-left {
    width: 200px !important;
}

.navbar-custom {
    margin-right: 200px !important;
}

* download 
https://www.qt.io/download-open-source/#section-2
http://radius-manager.soft112.com/
http://wifismartzone.com/files/rm_related/

* setting android development environmet
https://gist.github.com/venkateshshukla/9736261

* radius
http://radmandemo.dmasoftlab.com/
http://www.proradiusmanager.com/


