* Tasks
** german anthem
Einigkeit und Recht und Freiheit
Für das deutsche Vaterland!
Danach lasst uns alle streben
Brüderlich mit Herz und Hand!
Einigkeit und Recht und Freiheit
Sind des Glückes Unterpfand;
 |: Blüh' im Glanze dieses Glückes,
  Blühe, deutsches Vaterland! :|
Unity, justice and liberty
For our German fatherland!
For all these let us work and strive
United in hearts and hands!
Unity, justice and liberty
Are the pledges of our land;
 |: Flourish in fortune's blessings,
  Flourish, German fatherland! :|

** Linux Standard Base
Probably the single most relevant standard for a Linux distribution maintainer is the
Linux Standard Base (LSB). The goal of the LSB is to establish a set of standards
designed to enhance the interoperability of applications among different Linux distributions.
** Linux Standard Base Project
http://www.linuxfoundation.org/collaborate/workgroups/lsb
Linux Foundation
http://www.linuxfoundation.org/
** TODO learn some more
  
   [[file:~/Documents/notes/emacs-notes.org::*org-capture][org-capture]]
[[file:~/Documents/notes/problem-solving.org::*Backtracking][Backtracking]]
** TODO update for groups
  
   [[file:~/Documents/notes/ubuntu.org::*Repair%20grub][Repair grub]]
** TODO log to db when shahkar is disconnected
** TODO aaaa
  
   [[file:~/.emacs.d/init.el::'(("t"%20"Todo"%20entry%20(file+headline%20"todo.org"%20"Tasks")]]
** TODO asdfd
  
   [[file:~/.emacs.d/init.el::(setq%20org-default-notes-file%20(concat%20org-directory%20"todo.org"))]]
* Embedded
* memory space
High-performance microprocessors contain complex hardware engines called
Memory Management Units (MMUs). Their purpose is to enable an operating system
to exercise a high degree of management and control over its address space and the
address space it allocates to processes. This control comes in two primary forms: access
rights and memory translation. Access rights allow an operating system to assign specific
memory-access privileges to specific tasks. Memory translation allows an operating
system to virtualize its address space, which has many benefits.
 The Linux kernel takes advantage of these hardware MMUs to create a virtual
memory operating system
* Execution Contexts
 In Linux, we refer to two distinctly separate operational contexts, based on the
environment in which a given thread15 is executing. Threads executing entirely within
the kernel are said to be operating in kernel context. Application programs are said to
operate in user space context. A user space process can access only memory it owns, and
it is required to use kernel system calls to access privileged resources such as file and
device I/O. 
 When an application program executes a system call that
results in a context switch and enters the kernel, it is executing kernel code on behalf
of a process. You will often hear this referred to as process context within the kernel. In
contrast, the interrupt service routine (ISR) handling the IDE drive (or any other ISR,
for that matter) is kernel code that is not executing on behalf of any particular process.
This is typically called interrupt context.
* Processors
* Stand-Alone Processors
Stand-alone processors are processor chips that are dedicated exclusively to the
processing function. As opposed to integrated processors, stand-alone processors
require additional support circuitry for their basic operation. In many cases, this
means a chipset or custom logic surrounding the processor to handle functions such
as DRAM controller, system bus addressing configuration, and external peripheral
devices such as keyboard controllers and serial ports. Stand-alone processors often
offer the highest overall CPU performance.

** Companion Chipsets
Stand-alone processors require support logic to connect to and enable
external peripheral devices such as main system memory (DRAM), ROM or
Flash memory, system buses such as PCI, and other peripherals.  This
support logic often is accomplished by companion chipsets, which may
even be purpose-designed specifically for a family of processors.

*** northbridge , southbridge
northbridge is directly connected to the  processor's high-speed front-side bus (FSB).

* Ich kann alless lyrics
[Verse 1]
Ich nehm' mein Ego, quetsch' es aus
Alle Tränen müssen raus
Betrunken von mir selbst, füll' leere Gläser wieder auf
Leere Gläser wieder aus
Selbst der Wasserwerfer kann mir nichts
Strahle so hell, dass alles regenbogenfarben ist
Wo die Nacht pulsiert, wo jeder was erwartet
Mich niemand wirklich kennt, wirklich niemand auf mich wartet

[Pre-Hook]
Weiß niemand, wo mein Herz schlägt?
Weiß niemand, wo mein Herz schlägt?
Und die Vögel, sie zwitschern immer noch das alte Lied
Ein zahmer singt von Freiheit, ein wilder Vogel fliegt
Und jeder Spruch klingt so wie tausende zuvor
Nicht mehr wert als nur ein Rauschen im Ohr

[Hook]
Mir egal, ich kann alles
Ich kann alles
Ich kann alles
Alles glänzt, was ab jetzt vor mir liegt
Ich kann alles
Ich kann alles
Ich kann alles
Bis ich aufschlag' beweis' ich, dass ich flieg'

[Verse 2]
Ich hab mir alles geglaubt, mir meine Lügen auch
Und dass die Lügen Lügen waren, glaub' ich mir jetzt auch
Wissen ersetzt denken nicht, weiß ich nicht, denke ich
Ich hab mich an mir verblendet, schrieb Geschichte nur in Blindenschrift
Wollte nicht so sein wie sie, wusste, was ich werden muss
Andere Leute werden groß, ich mach' mit dem werden Schluss
Und wenn mich jemand hasst, hab ich immer noch irgendwas
Das der jemand gerne hätte - alles richtig gemacht

[Pre-Hook]
Ich weiß wieder wo mein Herz schlägt
Ich weiß wieder wo mein Herz schlägt
Und die Vögel, sie zwitschern immer noch das alte Lied
Ein zahmer singt von Freiheit, ein wilder Vogel fliegt
Und jeder Spruch klingt so wie tausende zuvor
Nicht mehr wert als nur ein Rauschen im Ohr

[Hook]
Mir egal, ich kann alles
Ich kann alles
Ich kann alles
Alles glänzt, was ab jetzt vor mir liegt
Ich kann alles
Ich kann alles
Ich kann alles
Bis ich aufschlag' beweis' ich, dass ich flieg'

[Bridge]
Schau mich an, ich kann alles
Ich kann nicht viel, nein, alles
Wie viel ich verdien'? Alles!
Mein einziges Ziel? Alles!
Schau mich an, ich kann alles
Hab' mich entschieden gegen alle
Mach' meinen Frieden mit allen
Entschieden zu fliegen, bis ich falle

[Hook] x2
Ich kann alles
Ich kann alles
Ich kann alles
Alles glänzt, was ab jetzt vor mir liegt
Ich kann alles
Ich kann alles
Ich kann alles
Bis ich aufschlag' beweis' ich, dass ich flieg'
* LFS assumes that the root file system (/) is of type ext4. To create an ext4 file system on the LFS partition, run the following:
  
mkfs -v -t ext4 /dev/<xxx>
If you are using an existing swap partition, there is no need to format it. If a new swap partition was created, it will need to be initialized with this command:

mkswap /dev/<yyy>
Replace <yyy> with the name of the swap partition.
* LFS assumes that the root file system (/) is of type ext4. To create an ext4 file system on the LFS partition, run the following:

mkfs -v -t ext4 /dev/<xxx>
If you are using an existing swap partition, there is no need to format it. If a new swap partition was created, it will need to be initialized with this command:

mkswap /dev/<yyy>
Replace <yyy> with the name of the swap partition.
* LFS assumes that the root file system (/) is of type ext4. To create an ext4 file system on the LFS partition, run the following:

mkfs -v -t ext4 /dev/<xxx>
If you are using an existing swap partition, there is no need to format it. If a new swap partition was created, it will need to be initialized with this command:

mkswap /dev/<yyy>
Replace <yyy> with the name of the swap partition.
* LFS assumes that the root file system (/) is of type ext4. To create an ext4 file system on the LFS partition, run the following:

mkfs -v -t ext4 /dev/<xxx>
If you are using an existing swap partition, there is no need to format it. If a new swap partition was created, it will need to be initialized with this command:

mkswap /dev/<yyy>
Replace <yyy> with the name of the swap partition.

============ 
LFS assumes that the root file system (/) is of type
ext4. To create an ext4 file system on the LFS partition, run the
following:

mkfs -v -t ext4 /dev/<xxx> 

If you are using an existing swap
partition, there is no need to format it. If a new swap partition was
created, it will need to be initialized with this command:

mkswap /dev/<yyy>

Replace <yyy> with the name of the swap partition.
export LFS=/mnt/lfs

Create the mount point and mount the LFS file system by running:

mkdir -pv $LFS
mount -v -t ext4 /dev/<xxx> $LFS

If using multiple partitions for LFS (e.g., one for / and another for /usr), mount them using:

mkdir -pv $LFS
mount -v -t ext4 /dev/<xxx> $LFS
mkdir -v $LFS/usr
mount -v -t ext4 /dev/<yyy> $LFS/usr

If you are using a swap partition, ensure that it is enabled using the swapon command:

/sbin/swapon -v /dev/<zzz>
Replace <zzz> with the name of the swap partition

mkdir -v $LFS/sources
Make this directory writable and sticky. “Sticky” means that even if multiple users have write permission on a directory, only the owner of a file can delete the file within a sticky directory. The following command will enable the write and sticky modes:

chmod -v a+wt $LFS/sources
An easy way to download all of the packages and patches is by using wget-list as an input to wget. For example:

wget --input-file=wget-list --continue --directory-prefix=$LFS/sources


mkdir -v $LFS/tools
ln -sv $LFS/tools /
groupadd lfs
useradd -s /bin/bash -g lfs -m -k /dev/null lfs
passwd lfs
chown -v lfs $LFS/tools
chown -v lfs $LFS/sources
su - lfs

cat > ~/.bash_profile << "EOF"
exec env -i HOME=$HOME TERM=$TERM PS1='\u:\w\$ ' /bin/bash
EOF


cat > ~/.bashrc << "EOF"
set +h
umask 022
LFS=/mnt/lfs
LC_ALL=POSIX
LFS_TGT=$(uname -m)-lfs-linux-gnu
PATH=/tools/bin:/bin:/usr/bin
export LFS LC_ALL LFS_TGT PATH
EOF

source ./.bash_profile

The Binutils documentation recommends building Binutils in a dedicated build directory:

mkdir -v build
cd       build

../configure --prefix=/tools            \
             --with-sysroot=$LFS        \
             --with-lib-path=/tools/lib \
             --target=$LFS_TGT          \
             --disable-nls              \
             --disable-werror

If building on x86_64, create a symlink to ensure the sanity of the toolchain:

case $(uname -m) in
  x86_64) mkdir -v /tools/lib && ln -sv lib /tools/lib64 ;;
esac
Install the package:

make install
* this is a new todo?
  what is your name
route add -net 172.16.11.0/24 172.16.12.141
** 
howManyBees = function(hive) {
  var res = 0;
  for(var k in hive){
    var row = hive[k];
    var rev = row.split('').reverse().join('');
    res += (row.match(/bee/g) || []).length;
    res += (rev.match(/bee/g) || []).length;
  }
  var cols = [];
  for(var i = 0; i < hive.length; ++i){
    var col='';
    for(var j = 0; j< hive.length; ++j){
      col += hive[i][j];
    }
    cols.push(col);
  }
  
  for(var k in cols){
    var row = cols[k];
    var rev = row.split('').reverse().join('');
    res += (row.match(/bee/g) || []).length;
    res += (rev.match(/bee/g) || []).length;
  }
  
  return res;
}
* PPP over SSH with linux
PPP over SSH with linux

What?

PPP is an IP point-to-point link protocol that operates over terminals. Usually the terminal is a modem, but any tty will do. SSH creates secure ttys. SSH also has the advantage that it uses a single client->server TCP connection, and thereby NATs cleanly. These properties make it pass easily through firewalls and NAT routers. PPP over SSH is a poor man's VPN.

Why?

Because it can be done. And because sometimes it's quickest way to get the job done. One place it is useful is securing wireless connections. ppp over ssh over 802.11.

How?

PPP over SSH needs to be resilient. The SSH connection needs to connect and reconnect on its own when the connection is lost. To achieve this use SSH's public key authentication method and manually add the key to ssh-agent on the client side before connecting. Then configure ppp to "dial" using ssh, and to redial when the connection is lost. With this configuration SSH will reconnect as long as the client machine does not loose power. This is good enough in most cases; a UPS will make it even more reliable.

SSH will need a login and a public key. For safety this should be a new login on the server, and normal login should be disabled (A '*' in place of the password in /etc/shadow). If the client will be connecting from a static address, use of the public key should be restricted to that address. And that key does not need X11 forwarding, nor ssh agent forwarding. These also should be disabled for that key.

Because the PPP is tunneled over SSH you could use plaintext PPP passwords, but since CHAP is just as easy, do it.

Lastly if the client is in fact a router, IP routes should be setup at either end to point throught the tunnel. These can be hand configured in /etc/network/interfaces or with "/sbin/ip route add ..." commands in ppp-up. But running a routing daemon at both ends of the ppp link works much better. OSPF works well for this.

HOWTO

First configure ssh. Create a new user for SSH to login to.

root@server # adduser --disabled-password ppp-link
Create an ssh key pair on the client.

user@client > ssh-keygen -t rsa -f $HOME/.ssh/ppp_rsa
Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/user/.ssh/ppp_rsa.
Your public key has been saved in /home/user/.ssh/ppp_rsa.pub.
The key fingerprint is:
04:32:f5:c5:0f:94:4b:46:37:d4:00:ab:45:4d:66:ae user@client

Copy the public key (ppp_rsa.pub) to ~ppp-link/.ssh/authorized_keys on the
server. Then add options to the line in authorized_keys to restrict how it can
be used. For example:

ppp-link@server > cat $HOME/.ssh/authorized_keys
from="192.168.168.*",no-port-forwarding,no-X11-forwarding,no-agent-forwarding ssh-rsa AAAB...5+TCM= user@client

removes all the capabilities that aren't needed (port & X11 and ssh-agent
forwarding), and restricts the source IP so that the client must connect from
the 192.168.168.0/24 IP subnet. Restricting the client's IP address is a good
thing, especially if this is a public ssh server. See the AUTHORIZED_KEYS FILE
FORMAT section of the sshd manpage for more ways 'from' can be configured.

At this point ssh should be working. Test it:

user@client > ssh -l ppp-link -i $HOME/.ssh/ppp_rsa server
Enter passphrase for key '/home/user/.ssh/ppp_rsa':
ppp-link@server > exit
logout
Connection to server closed.

Then configure ppp. 

First add secrets for the chap authentication and IP addresses for the endpoints
of the ppp link. You can use a different secret in each direction. This way the
ppp client can authenticate the ppp server. In this example the client machine
has been called "client" and the server "server". They should be replaced with
the actual hostnames (or whatever PPP is configured to use for names).

root@server # echo >>/etc/ppp/chap-secrets <<EOF
client          server  secret1          10.1.1.1
server          client  secret2          10.1.1.2
EOF
Add the same secrets to the chap-secrets file on the client.

root@client # echo >>/etc/ppp/chap-secrets <<EOF
client          server  secret1          10.1.1.1
server          client  secret2          10.1.1.2
EOF
And lastly create a ppp peer configuration file on the client. The name of the file will be the name ppp will be told to call.

root@client # echo >>/etc/ppp/peers/server <<EOF

# use a seperate log file
logfile /var/log/ppp/server.log

# names to use in secret lookup
name client
remotename server

# other side must authenticate to us
auth

# don't allow pap out of paranoia (actually in case we mess up and don't use ssh)
require-chap

# don't accept the default route from the other end. This is useful if we are using
# ppp-over-ssh to reach only certain hosts, since it prevents us from sending everything
# through the ppp link. But if everything should go through the link then "nodefaultroute"
# should be commented out, and the "defaultroute" and "replacedefaultroute" lines uncommented.
nodefaultroute
#defaultroute
#replacedefaultroute

# to switch DNS servers to what server specifies, uncomment "usepeerdns"
# depending on your distribution, you might also have to copy /etc/ppp/resolv.conf 
# to /etc/resolv.conf as part of ppp-up
#usepeerdns

# the magic line: "dial" with ssh. blowfish is faster than 3DES.
pty "/usr/bin/ssh -e none -c blowfish -t -l ppp-link server /usr/sbin/pppd passive"

# give ssh+remote pppd up to 30 seconds to start ppp'ing
connect-delay 30000

# make sure we fit in a single ethernet packet after ssh-encryption/tcp/ip headers
mtu 1200
mru 1200

# after we connect, detach from shell and run in background
updetach

# reconnect if we get disconnected
persist
holdoff 60

# keep trying to connect forever
maxfail 0

EOF
On debian users must be part of the dip group so they can execute pppd

root@client # usermod -G dip user
root@server # usermod -G dip ppp-link
And the log directory needs to be created if it doesn't already exist

root@client # mkdir /var/log/ppp

Now everything is ready. Starting up an ssh-agent (note well: back-ticks, not
single-quotes), and adding the public key to ssh-agent keeps ssh from prompting
for a passphrase each time ppp (re)connects.

user@client > eval `ssh-agent`
Agent pid 12345
user@client > ssh-add $HOME/.ssh/ppp_rsa
Enter passphrase for /home/user/.ssh/ppp_rsa:
Identity added: /home/user/.ssh/ppp_rsa (/home/user/.ssh/ppp_rsa)
user@client > pppd call server
Check that the connection took place and is working as it should

user@client > tail /var/log/ppp/server.log
Using interface ppp0
Connect: ppp0 <--> /dev/pts/10
CHAP peer authentication succeeded for server
Remote message: Welcome to server.
Deflate (15) compression enabled
local  IP address 10.1.1.1
remote IP address 10.1.1.2
user@client > /sbin/ip addr
1: lo:  mtu 16436 qdisc noqueue
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    127.0.0.1/8 brd 127.255.255.255 scope host lo
2: eth0:  mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:01:02:b1:12:5b brd ff:ff:ff:ff:ff:ff
    inet 192.168.168.2/24 brd 192.168.168.255 scope global eth0
3: ppp0:  mtu 1200 qdisc pfifo_fast qlen 3
    link/ppp
    inet 10.1.1.1 peer 10.1.1.2/32 scope global ppp0
user@client > ping -c3 10.1.1.2
PING 10.10.10.2 (10.1.1.2) from 10.1.1.1 : 56(84) bytes of data.
64 bytes from 10.1.1.2: icmp_seq=1 ttl=255 time=50.7 ms
64 bytes from 10.1.1.2: icmp_seq=2 ttl=255 time=26.7 ms
64 bytes from 10.1.1.2: icmp_seq=3 ttl=255 time=29.2 ms

--- 10.1.1.2 ping statistics ---
3 packets transmitted, 3 received, 0% loss, time 2023ms
rtt min/avg/max/mdev = 26.795/35.617/50.768/10.762 ms
Looks good!

tunneling the default route

If the ppp-over-ssh link is being used to create a link to the internet (for
example when securing a wireless link) then the default route must point through
the tunnel. Two things must be true for this to happen: 'nodefaultroute' must be
changed to 'defaultroute' in the ppp peer's configuration, and if there exists a
default route before ppp connects then 'replacedefaultroute' must also be in the
peer's configuration. Without this pppd will not replace the existing default
route. Instead it will log a message to that effect: "not replacing default
route to eth0 [192.168.168.1]". As an added niceity, ppp will restore the
default route when the ppp link is torn down.

In the case of a wireless connection, client usually gets its IP address and
route table from the DHCP server in the wireless router. That DHCP server cannot
be configured not to advertise itself as the default gateway. So both
'defaultroute' and 'replacedefaultroute' are needed.

The DNS server address(es) might also have to be altered if the router also
advertised itself as the DNS server. Again the cleanest way to do this is to
pass the DNS address(es) to client as part of the ppp connection parameters.
'usepeerdns' on the client's peer configuration, and 'ms-dns' in the server's
options configuration file /etc/ppp/options.

OSPF

If other computers need to use client's ppp link, client will be acting as a
router. In this case it is most dynamic to run a routing daemon on client and
server and have then exchange routes over the ppp link. I prefer OSPF for this
since it doesn't send much traffic when no routes change. OSPF can also
advertise a default route, which removes the need to add it manually. Here is a
typical configurations for zebra's ospfd

root@server # cat /etc/zebra/ospfd.conf
hostname server

# ospf on the local LAN
interface eth0
 ip ospf authentication message-digest
 ip ospf message-digest-key 1 md5 secret_phrase_for_lan
exit

# ospf through the ppp tunnel
interface ppp0
 ip ospf network point-to-point
 # binding of key to ppp0 gets lost after ppp0 goes and comes back, so don't use auth
 #ip ospf authentication message-digest
 #ip ospf message-digest-key 1 md5 secret_phrase_for_ppp
exit

router ospf
 ospf router-id 192.168.168.1
 redistribute connected
 #redistribute static
 network 192.168.168.0/24 area 0
 network 10.1.1.1/32 area 0
exit

log file /var/log/zebra/ospfd.log

Unfortunately zebra's ospf looses the md5 key -> ppp0 binding if ppp0 goes down,
so it is not possible to use authentication with ospf on the ppp link. And
unfortunately zebra's ospf needs the name of the ppp link device. If there is
only one tunnel at any time then it is ppp0. If there are multiple tunnels then
ospfd must be reconfigured dynamically as part of the ppp-up process by passing
the appropriate commands to vtysh.

http://nsd.dyndns.org/pppossh/
* hajimi
https://security.rapiditynetworks.com/publications/2016-10-16/hajime.pdf
https://github.com/beekalam/Mirai-Source-Code
** 
https://routerboard.com/rb750g
https://routerboard.com/rb433ah
https://routerboard.com/rb450g

https://www.itbazar.com/all2_P_S_4734321.aspx
** 
۱۳۹۶/۰۲/۰۳
۱۳۹۵/۱۲/۲۶

* writing maintainable software
** Write Short Units of Code
*** intro
Units are the smallest groups of code that can be maintained and executed independ‐
ently. In Java, units are methods or constructors. A unit is always executed as a whole.
It is not possible to invoke just a few lines of a unit. Therefore, the smallest piece of
code that can be reused and tested is a unit.

 - Short Units Are Easy to Test
 - Short Units Are Easy to Analyze
 - Short Units Are Easy to Reuse
*** how to apply
 - Refactoring technique: Extract Method
 - Refactoring technique: Replace Method with Method Object
 - Limit the length of code units to 15 lines of code.
** Write Simple Units of Code
*** intro
 - Limit the number of branch points per unit to 4.
 - Do this by splitting complex units into simpler ones and avoiding complex units altogether.
 - This improves maintainability because keeping the number of branch points low makes units easier to modify and test.
*** How to apply
**** Dealing with Conditional Chains
   - use a Map data structure
   - Replace Conditional with Polymorphism pattern 

* timer1
  https://github.com/samyk/evercookie/
* css

http://kushagragour.in/lab/hint/
https://purecss.io/tools/
https://me.tamin.ir/js/register.js
https://me.tamin.ir/service/secure/registration

* javascript

  
var complexityText = 'پیچیدگی گذرواژه کافی نیست';
var complexityTextUpperCase = 'گذرواژه باید حداقل شامل یک کاراکتر بزرگ باشد';
var complexityTextLowerCase = 'گذرواژه باید حداقل شامل یک کاراکتر کوچک باشد';
var complexityTextDigit = 'گذرواژه باید شامل عدد باشد';
var complexityTextStartCharAlphabet = 'گذرواژه باید با یک حرف آغاز شود';
var complexityTextLength = 'گذرواژه حداقل باید هشت حرف باشد';
var complexityTextNotContainsSomeFields = 'گذرواژه باید با حروف لاتین بوده و شامل نام، نام خانوادگی و شماره ملی یا کد اتباع خارجی نباشد.';
var complexityTextFirstName = 'پیش از ورود نام امکان ارزیابی گذرواژه وجود ندارد';
var complexityTextlastName = 'پیش از ورود نام خانوادگی امکان ارزیابی گذرواژه وجود ندارد';
var complexityTextNationalCode = 'پیش از ورود کدملی یا شماره اتباع خارجی امکان ارزیابی گذرواژه وجود ندارد';
var complexityTextValidChar = 'فقط از کاراکترهای لاتین مجاز استفاده نمایید. شامل حروف، اعداد و !#$%&* ';

function hasClass(ele, cls) {
    return ele.className.match(new RegExp('(\\s|^)' + cls + '(\\s|$)'));
}

function addClass(ele, cls) {
    if (!this.hasClass(ele, cls))
        ele.className += " " + cls;
}
function removeClass(ele, cls) {
    if (hasClass(ele, cls)) {
        var reg = new RegExp('(\\s|^)' + cls + '(\\s|$)');
        ele.className = ele.className.replace(reg, ' ');
    }
}

function deleteButtonClick() {
    var queueNumber = document.getElementById('queueNumber');
    var nationalCode = document.getElementById('nationalCode');
    window.location.href = 'service/secure/delete-request?nationalCode=' + nationalCode.value + '&queueNumber=' + queueNumber.value;
}

function validateForm() {
    var result = true;
    result = result &
            validateLastName() &
            validateFirstName() &
            validateNationalCode() &
            validateEmail() &
            validatePassword() &
            validateRepeatedPassword() &
            validatePasswordsEquality() &
            validateMobile() &
            validateQuestion1() &
            validateQuestion2() &
            validateQuestion3() &
            validateQuestionEquality() &
//            validateSerialNo() &
//            validateSerialDigit() &
//            validateSerialAlphabet() &
            validateIdNo() &
            validateAnswer1() &
            validateAnswer2() &
            validateAnswer3() &
            validateAnswerEquality() &
//            validateDayOfBirth() &
            validateYearOfBirth();

    console.log(result != 0);
    return result != 0;
}

function validateMobile() {
    var mobile = document.getElementById('mobile');
    removeValidationEffects(mobile)
    if (mobile.value == null || mobile.value.trim() == '') {
        setInvalid(mobile, 'وارد نمودن شماره موبایل اجباری است');
        return false;
    }

    var re = /^[0-9]*$/;
    if (!re.test(mobile.value)) {
        setInvalid(mobile, 'شماره موبایل باید با کاراکترهای لاتین، بدون حرف و سایر کاراکترها وارد شود.');
        return false;
    }

    if (isNaN(mobile.value)) {
        setInvalid(mobile, 'شماره موبایل باید عدد باشد');
        return false;
    }

    if (mobile.value.length < 11) {
        setInvalid(mobile, 'شماره موبایل نادرست است');
        return false;
    }

    var reg = /^[0][9].*$/;
    if (!reg.test(mobile.value)) {
        setInvalid(mobile, 'شماره موبایل باید با عدد 09 شروع شود.');
        return false;
    }


    setValid(mobile);
    return true;
}

//function validateMobile() {
//    var mobile = document.getElementById('mobile');
//    removeValidationEffects(mobile)
//    if (mobile.value == null || mobile.value.trim() == '') {
//        setInvalid(mobile, 'وارد نمودن شماره موبایل اجباری است');
//        return false;
//    }
//
//    var re = /^[0-9]*$/;
//    if (!re.test(mobile.value)) {
//        setInvalid(mobile, 'شماره موبایل باید با کاراکترهای لاتین، بدون حرف و سایر کاراکترها وارد شود.');
//        return false;
//    }
//
//    if (isNaN(mobile.value)) {
//        setInvalid(mobile, 'شماره موبایل باید عدد باشد');
//        return false;
//    }
//
//
//    setValid(mobile);
//    return true;
//}

function validateSerialNo() {
    var serialNo = document.getElementById('serialNo');
    removeValidationEffects(serialNo)
    if (serialNo.value == null || serialNo.value.trim() == '') {
        setInvalid(serialNo, 'وارد نمودن شماره سریال اجباری است');
        return false;
    }

    var re = /^[0-9]*$/;
    if (!re.test(serialNo.value)) {
        setInvalid(serialNo, 'شماره سریال باید با کاراکترهای لاتین، بدون حرف و سایر کاراکترها وارد شود.');
        return false;
    }

    if (isNaN(serialNo.value)) {
        setInvalid(serialNo, 'شماره سریال باید عدد باشد');
        return false;
    }

    setValid(serialNo);
    return true;
}

function validateSerialDigit() {
    var serialDigit = document.getElementById('serialDigit');
    removeValidationEffects(serialDigit)
    if (serialDigit.value == null || serialDigit.value.trim() == '') {
//        setInvalid(serialDigit, 'وارد نمودن شماره سری اجباری است');
//        return false;
        return true;
    }

    var re = /^[0-9]*$/;
    if (!re.test(serialDigit.value)) {
        setInvalid(serialDigit, 'شماره سری باید با کاراکترهای لاتین، بدون حرف و سایر کاراکترها وارد شود.');
        return false;
    }

    if (isNaN(serialDigit.value)) {
        setInvalid(serialDigit, 'شماره سری باید عدد باشد');
        return false;
    }

    setValid(serialDigit);
    return true;
}

function validateIdNo() {
    var idNo = document.getElementById('idNo');
    removeValidationEffects(idNo)
    if (idNo.value == null || idNo.value.trim() == '') {
        setInvalid(idNo, 'وارد نمودن شماره شناسنامه اجباری است');
        return false;
    }

    var re = /^[0-9]*$/;
    if (!re.test(idNo.value)) {
        setInvalid(idNo, 'شماره شناسنامه باید با کاراکترهای لاتین، بدون حرف و سایر کاراکترها وارد شود.');
        return false;
    }

    if (isNaN(idNo.value)) {
        setInvalid(idNo, 'شماره شناسنامه باید عدد باشد');
        return false;
    }
    setValid(idNo);
    return true;
}

function validateLastName() {
    var lastName = document.getElementById('lastName');
    removeValidationEffects(lastName)
    if (lastName.value == null || lastName.value.trim() == '') {
        setInvalid(lastName, 'وارد نمودن نام خانوادگی اجباری است');
        return false;
    }
    setValid(lastName);
    return true;
}
function validateFirstName() {
    var firstName = document.getElementById('firstName');
    removeValidationEffects(firstName);
    if (firstName.value == null || firstName.value.trim() == '') {
        setInvalid(firstName, 'وارد نمودن نام اجباری است');
        return false;
    }
    setValid(firstName);
    return true;
}
function validateNationalCode() {
    var nationalCode = document.getElementById('nationalCode');
    removeValidationEffects(nationalCode);
    if (nationalCode.value == null) {
        setInvalid(nationalCode, 'وارد نمودن کد ملی اجباری است');
        return false;
    }
    if (nationalCode.value.length != 10) {
        setInvalid(nationalCode, 'کد ملی نادرست است');
        return false;
    }
    var re = /^[0-9]*$/;
    if (!re.test(nationalCode.value)) {
        setInvalid(nationalCode, 'کد ملی باید با کاراکترهای لاتین، بدون حرف و سایر کاراکترها وارد شود.');
        return false;
    }

    if (isNaN(nationalCode.value)) {
        setInvalid(nationalCode, 'کد ملی می بایست عدد باشد');
        return false;
    }
    setValid(nationalCode);
    return true;
//    var nationalCode = document.getElementById('nationalCode');
//    removeValidationEffects(nationalCode);
//    if (nationalCode.value == null || nationalCode.value.trim() == '') {
//        setInvalid(nationalCode, 'وارد نمودن کد ملی/اتباع خارجی اجباری است');
//        return false;
//    }
//    if (nationalCode.value.length != 10 && nationalCode.value.length != 13) {
//        setInvalid(nationalCode, 'کد ملی/اتباع خارجی نادرست است');
//        return false;
//    }
//    setValid(nationalCode);
//    return true;
}
function validateEmail() {
    var email = document.getElementById('email');
    removeValidationEffects(email);
    if (email.value == null || email.value.trim() == '') {
        setInvalid(email, 'وارد نمودن ایمیل اجباری است');
        return false;
    }

    var re = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i;
    if (!re.test(email.value)) {
        setInvalid(email, 'آدرس ایمیل وارد شده صحیح نمی باشد');
        return false;
    }

    setValid(email);
    return true;
}

function validateSerialAlphabet() {
    var serialAlphabet = document.getElementById('serialAlphabet');
    removeValidationEffects(serialAlphabet);
    if (serialAlphabet.value == null || serialAlphabet.value.trim() == '') {
//        setInvalid(serialAlphabet, 'وارد نمودن شماره سریال اجباری است');
//        return false;
        return true;
    }

//    var re = '/^[\u0600-\u065F\u066A-\u06EF\u06FA-\u06FF]*$/';
//    if (!re.test(serialAlphabet.value)) {
//        setInvalid(serialAlphabet, 'بخش آغازین شماره سریال باید از حروف فارسی باشد.');
//        return false;
//    }

    setValid(serialAlphabet);
    return true;
}


function validatePassword() {
    var password = document.getElementById('password');
    removeValidationEffects(password);
    if (password.value == null || password.value.trim() == '') {
        setInvalid(password, 'وارد نمودن گذرواژه اجباری است');
        return false;
    }

    if (password.value.length < 8) {
        setInvalid(password, 'گذرواژه حداقل باید هشت حرف باشد');
        return false;
    }
    if (!passwordComplexityStartChar(password.value)) {
        setInvalid(password, complexityTextStartCharAlphabet);
        return false;
    }
    if (!passwordComplexityUpperCase(password.value)) {
        setInvalid(password, complexityTextUpperCase);
        return false;
    }
    if (!passwordComplexityLowerCase(password.value)) {
        setInvalid(password, complexityTextLowerCase);
        return false;
    }
    if (!passwordComplexityDigit(password.value)) {
        setInvalid(password, complexityTextDigit);
        return false;
    }
    if (!passwordComplexityValidChar(password.value)) {
        setInvalid(password, complexityTextValidChar);
        return false;
    }

    var nationalCode = document.getElementById('nationalCode');
    var firstName = document.getElementById('firstName');
    var lastName = document.getElementById('lastName');

    if (nationalCode.value === null || nationalCode.value === '') {
        setInvalid(password, complexityTextNationalCode);
        return false;
    }
    if (firstName.value === null || firstName.value === '') {
        setInvalid(password, complexityTextFirstName);
        return false;
    }
    if (lastName.value === null || lastName.value === '') {
        setInvalid(password, complexityTextlastName);
        return false;
    }

    if (passwordComplexityNotContainsSomeFields(password.value, firstName.value, lastName.value, nationalCode.value)) {
        setInvalid(password, complexityTextNotContainsSomeFields);
        return false;
    }



//    if (password.value.length < 8) {
//        setInvalid(password, 'گذرواژه حداقل باید هشت حرف باشد');
//        return false;
//    }
//
//    if (!passwordComplexity(password.value)) {
//        setInvalid(password, complexityText);
//        return false;
//    }

    setValid(password);
    return true;
}
function validateRepeatedPassword() {
    var repeatedPassword = document.getElementById('repeatedpassword');
    removeValidationEffects(repeatedPassword);
    if (repeatedPassword.value == null || repeatedPassword.value.trim() == '') {
        setInvalid(repeatedPassword, 'وارد نمودن تکرار گذرواژه اجباری است');
        return false;
    }

    if (repeatedPassword.value.length < 8) {
        setInvalid(repeatedPassword, 'گذرواژه حداقل باید هشت حرف باشد');
        return false;
    }
    if (!passwordComplexityStartChar(repeatedPassword.value)) {
        setInvalid(repeatedPassword, complexityTextStartCharAlphabet);
        return false;
    }
    if (!passwordComplexityUpperCase(repeatedPassword.value)) {
        setInvalid(repeatedPassword, complexityTextUpperCase);
        return false;
    }
    if (!passwordComplexityLowerCase(repeatedPassword.value)) {
        setInvalid(repeatedPassword, complexityTextLowerCase);
        return false;
    }
    if (!passwordComplexityDigit(repeatedPassword.value)) {
        setInvalid(repeatedPassword, complexityTextDigit);
        return false;
    }
    if (!passwordComplexityValidChar(repeatedPassword.value)) {
        setInvalid(repeatedPassword, complexityTextValidChar);
        return false;
    }

    var nationalCode = document.getElementById('nationalCode');
    var firstName = document.getElementById('firstName');
    var lastName = document.getElementById('lastName');

    if (nationalCode.value === null || nationalCode.value === '') {
        setInvalid(repeatedPassword, complexityTextNationalCode);
        return false;
    }
    if (firstName.value === null || firstName.value === '') {
        setInvalid(repeatedPassword, complexityTextFirstName);
        return false;
    }
    if (lastName.value === null || lastName.value === '') {
        setInvalid(repeatedPassword, complexityTextlastName);
        return false;
    }

    if (passwordComplexityNotContainsSomeFields(repeatedPassword.value, firstName.value, lastName.value, nationalCode.value)) {
        setInvalid(repeatedPassword, complexityTextNotContainsSomeFields);
        return false;
    }

//    if (repeatedPassword.value.length < 8) {
//        setInvalid(repeatedPassword, 'گذرواژه حداقل باید هشت حرف باشد');
//        return false;
//    }
//
//    if (!passwordComplexity(repeatedPassword.value)) {
//
//        setInvalid(repeatedPassword, complexityText);
//        return false;
//    }

    setValid(repeatedPassword);
    return true;
}

function validatePasswordsEquality() {
    var password = document.getElementById('password');
    var repeatedPassword = document.getElementById('repeatedpassword');
    if (!hasClass(password, 'valid') && !hasClass(repeatedPassword, 'valid')) {
        return false;
    }

    removeValidationEffects(password);
    removeValidationEffects(repeatedPassword);

    var v1 = repeatedPassword.value;
    var v2 = password.value;
    console.log(v1);
    console.log(v2);
    if (v1 !== v2) {
        console.log(password.value);
        console.log(repeatedPassword.value);
        setInvalid(repeatedPassword, 'گدرواژه و تکرار آن یکسان نمی باشد');
        setInvalid(password, 'گدرواژه و تکرار آن یکسان نمی باشد');
        return false;
    }
    setValid(password);
    setValid(repeatedPassword);
    return true;
}

function validateQuestionEquality() {
    var question1 = document.getElementById('question1');
    var question2 = document.getElementById('question2');
    var question3 = document.getElementById('question3');
    if (!hasClass(question1, 'valid') && !hasClass(question2, 'valid') && !hasClass(question3, 'valid')) {
        return false;
    }

    removeValidationEffects(question1);
    removeValidationEffects(question2);
    removeValidationEffects(question3);

    var v1 = question1.value.trim();
    var v2 = question2.value.trim();
    var v3 = question3.value.trim();
    if (v1 === v2 || v1 === v3 || v2 === v3) {
        setInvalid(question1, 'سوالات امنیتی نمیتوانند یکسان باشند.');
        setInvalid(question2, 'سوالات امنیتی نمیتوانند یکسان باشند.');
        setInvalid(question3, 'سوالات امنیتی نمیتوانند یکسان باشند.');
        return false;
    }
    setValid(question1);
    setValid(question2);
    setValid(question3);
    return true;
}

function validateAnswerEquality() {
    var answer1 = document.getElementById('answer1');
    var answer2 = document.getElementById('answer2');
    var answer3 = document.getElementById('answer3');
    if (!hasClass(answer1, 'valid') && !hasClass(answer2, 'valid') && !hasClass(answer3, 'valid')) {
        return false;
    }

    removeValidationEffects(answer1);
    removeValidationEffects(answer2);
    removeValidationEffects(answer3);

    var v1 = answer1.value.trim();
    var v2 = answer2.value.trim();
    var v3 = answer3.value.trim();
    if (v1 === v2 || v1 === v3 || v2 === v3) {
        setInvalid(answer1, 'پاسخ ها نمیتوانند یکسان باشند.');
        setInvalid(answer2, 'پاسخ ها نمیتوانند یکسان باشند.');
        setInvalid(answer3, 'پاسخ ها نمیتوانند یکسان باشند.');
        return false;
    }
    setValid(answer1);
    setValid(answer2);
    setValid(answer3);
    return true;
}

function validateYearOfBirth() {
    var yearOfBirth = document.getElementById('YearOfBirth');
    removeValidationEffects(yearOfBirth)
    if (yearOfBirth.value == null || yearOfBirth.value.trim() == '') {
        setInvalid(yearOfBirth, 'وارد نمودن سال تولد اجباری است');
        return false;
    }

    if (isNaN(yearOfBirth.value)) {
        setInvalid(yearOfBirth, 'سال تولد می بایست عدد باشد');
        return false;
    }

    if (yearOfBirth.value <= 1250 || yearOfBirth.value >= 2000) {
        setInvalid(yearOfBirth, 'سال تولد می بایست عددی بین ۱۲۵۰ تا ۲۰۰۰ باشد');
        return false;
    }

    setValid(yearOfBirth);
    return true;
}

function validateDayOfBirth() {
//    setInvalid(dayOfBirth, 'روز وارد شده معتبر نمیباشد.');
//            return false;
    var monthOfBirth = document.getElementById('MonthOfBirth');
    var dayOfBirth = document.getElementById('DayOfBirth');
    removeValidationEffects(dayOfBirth)
    if (dayOfBirth.value == null || dayOfBirth.value.trim() == '') {
        setInvalid(dayOfBirth, 'وارد نمودن روز تولد اجباری است');
        return false;
    }

    if (monthOfBirth == "07" || monthOfBirth == '08' || monthOfBirth == '09' || monthOfBirth == '10' || monthOfBirth == '11' || monthOfBirth == '12') {
//        if (dayOfBirth == '31') {
        setInvalid(dayOfBirth, 'روز وارد شده معتبر نمیباشد.');
        return false;
//        }
    }
    setValid(dayOfBirth);
    return true;
}

function validateQuestion1() {
    var question1 = document.getElementById('question1');
    removeValidationEffects(question1)
    if (question1.value == null || question1.value.trim() == '') {
        setInvalid(question1, 'وارد نمودن سوال ۱ اجباری است');
        return false;
    }
    setValid(question1);
    return true;
}

function validateQuestion2() {
    var question2 = document.getElementById('question2');
    removeValidationEffects(question2)
    if (question2.value == null || question2.value.trim() == '') {
        setInvalid(question2, 'وارد نمودن سوال ۲ اجباری است');
        return false;
    }
    setValid(question2);
    return true;
}

function validateQuestion3() {
    var question3 = document.getElementById('question3');
    removeValidationEffects(question3)
    if (question3.value == null || question3.value.trim() == '') {
        setInvalid(question3, 'وارد نمودن سوال ۳ اجباری است');
        return false;
    }
    setValid(question3);
    return true;
}

function validateAnswer1() {
    var answer1 = document.getElementById('answer1');
    removeValidationEffects(answer1)
    if (answer1.value == null || answer1.value.trim() == '') {
        setInvalid(answer1, 'وارد نمودن جواب ۱ اجباری است');
        return false;
    }
    setValid(answer1);
    return true;
}

function validateAnswer2() {
    var answer2 = document.getElementById('answer2');
    removeValidationEffects(answer2)
    if (answer2.value == null || answer2.value.trim() == '') {
        setInvalid(answer2, 'وارد نمودن جواب ۲ اجباری است');
        return false;
    }
    setValid(answer2);
    return true;
}

function validateAnswer3() {
    var answer3 = document.getElementById('answer3');
    removeValidationEffects(answer3)
    if (answer3.value == null || answer3.value.trim() == '') {
        setInvalid(answer3, 'وارد نمودن جواب ۳ اجباری است');
        return false;
    }
    setValid(answer3);
    return true;
}

function passwordComplexityLength(password) {

    if (password.length < 8)
        return false;

}

function passwordComplexityStartChar(password) {

    var hasStartCharAlphabetic = /^[A-Za-z].*$/.test(password);
    return hasStartCharAlphabetic === true;

}

function passwordComplexityUpperCase(password) {

    var hasUpperCase = /[A-Z]/.test(password);
    return hasUpperCase === true;

}

function passwordComplexityLowerCase(password) {

    var hasLowerCase = /[a-z]/.test(password);
    return hasLowerCase === true;

}

function passwordComplexityDigit(password) {

    var hasNumbers = /\d/.test(password);
    return hasNumbers === true;

}

function passwordComplexityValidChar(password) {

    var hasNumbers = /^(")?(?:[^\."])(?:(?:[\.])?(?:[\w\-!#$%&'*+\/=?\^_`{|}~]))*$/.test(password);
    return hasNumbers === true;

}

function passwordComplexityNotContainsSomeFields(password, firstName, lastName, nationalCode) {

//    var nationalCode = document.getElementById('nationalCode').value;
//    var firstName = document.getElementById('firstName').value;
//    var lastName = document.getElementById('lastName').value;
//    
//    if (nationalCode === null || nationalCode === ''){
//        return false;
//    }
//    if (hasLastName === null || hasLastName === ''){
//        return false;
//    }
//    if (hasFistNaame === null || hasFistNaame === ''){
//        return false;
//    }

//    var hasNatCode = password.indexOf(nationalCode) !== -1;
//    console.log('hasNatCode');
//    console.log(password.indexOf(nationalCode));
//    console.log(hasNatCode);
//    var hasFistNaame = password.indexOf(firstName) !== -1;
//    console.log('hasFistNaame');
//    console.log(password.indexOf(firstName));
//    console.log(hasFistNaame);
//    var hasLastName = password.indexOf(lastName) !== -1;
//    console.log('hasLastName');
//    console.log(password.indexOf(lastName));
//    console.log(hasLastName);
//    console.log('jam');
//    console.log(hasFistNaame + hasLastName + hasNatCode);
//    console.log('kol');
//    console.log(hasFistNaame + hasLastName + hasNatCode !== 0);
//    return hasFistNaame + hasLastName + hasNatCode !== 0;
    var hasNatCode = password.indexOf(nationalCode);
    if (hasNatCode !== -1)
        return true;
    var hasFistNaame = password.indexOf(firstName);
    if (hasFistNaame !== -1)
        return true;
    var hasLastName = password.indexOf(lastName);
    if (hasLastName !== -1)
        return true;
    return false;
}

function passwordComplexity(password) {

    if (password.length < 8)
        return false;

    var hasUpperCase = /[A-Z]/.test(password);
    var hasLowerCase = /[a-z]/.test(password);
    var hasNumbers = /\d/.test(password);
    return hasUpperCase + hasLowerCase + hasNumbers === 3;

}

function setInvalid(elem, msg) {
    elem.parentNode.setAttribute('data-hint', msg);
    addClass(elem.parentNode, 'hint--left hint--error');
    addClass(elem, 'invalid');
}
function setValid(elem) {
    addClass(elem, 'valid');
}
function removeValidationEffects(elem) {
    removeClass(elem, 'valid');
    removeClass(elem, 'invalid');
    removeClass(elem.parentNode, 'hint--left hint--error');
    elem.parentNode.removeAttribute('data-hint');
}
function myMethod(elem) {
    var country = document.getElementById('country');
    var fetchCity = document.getElementById('fetchCity');
    fetchCity.value = "true";
    setInvalid(country, country.value);
    var theForm = document.forms[0];
    theForm.submit();
}
function showResponse(originalRequest)
{
    setInvalid(country, 'finito');
//    var list = $('city');
//    var xmlString = originalRequest.responseXML;
//    var items = xmlString.getElementsByTagName('labelValueBean');
//    clearList(list);
//    if (items.length > 0)
//    {
//        for (var i = 0; i < items.length; i++)
//        {
//            var node = items[i];
//            var value = "";
//            var label = "";
//            if (node.getElementsByTagName("label")[0].firstChild.nodeValue) {
//                value = node.getElementsByTagName("label")[0].firstChild.nodeValue;
//                label = node.getElementsByTagName("value")[0].firstChild.nodeValue;
//            }
//            addElementToList(list, value, label);
//        }
//    }
//    else
//    {
//        addElementToList(list, "", "-- Select is Empty --");
//    }
}

* 
* 

* persianjs
Ext.define('Tamin.helpers.Persian', {
    requires:['Tamin.PDate'],
    statics: {
        persianToGregorian: function (pdate) {
            var ymd = pdate.split('/');
            var tmp = Tamin.PDate.PersianToGregorian(ymd[0], ymd[1], ymd[2]);
            return new Date(tmp[0],tmp[1] - 1, tmp[2]);
        },
        gregorianToPersian: function (date) {
            function setLeadingZero(str) {
                if (isNaN(str)) return str;
                if (Number(str) > 0 && Number(str) <= 9) return '0' + str;
                return str;
            }

            var year = date.getFullYear();
            var month = date.getMonth() + 1;
            var day = date.getDate();
            var tmp = Tamin.PDate.GregorianToPersian(year, month, day);
            return tmp[0] + '/' + setLeadingZero(tmp[1]) + '/' + setLeadingZero(tmp[2]);
        },
        gregorianToPersianWithTime: function (date) {
            function setLeadingZero(str) {
                if (isNaN(str)) return str;
                if (Number(str) > 0 && Number(str) <= 9) return '0' + str;
                return str;
            }

            var year = date.getFullYear();
            var month = date.getMonth() + 1;
            var day = date.getDate();
            var tmp = Tamin.PDate.GregorianToPersian(year, month, day);
            var time = setLeadingZero(date.getHours()) + ':' + setLeadingZero(date.getMinutes()) + ':' + setLeadingZero(date.getSeconds());
            return time + ' ' + tmp[0] + '/' + setLeadingZero(tmp[1]) + '/' + setLeadingZero(tmp[2]);
        },
        taminDateToGregorian: function (value) {
            
            if (value == null || value.length != 8 || isNaN(value)) return null;
            var y = value.substring(0, 4);
            var m = value.substring(4, 6);
            var d = value.substring(6, 8);
            var tmp = Tamin.PDate.PersianToGregorian(y, m, d);
            return new Date(tmp[0], tmp[1], tmp[2]);
        }

    }
});
**********************************************8
Ext.define('Tamin.PDate', {
    statics: {
        g_days_in_month: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        j_days_in_month: [31, 31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 29],

        PersianToGregorian: function (jy, jm, jd) {

            var jy = parseInt(jy) - 979,
                jm = parseInt(jm) - 1,
                jd = parseInt(jd) - 1,
                j_day_no = 365 * jy + parseInt(jy / 33) * 8 + parseInt((jy % 33 + 3) / 4),
                g_day_no,
                leap,
                gm;

            for (var i = 0; i < jm; ++i)
                j_day_no += Tamin.PDate.j_days_in_month[i];

            j_day_no += jd;

            g_day_no = j_day_no + 79,
                gy = 1600 + 400 * parseInt(g_day_no / 146097);
            /* 146097 = 365*400 + 400/4 - 400/100 + 400/400 */
            g_day_no = g_day_no % 146097;

            leap = true;
            if (g_day_no >= 36525) /* 36525 = 365*100 + 100/4 */ {
                g_day_no--;
                gy += 100 * parseInt(g_day_no / 36524);
                /* 36524 = 365*100 + 100/4 - 100/100 */
                g_day_no = g_day_no % 36524;

                if (g_day_no >= 365)
                    g_day_no++;
                else
                    leap = false;
            }

            gy += 4 * parseInt(g_day_no / 1461);
            /* 1461 = 365*4 + 4/4 */
            g_day_no %= 1461;

            if (g_day_no >= 366) {
                leap = false;

                g_day_no--;
                gy += parseInt(g_day_no / 365);
                g_day_no = g_day_no % 365;
            }

            for (var i = 0; g_day_no >= Tamin.PDate.g_days_in_month[i] + (i == 1 && leap); i++)
                g_day_no -= Tamin.PDate.g_days_in_month[i] + (i == 1 && leap);
            gm = i + 1,
                gd = g_day_no + 1;

            return [gy, gm, gd];
        },
        GregorianToPersian: function (gy, gm, gd) {
            var gy = parseInt(gy) - 1600,
                gm = parseInt(gm) - 1,
                gd = parseInt(gd) - 1,
                g_day_no = 365 * gy + parseInt((gy + 3) / 4) - parseInt((gy + 99) / 100) + parseInt((gy + 399) / 400),
                j_day_no,
                jy,
                jm;

            for (var i = 0; i < gm; ++i)
                g_day_no += Tamin.PDate.g_days_in_month[i];
            if (gm > 1 && ((gy % 4 == 0 && gy % 100 != 0) || (gy % 400 == 0)))
            /* leap and after Feb */
                ++g_day_no;
            g_day_no += gd;

            j_day_no = g_day_no - 79,
                j_np = parseInt(j_day_no / 12053);
            j_day_no %= 12053;

            jy = 979 + 33 * j_np + 4 * parseInt(j_day_no / 1461);

            j_day_no %= 1461;

            if (j_day_no >= 366) {
                jy += parseInt((j_day_no - 1) / 365);
                j_day_no = (j_day_no - 1) % 365;
            }

            for (var i = 0; i < 11 && j_day_no >= Tamin.PDate.j_days_in_month[i]; ++i) {
                j_day_no -= Tamin.PDate.j_days_in_month[i];
            }
            jm = i + 1,
                jd = j_day_no + 1;

            return [jy, jm, jd];
        },
        setFullYear: function (date, y, m, d) {
            var gd = date.getDate(),
                gm = date.getMonth(),
                gy = date.getFullYear(),
                j = Tamin.PDate.GregorianToPersian(gy, gm + 1, gd);

            if (y < 100)
                y += 1300;

            j[0] = y;
            if (m != undefined) {
                if (m > 11) {
                    j[0] += Math.floor(m / 11);
                    j[1] = (m % 11);
                } else if (m < 0) {
                    j[0] += Math.floor(m / 11);
                    j[1] = (m % 11) + 13;
                } else
                    j[1] = m + 1;

            }
            if (d != undefined)
                j[2] = d;
            var g = Tamin.PDate.PersianToGregorian(j[0], j[1], j[2]);
            return date.setFullYear(g[0], g[1] - 1, g[2]);
        },
        setMonth: function (date, m, d) {
            var gd = date.getDate(),
                gm = date.getMonth(),
                gy = date.getFullYear(),
                j = Tamin.PDate.GregorianToPersian(gy, gm + 1, gd);
            if (m > 11) {
                j[0] += Math.floor(m / 11);
                j[1] = (m % 11);

            } else if (m < 0) {
                j[0] -= Math.floor((-m) / 11);
                j[0] -= 1;
                j[1] = (m % 11) + 13;
            } else {
                j[1] = m + 1;
            }

            if (d != undefined)
                j[2] = d;

            var g = Tamin.PDate.PersianToGregorian(j[0], j[1], j[2]);
            return date.setFullYear(g[0], g[1] - 1, g[2]);
        },

        setDate: function (date, d) {
            var gd = date.getDate(),
                gm = date.getMonth(),
                gy = date.getFullYear(),
                j = Tamin.PDate.GregorianToPersian(gy, gm + 1, gd);
            j[2] = d;

            var g = Tamin.PDate.PersianToGregorian(j[0], j[1], j[2]);
            return date.setFullYear(g[0], g[1] - 1, g[2]);
        },
        getFullYear: function (date) {
            var gd = date.getDate(),
                gm = date.getMonth(),
                gy = date.getFullYear(),
                j = Tamin.PDate.GregorianToPersian(gy, gm + 1, gd);
            return j[0];
        },
        getMonth: function (date) {
            var gd = date.getDate(),
                gm = date.getMonth(),
                gy = date.getFullYear(),
                j = Tamin.PDate.GregorianToPersian(gy, gm + 1, gd);
            return j[1] - 1;
        },
        getDate: function (date) {
            var gd = date.getDate(),
                gm = date.getMonth(),
                gy = date.getFullYear(),
                j = Tamin.PDate.GregorianToPersian(gy, gm + 1, gd);
            return j[2];
        },
        getDay: function (date) {
            var day = date.getDay();
            day = (day + 1) % 7;
            return day;
        },
        /**
         * Persian UTC functions
         */

        getUTCFullYear: function (date) {
            var gd = date.getUTCDate(),
                gm = date.getUTCMonth(),
                gy = date.getUTCFullYear(),
                j = Tamin.PDate.GregorianToPersian(gy, gm + 1, gd);
            return j[0];
        },
        getUTCMonth: function (date) {
            var gd = date.getUTCDate(),
                gm = date.getUTCMonth(),
                gy = date.getUTCFullYear(),
                j = Tamin.PDate.GregorianToPersian(gy, gm + 1, gd);
            return j[1] - 1;
        },
        getUTCDate: function (date) {
            var gd = date.getUTCDate(),
                gm = date.getUTCMonth(),
                gy = date.getUTCFullYear(),
                j = Tamin.PDate.GregorianToPersian(gy, gm + 1, gd);
            return j[2];
        },
        getUTCDay: function (date) {
            var day = date.getUTCDay();
            day = (day + 1) % 7;
            return day;
        },
        /**
         * Returns the current timestamp
         * @return {Number} The current timestamp
         * @method
         */
        now: Ext.Date.now,

        /**
         * @private
         * Private for now
         */
        toString: function (date) {
            var pad = Ext.String.leftPad;

            return Tamin.PDate.getFullYear(date) + "-"
                + pad(Tamin.PDate.getMonth(date) + 1, 2, '0') + "-"
                + pad(Tamin.PDate.getDate(date), 2, '0') + "T"
                + pad(date.getHours(), 2, '0') + ":"
                + pad(date.getMinutes(), 2, '0') + ":"
                + pad(date.getSeconds(), 2, '0');
        },
        /**
         * Returns the number of milliseconds between two dates
         * @param {Date} dateA The first date
         * @param {Date} dateB (optional) The second date, defaults to now
         * @return {Number} The difference in milliseconds
         */
        getElapsed: Ext.Date.getElapsed,

        /**
         * Global flag which determines if strict date parsing should be used.
         * Strict date parsing will not roll-over invalid dates, which is the
         * default behaviour of javascript Date objects.
         * (see {@link #parse} for more information)
         * Defaults to <tt>false</tt>.
         * @static
         * @type Boolean
         */
        useStrict: Ext.Date.useStrict,

        // private
        formatCodeToRegex: function (character, currentGroup) {
            // Note: currentGroup - position in regex result array (see notes for Ext.Date.parseCodes below)
            var p = utilPDate.parseCodes[character];

            if (p) {
                p = typeof p == 'function' ? p() : p;
                utilPDate.parseCodes[character] = p; // reassign function result to prevent repeated execution
            }

            return p ? Ext.applyIf({
                c: p.c ? xf(p.c, currentGroup || "{0}") : p.c
            }, p) : {
                g: 0,
                c: null,
                s: Ext.String.escapeRegex(character) // treat unrecognised characters as literals
            };
        },
        /**
         * <p>An object hash in which each property is a date parsing function. The property name is the
         * format string which that function parses.</p>
         * <p>This object is automatically populated with date parsing functions as
         * date formats are requested for Ext standard formatting strings.</p>
         * <p>Custom parsing functions may be inserted into this object, keyed by a name which from then on
         * may be used as a format string to {@link #parse}.<p>
         * <p>Example:</p><pre><code>
         Tamin.PDate.parseFunctions['x-date-format'] = myDateParser;
         </code></pre>
         * <p>A parsing function should return a Date object, and is passed the following parameters:<div class="mdetail-params"><ul>
         * <li><code>date</code> : String<div class="sub-desc">The date string to parse.</div></li>
         * <li><code>strict</code> : Boolean<div class="sub-desc">True to validate date strings while parsing
         * (i.e. prevent javascript Date "rollover") (The default must be false).
         * Invalid date strings should return null when parsed.</div></li>
         * </ul></div></p>
         * <p>To enable Dates to also be <i>formatted</i> according to that format, a corresponding
         * formatting function must be placed into the {@link #formatFunctions} property.
         * @property parseFunctions
         * @static
         * @type Object
         */
        parseFunctions: {
            "MS": function (input, strict) {
                // note: the timezone offset is ignored since the MS Ajax server sends
                // a UTC milliseconds-since-Unix-epoch value (negative values are allowed)
                var re = new RegExp('\\/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\/'),
                    r = (input || '').match(re);
                return r ? new Date(((r[1] || '') + r[2]) * 1) : null;
            }
        },
        parseRegexes: [],

        /**
         * <p>An object hash in which each property is a date formatting function. The property name is the
         * format string which corresponds to the produced formatted date string.</p>
         * <p>This object is automatically populated with date formatting functions as
         * date formats are requested for Ext standard formatting strings.</p>
         * <p>Custom formatting functions may be inserted into this object, keyed by a name which from then on
         * may be used as a format string to {@link #format}. Example:</p><pre><code>
         Tamin.PDate.formatFunctions['x-date-format'] = myDateFormatter;
         </code></pre>
         * <p>A formatting function should return a string representation of the passed Date object, and is passed the following parameters:<div class="mdetail-params"><ul>
         * <li><code>date</code> : Date<div class="sub-desc">The Date to format.</div></li>
         * </ul></div></p>
         * <p>To enable date strings to also be <i>parsed</i> according to that format, a corresponding
         * parsing function must be placed into the {@link #parseFunctions} property.
         * @property formatFunctions
         * @static
         * @type Object
         */
        formatFunctions: {
            "MS": function () {
                // UTC milliseconds since Unix epoch (MS-AJAX serialized date format (MRSF))
                return '\\/Date(' + this.getTime() + ')\\/';
            }
        },

        y2kYear: 50,

        /**
         * Date interval constant
         * @static
         * @type String
         */
        MILLI: "ms",

        /**
         * Date interval constant
         * @static
         * @type String
         */
        SECOND: "s",

        /**
         * Date interval constant
         * @static
         * @type String
         */
        MINUTE: "mi",

        /** Date interval constant
         * @static
         * @type String
         */
        HOUR: "h",

        /**
         * Date interval constant
         * @static
         * @type String
         */
        DAY: "d",

        /**
         * Date interval constant
         * @static
         * @type String
         */
        MONTH: "mo",

        /**
         * Date interval constant
         * @static
         * @type String
         */
        YEAR: "y",

        /**
         * <p>An object hash containing default date values used during date parsing.</p>
         * <p>The following properties are available:<div class="mdetail-params"><ul>
         * <li><code>y</code> : Number<div class="sub-desc">The default year value. (defaults to undefined)</div></li>
         * <li><code>m</code> : Number<div class="sub-desc">The default 1-based month value. (defaults to undefined)</div></li>
         * <li><code>d</code> : Number<div class="sub-desc">The default day value. (defaults to undefined)</div></li>
         * <li><code>h</code> : Number<div class="sub-desc">The default hour value. (defaults to undefined)</div></li>
         * <li><code>i</code> : Number<div class="sub-desc">The default minute value. (defaults to undefined)</div></li>
         * <li><code>s</code> : Number<div class="sub-desc">The default second value. (defaults to undefined)</div></li>
         * <li><code>ms</code> : Number<div class="sub-desc">The default millisecond value. (defaults to undefined)</div></li>
         * </ul></div></p>
         * <p>Override these properties to customize the default date values used by the {@link #parse} method.</p>
         * <p><b>Note: In countries which experience Daylight Saving Time (i.e. DST), the <tt>h</tt>, <tt>i</tt>, <tt>s</tt>
         * and <tt>ms</tt> properties may coincide with the exact time in which DST takes effect.
         * It is the responsiblity of the developer to account for this.</b></p>
         * Example Usage:
         * <pre><code>
         // set default day value to the first day of the month
         Tamin.PDate.defaults.d = 1;

         // parse a February date string containing only year and month values.
         // setting the default day value to 1 prevents weird date rollover issues
         // when attempting to parse the following date string on, for example, March 31st 2009.
         Tamin.PDate.parse('2009-02', 'Y-m'); // returns a Date object representing February 1st 2009
         </code></pre>
         * @property defaults
         * @static
         * @type Object
         */
        defaults: {},

        /**
         * An array of textual day names.
         * Override these values for international dates.
         * Example:
         * <pre><code>
         Tamin.PDate.dayNames = [
         'SundayInYourLang',
         'MondayInYourLang',
         ...
         ];
         </code></pre>
         * @type Array
         * @static
         */
        dayNames: Ext.Date.dayNames,

        //<locale type="array">
        /**
         * An array of textual month names.
         * Override these values for international dates.
         * Example:
         * <pre><code>
         Tamin.PDate.monthNames = [
         'FarvardinInYourLang',
         'OrdibeheshtInYourLang',
         ...
         ];
         </code></pre>
         * @type Array
         * @static
         */
        monthNames: [
            "فروردین",
            "اردیبهشت",
            "خرداد",
            "تیر",
            "مرداد",
            "شهریور",
            "مهر",
            "آبان",
            "آذر",
            "دی",
            "بهمن",
            "اسفند"
        ],

        //</locale>
        //<locale type="array">
        /**
         * An object hash of zero-based javascript month numbers (with short month names as keys. note: keys are case-sensitive).
         * Override these values for international dates.
         * Example:
         * <pre><code>
         Tamin.PDate.monthNumbers = {
		 'ShortFarNameInYourLang':0,
		 'ShortOrdNameInYourLang':1,
		 ...
		 };
         </code></pre>
         * @type Object
         * @static
         */
        monthNumbers: {
            Far: 0,
            Farvardin: 0,
            Ord: 1,
            Ordibehesht: 1,
            Kho: 2,
            Khordad: 2,
            Tir: 3,
            Mor: 4,
            Mordad: 4,
            Sha: 5,
            Shahrivar: 5,
            Meh: 6,
            Mehr: 6,
            Aba: 7,
            Aban: 7,
            Aza: 8,
            Azar: 8,
            Dey: 9,
            Bah: 10,
            Bahman: 10,
            Esf: 11,
            Esfand: 11
        },
        //</locale>

        //<locale>
        /**
         * <p>The date format string that the {@link Ext.util.Format#dateRenderer}
         * and {@link Ext.util.Format#date} functions use.  See {@link     Tamin.PDate} for details.</p>
         * <p>This defaults to <code>m/d/Y</code>, but may be overridden in a locale file.</p>
         * @property defaultFormat
         * @static
         * @type String
         */
        defaultFormat: "Y/m/d",
        //</locale>

        /**
         * Get the short month name for the given month number.
         * Override this function for international dates.
         * @param {Number} month A zero-based javascript month number.
         * @return {String} The short month name.
         * @static
         */
        getShortMonthName: function (month) {
            return Tamin.PDate.monthNames[month].substring(0, 3);
        },
        //</locale>

        //<locale type="function">
        /**
         * Get the short day name for the given day number.
         * Override this function for international dates.
         * @param {Number} day A zero-based javascript day number.
         * @return {String} The short day name.
         * @static
         */
        //</locale>

        //<locale type="function">
        getShortDayName: function (day) {
            return Tamin.PDate.dayNames[day].substring(0, 3);
        },
        //</locale>

        //<locale type="function">
        /**
         * Get the zero-based javascript month number for the given short/full month name.
         * Override this function for international dates.
         * @param {String} name The short/full month name.
         * @return {Number} The zero-based javascript month number.
         * @static
         */
        //</locale>

        //<locale type="function">
        getMonthNumber: function (name) {
            // handle camel casing for english month names (since the keys for the     Tamin.PDate.monthNumbers hash are case sensitive)
            return Tamin.PDate.monthNumbers[name.substring(0, 1).toUpperCase() + name.substring(1, 3).toLowerCase()];
        },
        //</locale>

        /**
         * Checks if the specified format contains hour information
         * @param {String} format The format to check
         * @return {Boolean} True if the format contains hour information
         * @static
         * @method
         */
        formatContainsHourInfo: (function () {
            var stripEscapeRe = /(\\.)/g,
                hourInfoRe = /([gGhHisucUOPZ]|MS)/;
            return function (format) {
                return hourInfoRe.test(format.replace(stripEscapeRe, ''));
            };
        }()),
        /**
         * Checks if the specified format contains information about
         * anything other than the time.
         * @param {String} format The format to check
         * @return {Boolean} True if the format contains information about
         * date/day information.
         * @static
         * @method
         */
        formatContainsDateInfo: (function () {
            var stripEscapeRe = /(\\.)/g,
                dateInfoRe = /([djzmnYycU]|MS)/;

            return function (format) {
                return dateInfoRe.test(format.replace(stripEscapeRe, ''));
            };
        }()),

        /**
         * Removes all escaping for a date format string. In date formats,
         * using a '\' can be used to escape special characters.
         * @param {String} format The format to unescape
         * @return {String} The unescaped format
         * @method
         */
        unescapeFormat: (function () {
            var slashRe = /\\/gi;
            return function (format) {
                // Escape the format, since \ can be used to escape special
                // characters in a date format. For example, in a spanish
                // locale the format may be: 'd \\de F \\de Y'
                return format.replace(slashRe, '');
            }
        }()),
        /**
         * The base format-code to formatting-function hashmap used by the {@link #format} method.
         * Formatting functions are strings (or functions which return strings) which
         * will return the appropriate value when evaluated in the context of the Date object
         * from which the {@link #format} method is called.
         * Add to / override these mappings for custom date formatting.
         * Note:     Tamin.PDate.format() treats characters as literals if an appropriate mapping cannot be found.
         * Example:
         * <pre><code>
         Tamin.PDate.formatCodes.x = "Ext.util.Format.leftPad(this.getDate(), 2, '0')";
         console.log(    Tamin.PDate.format(new Date(), 'X'); // returns the current day of the month
         </code></pre>
         * @type Object
         * @static
         */
        formatCodes: {
            d: "Ext.String.leftPad(    Tamin.PDate.getDate(this), 2, '0')",
            D: "    Tamin.PDate.getShortDayName(this.getDay())", // get localised short day name
            j: "    Tamin.PDate.getDate(this)",
            l: "    Tamin.PDate.dayNames[this.getDay()]",
            N: "(this.getDay() ? this.getDay() : 7)",
            S: "    Tamin.PDate.getSuffix(this)",
            w: "this.getDay()",
            z: "    Tamin.PDate.getDayOfYear(this)",
            W: "Ext.String.leftPad(    Tamin.PDate.getWeekOfYear(this), 2, '0')",
            F: "    Tamin.PDate.monthNames[    Tamin.PDate.getMonth(this)]",
            m: "Ext.String.leftPad(    Tamin.PDate.getMonth(this) + 1, 2, '0')",
            M: "    Tamin.PDate.getShortMonthName(    Tamin.PDate.getMonth(this))", // get localised short month name
            n: "(    Tamin.PDate.getMonth(this) + 1)",
            t: "    Tamin.PDate.getDaysInMonth(this)",
            L: "(    Tamin.PDate.isLeapYear(this) ? 1 : 0)",
            o: "(    Tamin.PDate.getFullYear(this) + (    Tamin.PDate.getWeekOfYear(this) == 1 &&     Tamin.PDate.getMonth(this) > 0 ? +1 : (    Tamin.PDate.getWeekOfYear(this) >= 52 &&     Tamin.PDate.getMonth(this) < 11 ? -1 : 0)))",
            Y: "Ext.String.leftPad(    Tamin.PDate.getFullYear(this), 4, '0')",
            y: "('' +     Tamin.PDate.getFullYear(this)).substring(2, 4)",
            a: "(this.getHours() < 12 ? 'am' : 'pm')",
            A: "(this.getHours() < 12 ? 'AM' : 'PM')",
            g: "((this.getHours() % 12) ? this.getHours() % 12 : 12)",
            G: "this.getHours()",
            h: "Ext.String.leftPad((this.getHours() % 12) ? this.getHours() % 12 : 12, 2, '0')",
            H: "Ext.String.leftPad(this.getHours(), 2, '0')",
            i: "Ext.String.leftPad(this.getMinutes(), 2, '0')",
            s: "Ext.String.leftPad(this.getSeconds(), 2, '0')",
            u: "Ext.String.leftPad(this.getMilliseconds(), 3, '0')",
            O: "    Tamin.PDate.getGMTOffset(this)",
            P: "Ext.{Date.getGMTOffset(this, true)",
            T: "    Tamin.PDate.getTimezone(this)",
            Z: "(this.getTimezoneOffset() * -60)",

            c: function () { // ISO-8601 -- GMT format
                var c, code, i, l, e;
                for (c = "Y-m-dTH:i:sP", code = [], i = 0, l = c.length; i < l; ++i) {
                    e = c.charAt(i);
                    code.push(e == "T" ? "'T'" : utilPDate.getFormatCode(e)); // treat T as a character literal
                }
                return code.join(" + ");
            },
            /*
             c: function() { // ISO-8601 -- UTC format
             return [
             "this.getUTCFullYear()", "'-'",
             "Ext.util.Format.leftPad(this.getUTCMonth() + 1, 2, '0')", "'-'",
             "Ext.util.Format.leftPad(this.getUTCDate(), 2, '0')",
             "'T'",
             "Ext.util.Format.leftPad(this.getUTCHours(), 2, '0')", "':'",
             "Ext.util.Format.leftPad(this.getUTCMinutes(), 2, '0')", "':'",
             "Ext.util.Format.leftPad(this.getUTCSeconds(), 2, '0')",
             "'Z'"
             ].join(" + ");
             },
             */

            U: "Math.round(this.getTime() / 1000)"
        },

        /**
         * Checks if the passed Date parameters will cause a javascript Date "rollover".
         * @param {Number} year 4-digit year
         * @param {Number} month 1-based month-of-year
         * @param {Number} day Day of month
         * @param {Number} hour (optional) Hour
         * @param {Number} minute (optional) Minute
         * @param {Number} second (optional) Second
         * @param {Number} millisecond (optional) Millisecond
         * @return {Boolean} true if the passed parameters do not cause a Date "rollover", false otherwise.
         * @static
         */
        isValid: Ext.Date.isValid,

        /**
         * Parses the passed string using the specified date format.
         * Note that this function expects normal calendar dates, meaning that months are 1-based (i.e. 1 = January).
         * The {@link #defaults} hash will be used for any date value (i.e. year, month, day, hour, minute, second or millisecond)
         * which cannot be found in the passed string. If a corresponding default date value has not been specified in the {@link #defaults} hash,
         * the current date's year, month, day or DST-adjusted zero-hour time value will be used instead.
         * Keep in mind that the input date string must precisely match the specified format string
         * in order for the parse operation to be successful (failed parse operations return a null value).
         * <p>Example:</p><pre><code>
         //dt = Fri May 25 2007 (current date)
         var dt = new Date();

         //dt = Thu May 25 2006 (today&#39;s month/day in 2006)
         dt =     Tamin.PDate.parse("2006", "Y");

         //dt = Sun Jan 15 2006 (all date parts specified)
         dt =     Tamin.PDate.parse("2006-01-15", "Y-m-d");

         //dt = Sun Jan 15 2006 15:20:01
         dt =     Tamin.PDate.parse("2006-01-15 3:20:01 PM", "Y-m-d g:i:s A");

         // attempt to parse Sun Feb 29 2006 03:20:01 in strict mode
         dt =     Tamin.PDate.parse("2006-02-29 03:20:01", "Y-m-d H:i:s", true); // returns null
         </code></pre>
         * @param {String} input The raw date string.
         * @param {String} format The expected date string format.
         * @param {Boolean} strict (optional) True to validate date strings while parsing (i.e. prevents javascript Date "rollover")
         (defaults to false). Invalid date strings will return null when parsed.
         * @return {Date} The parsed Date.
         * @static
         */
        parse: function (input, format, strict) {
            var p = utilPDate.parseFunctions;
            if (p[format] == null) {
                utilPDate.createParser(format);
            }
            return p[format](input, Ext.isDefined(strict) ? strict : utilPDate.useStrict);
        },
        // Backwards compat
        parseDate: function (input, format, strict) {
            return utilPDate.parse(input, format, strict);
        },
        // private
        getFormatCode: function (character) {
            var f = utilPDate.formatCodes[character];

            if (f) {
                f = typeof f == 'function' ? f() : f;
                utilPDate.formatCodes[character] = f; // reassign function result to prevent repeated execution
            }

            // note: unknown characters are treated as literals
            return f || ("'" + Ext.String.escape(character) + "'");
        },
        // private
        createFormat: function (format) {
            var code = [],
                special = false,
                ch = '',
                i;

            for (i = 0; i < format.length; ++i) {
                ch = format.charAt(i);
                if (!special && ch == "\\") {
                    special = true;
                } else if (special) {
                    special = false;
                    code.push("'" + Ext.String.escape(ch) + "'");
                } else {
                    code.push(utilPDate.getFormatCode(ch));
                }
            }
            utilPDate.formatFunctions[format] = Ext.functionFactory("return " + code.join('+'));
        },
        // private
        createParser: (function () {
            var code = [
                "var dt, y, m, d, h, i, s, ms, o, z, zz, u, v,",
                "def =     Tamin.PDate.defaults,",
                "results = String(input).match(    Tamin.PDate.parseRegexes[{0}]);", // either null, or an array of matched strings

                "if(results){",
                "{1}",

                "if(u != null){", // i.e. unix time is defined
                "v = new Date(u * 1000);", // give top priority to UNIX time
                "}else{",
                // create Date object representing midnight of the current day;
                // this will provide us with our date defaults
                // (note: clearTime() handles Daylight Saving Time automatically)
                "dt =     Tamin.PDate.clearTime(new Date);",

                // date calculations (note: these calculations create a dependency on Ext.Number.from())
                "y = Ext.Number.from(y, Ext.Number.from(def.y,     Tamin.PDate.getFullYear(dt)));",
                "m = Ext.Number.from(m, Ext.Number.from(def.m - 1,     Tamin.PDate.getMonth(dt)));",
                "d = Ext.Number.from(d, Ext.Number.from(def.d,     Tamin.PDate.getDate(dt)));",

                // time calculations (note: these calculations create a dependency on Ext.Number.from())
                "h  = Ext.Number.from(h, Ext.Number.from(def.h, dt.getHours()));",
                "i  = Ext.Number.from(i, Ext.Number.from(def.i, dt.getMinutes()));",
                "s  = Ext.Number.from(s, Ext.Number.from(def.s, dt.getSeconds()));",
                "ms = Ext.Number.from(ms, Ext.Number.from(def.ms, dt.getMilliseconds()));",
                "gm=    Tamin.PDate.PersianToGregorian(y, m+1, d);y=gm[0];m=gm[1]-1;d=gm[2];",

                "if(z >= 0 && y >= 0){",
                // both the year and zero-based day of year are defined and >= 0.
                // these 2 values alone provide sufficient info to create a full date object

                // create Date object representing January 1st for the given year
                // handle years < 100 appropriately
                "v = Ext.Date.add(new Date(y < 100 ? 100 : y, 0, 1, h, i, s, ms), Ext.Date.YEAR, y < 100 ? y - 100 : 0);",

                // then add day of year, checking for Date "rollover" if necessary
                "v = !strict? v : (strict === true && (z <= 364 || (Ext.Date.isLeapYear(v) && z <= 365))? Ext.Date.add(v, Ext.Date.DAY, z) : null);",
                "}else if(strict === true && !Ext.Date.isValid(y, m + 1, d, h, i, s, ms)){", // check for Date "rollover"
                "v = null;", // invalid date, so return null
                "}else{",
                // plain old Date object
                // handle years < 100 properly
                "v = Ext.Date.add(new Date(y < 100 ? 100 : y, m, d, h, i, s, ms), Ext.Date.YEAR, y < 100 ? y - 100 : 0);",
                "}",
                "}",
                "}",

                "if(v){",
                // favour UTC offset over GMT offset
                "if(zz != null){",
                // reset to UTC, then add offset
                "v = Ext.Date.add(v, Ext.Date.SECOND, -v.getTimezoneOffset() * 60 - zz);",
                "}else if(o){",
                // reset to GMT, then add offset
                "v = Ext.Date.add(v, Ext.Date.MINUTE, -v.getTimezoneOffset() + (sn == '+'? -1 : 1) * (hr * 60 + mn));",
                "}",
                "}",

                "return v;"
            ].join('\n');

            return function (format) {
                var regexNum = utilPDate.parseRegexes.length,
                    currentGroup = 1,
                    calc = [],
                    regex = [],
                    special = false,
                    ch = "",
                    i = 0,
                    len = format.length,
                    atEnd = [],
                    obj;

                for (; i < len; ++i) {
                    ch = format.charAt(i);
                    if (!special && ch == "\\") {
                        special = true;
                    } else if (special) {
                        special = false;
                        regex.push(Ext.String.escape(ch));
                    } else {
                        obj = utilPDate.formatCodeToRegex(ch, currentGroup);
                        currentGroup += obj.g;
                        regex.push(obj.s);
                        if (obj.g && obj.c) {
                            if (obj.calcAtEnd) {
                                atEnd.push(obj.c);
                            } else {
                                calc.push(obj.c);
                            }
                        }
                    }
                }


                calc = calc.concat(atEnd);

                utilPDate.parseRegexes[regexNum] = new RegExp("^" + regex.join('') + "$", 'i');
                utilPDate.parseFunctions[format] = Ext.functionFactory("input", "strict", xf(code, regexNum, calc.join('')));
            };
        }()),
        // private
        parseCodes: {
            /*
             * Notes:
             * g = {Number} calculation group (0 or 1. only group 1 contributes to date calculations.)
             * c = {String} calculation method (required for group 1. null for group 0. {0} = currentGroup - position in regex result array)
             * s = {String} regex pattern. all matches are stored in results[], and are accessible by the calculation mapped to 'c'
             */
            d: {
                g: 1,
                c: "d = parseInt(results[{0}], 10);\n",
                s: "(3[0-1]|[1-2][0-9]|0[1-9])" // day of month with leading zeroes (01 - 31)
            },
            j: {
                g: 1,
                c: "d = parseInt(results[{0}], 10);\n",
                s: "(3[0-1]|[1-2][0-9]|[1-9])" // day of month without leading zeroes (1 - 31)
            },
            D: function () {
                for (var a = [], i = 0; i < 7; a.push(utilPDate.getShortDayName(i)), ++i); // get localised short day names
                return {
                    g: 0,
                    c: null,
                    s: "(?:" + a.join("|") + ")"
                };
            },
            l: function () {
                return {
                    g: 0,
                    c: null,
                    s: "(?:" + utilPDate.dayNames.join("|") + ")"
                };
            },
            N: {
                g: 0,
                c: null,
                s: "[1-7]" // ISO-8601 day number (1 (monday) - 7 (sunday))
            },
            //<locale type="object" property="parseCodes">
            S: {
                g: 0,
                c: null,
                s: "(?:st|nd|rd|th)"
            },
            //</locale>
            w: {
                g: 0,
                c: null,
                s: "[0-6]" // javascript day number (0 (sunday) - 6 (saturday))
            },
            z: {
                g: 1,
                c: "z = parseInt(results[{0}], 10);\n",
                s: "(\\d{1,3})" // day of the year (0 - 364 (365 in leap years))
            },
            W: {
                g: 0,
                c: null,
                s: "(?:\\d{2})" // ISO-8601 week number (with leading zero)
            },
            F: function () {
                return {
                    g: 1,
                    c: "m = parseInt(    Tamin.PDate.getMonthNumber(results[{0}]), 10);\n", // get localised month number
                    s: "(" + utilPDate.monthNames.join("|") + ")"
                };
            },
            M: function () {
                for (var a = [], i = 0; i < 12; a.push(utilPDate.getShortMonthName(i)), ++i); // get localised short month names
                return Ext.applyIf({
                    s: "(" + a.join("|") + ")"
                }, utilPDate.formatCodeToRegex("F"));
            },
            m: {
                g: 1,
                c: "m = parseInt(results[{0}], 10) - 1;\n",
                s: "(1[0-2]|0[1-9])" // month number with leading zeros (01 - 12)
            },
            n: {
                g: 1,
                c: "m = parseInt(results[{0}], 10) - 1;\n",
                s: "(1[0-2]|[1-9])" // month number without leading zeros (1 - 12)
            },
            t: {
                g: 0,
                c: null,
                s: "(?:\\d{2})" // no. of days in the month (28 - 31)
            },
            L: {
                g: 0,
                c: null,
                s: "(?:1|0)"
            },
            o: function () {
                return utilPDate.formatCodeToRegex("Y");
            },
            Y: {
                g: 1,
                c: "y = parseInt(results[{0}], 10);\n",
                s: "(\\d{4})" // 4-digit year
            },
            y: {
                g: 1,
                c: "var ty = parseInt(results[{0}], 10);\n"
                + "y = ty >     Tamin.PDate.y2kYear ? 1300 + ty : 1400 + ty;\n", // 2-digit year
                s: "(\\d{1,2})"
            },
            /*
             * In the am/pm parsing routines, we allow both upper and lower case
             * even though it doesn't exactly match the spec. It gives much more flexibility
             * in being able to specify case insensitive regexes.
             */
            //<locale type="object" property="parseCodes">
            a: {
                g: 1,
                c: "if (/(am)/i.test(results[{0}])) {\n"
                + "if (!h || h == 12) { h = 0; }\n"
                + "} else { if (!h || h < 12) { h = (h || 0) + 12; }}",
                s: "(am|pm|AM|PM)",
                calcAtEnd: true
            },
            //</locale>
            //<locale type="object" property="parseCodes">
            A: {
                g: 1,
                c: "if (/(am)/i.test(results[{0}])) {\n"
                + "if (!h || h == 12) { h = 0; }\n"
                + "} else { if (!h || h < 12) { h = (h || 0) + 12; }}",
                s: "(AM|PM|am|pm)",
                calcAtEnd: true
            },
            //</locale>
            g: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(1[0-2]|[0-9])" //  12-hr format of an hour without leading zeroes (1 - 12)
            },
            G: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(2[0-3]|1[0-9]|[0-9])" // 24-hr format of an hour without leading zeroes (0 - 23)
            },
            h: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(1[0-2]|0[1-9])" //  12-hr format of an hour with leading zeroes (01 - 12)
            },
            H: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(2[0-3]|[0-1][0-9])" //  24-hr format of an hour with leading zeroes (00 - 23)
            },
            i: {
                g: 1,
                c: "i = parseInt(results[{0}], 10);\n",
                s: "([0-5][0-9])" // minutes with leading zeros (00 - 59)
            },
            s: {
                g: 1,
                c: "s = parseInt(results[{0}], 10);\n",
                s: "(\\d{2})" // seconds with leading zeros (00 - 59)
            },
            u: {
                g: 1,
                c: "ms = results[{0}]; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n",
                s: "(\\d+)" // decimal fraction of a second (minimum = 1 digit, maximum = unlimited)
            },
            O: {
                g: 1,
                c: [
                    "o = results[{0}];",
                    "var sn = o.substring(0,1),", // get + / - sign
                    "hr = o.substring(1,3)*1 + Math.floor(o.substring(3,5) / 60),", // get hours (performs minutes-to-hour conversion also, just in case)
                    "mn = o.substring(3,5) % 60;", // get minutes
                    "o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n" // -12hrs <= GMT offset <= 14hrs
                ].join("\n"),
                s: "([+-]\\d{4})" // GMT offset in hrs and mins
            },
            P: {
                g: 1,
                c: [
                    "o = results[{0}];",
                    "var sn = o.substring(0,1),", // get + / - sign
                    "hr = o.substring(1,3)*1 + Math.floor(o.substring(4,6) / 60),", // get hours (performs minutes-to-hour conversion also, just in case)
                    "mn = o.substring(4,6) % 60;", // get minutes
                    "o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n" // -12hrs <= GMT offset <= 14hrs
                ].join("\n"),
                s: "([+-]\\d{2}:\\d{2})" // GMT offset in hrs and mins (with colon separator)
            },
            T: {
                g: 0,
                c: null,
                s: "[A-Z]{1,4}" // timezone abbrev. may be between 1 - 4 chars
            },
            Z: {
                g: 1,
                c: "zz = results[{0}] * 1;\n" // -43200 <= UTC offset <= 50400
                + "zz = (-43200 <= zz && zz <= 50400)? zz : null;\n",
                s: "([+\-]?\\d{1,5})" // leading '+' sign is optional for UTC offset
            },
            c: function () {
                var calc = [],
                    arr = [
                        utilPDate.formatCodeToRegex("Y", 1), // year
                        utilPDate.formatCodeToRegex("m", 2), // month
                        utilPDate.formatCodeToRegex("d", 3), // day
                        utilPDate.formatCodeToRegex("H", 4), // hour
                        utilPDate.formatCodeToRegex("i", 5), // minute
                        utilPDate.formatCodeToRegex("s", 6), // second
                        {
                            c: "ms = results[7] || '0'; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n"
                        }, // decimal fraction of a second (minimum = 1 digit, maximum = unlimited)
                        {
                            c: [ // allow either "Z" (i.e. UTC) or "-0530" or "+08:00" (i.e. UTC offset) timezone delimiters. assumes local timezone if no timezone is specified
                                "if(results[8]) {", // timezone specified
                                "if(results[8] == 'Z'){",
                                "zz = 0;", // UTC
                                "}else if (results[8].indexOf(':') > -1){",
                                utilPDate.formatCodeToRegex("P", 8).c, // timezone offset with colon separator
                                "}else{",
                                utilPDate.formatCodeToRegex("O", 8).c, // timezone offset without colon separator
                                "}",
                                "}"
                            ].join('\n')
                        }
                    ],
                    i,
                    l;

                for (i = 0, l = arr.length; i < l; ++i) {
                    calc.push(arr[i].c);
                }

                return {
                    g: 1,
                    c: calc.join(""),
                    s: [
                        arr[0].s, // year (required)
                        "(?:", "-", arr[1].s, // month (optional)
                        "(?:", "-", arr[2].s, // day (optional)
                        "(?:",
                        "(?:T| )?", // time delimiter -- either a "T" or a single blank space
                        arr[3].s, ":", arr[4].s,  // hour AND minute, delimited by a single colon (optional). MUST be preceded by either a "T" or a single blank space
                        "(?::", arr[5].s, ")?", // seconds (optional)
                        "(?:(?:\\.|,)(\\d+))?", // decimal fraction of a second (e.g. ",12345" or ".98765") (optional)
                        "(Z|(?:[-+]\\d{2}(?::)?\\d{2}))?", // "Z" (UTC) or "-0530" (UTC offset without colon delimiter) or "+08:00" (UTC offset with colon delimiter) (optional)
                        ")?",
                        ")?",
                        ")?"
                    ].join("")
                };
            },
            U: {
                g: 1,
                c: "u = parseInt(results[{0}], 10);\n",
                s: "(-?\\d+)" // leading minus sign indicates seconds before UNIX epoch
            }
        },

        //Old     Tamin.PDate prototype methods.
        // private
        dateFormat: function (date, format) {
            return utilPDate.format(date, format);
        },

        /**
         * Compares if two dates are equal by comparing their values.
         * @param {Date} date1
         * @param {Date} date2
         * @return {Boolean} True if the date values are equal
         */
        isEqual: Ext.Date.isEqual,

        /**
         * Formats a date given the supplied format string.
         * @param {Date} date The date to format
         * @param {String} format The format string
         * @return {String} The formatted date or an empty string if date parameter is not a JavaScript Date object
         */
        format: function (date, format) {
            var formatFunctions = utilPDate.formatFunctions;

            if (!Ext.isDate(date)) {
                return '';
            }

            if (formatFunctions[format] == null) {
                utilPDate.createFormat(format);
            }

            return formatFunctions[format].call(date) + '';
        },
        /**
         * Get the timezone abbreviation of the current date (equivalent to the format specifier 'T').
         *
         * Note: The date string returned by the javascript Date object's toString() method varies
         * between browsers (e.g. FF vs IE) and system region settings (e.g. IE in Asia vs IE in America).
         * For a given date string e.g. "Thu Oct 25 2007 22:55:35 GMT+0800 (Malay Peninsula Standard Time)",
         * getTimezone() first tries to get the timezone abbreviation from between a pair of parentheses
         * (which may or may not be present), failing which it proceeds to get the timezone abbreviation
         * from the GMT offset portion of the date string.
         * @param {Date} date The date
         * @return {String} The abbreviated timezone name (e.g. 'CST', 'PDT', 'EDT', 'MPST' ...).
         */
        getTimezone: Ext.Date.getTimezone,

        /**
         * Get the offset from GMT of the current date (equivalent to the format specifier 'O').
         * @param {Date} date The date
         * @param {Boolean} colon (optional) true to separate the hours and minutes with a colon (defaults to false).
         * @return {String} The 4-character offset string prefixed with + or - (e.g. '-0600').
         */
        getGMTOffset: Ext.Date.getGMTOffset,

        /**
         * Get the numeric day number of the year, adjusted for leap year.
         * @param {Date} date The date
         * @return {Number} 0 to 364 (365 in leap years).
         */
        getDayOfYear: function (date) {
            var num = 0,
                d = Tamin.PDate.clone(date),
                m = Tamin.PDate.getMonth(date),
                i;

            for (i = 0, utilPDate.setDate(d, 1), utilPDate.setMonth(d, 0); i < m; utilPDate.setMonth(d, ++i)) {
                num += utilPDate.getDaysInMonth(d);
            }
            return num + Tamin.PDate.getDate(date) - 1;
        },
        /**
         * Get the numeric ISO-8601 week number of the year.
         * (equivalent to the format specifier 'W', but without a leading zero).
         * @param {Date} date The date
         * @return {Number} 1 to 53
         * @method
         */
        getWeekOfYear: function (date) {
            var days = Tamin.PDate.getDayOfYear(date);
            return Math.ceil(days / 7);
        },
        /**
         * Checks if the current date falls within a leap year.
         * @param {Date} date The date
         * @return {Boolean} True if the current date falls within a leap year, false otherwise.
         */
        isLeapYear: function (date) {
            var year = Tamin.PDate.getFullYear(date),
                mod = year % 33;
            return !!(mod == 1 || mod == 5 || mod == 9 || mod == 13 || mod == 17 || mod == 22 || mod == 26 || mod == 30);
        },
        /**
         * Get the first day of the current month, adjusted for leap year.  The returned value
         * is the numeric day index within the week (0-6) which can be used in conjunction with
         * the {@link #monthNames} array to retrieve the textual day name.
         * Example:
         * <pre><code>
         var dt = new Date('1/10/2007'),
         firstDay =     Tamin.PDate.getFirstDayOfMonth(dt);
         console.log(    Tamin.PDate.dayNames[firstDay]); //output: 'Monday'
         * </code></pre>
         * @param {Date} date The date
         * @return {Number} The day number (0-6).
         */
        getFirstDayOfMonth: function (date) {
            utilPDate.getFirstDateOfMonth(date).getDay();
        },
        /**
         * Get the last day of the current month, adjusted for leap year.  The returned value
         * is the numeric day index within the week (0-6) which can be used in conjunction with
         * the {@link #monthNames} array to retrieve the textual day name.
         * Example:
         * <pre><code>
         var dt = new Date('1/10/2007'),
         lastDay =     Tamin.PDate.getLastDayOfMonth(dt);
         console.log(    Tamin.PDate.dayNames[lastDay]); //output: 'Wednesday'
         * </code></pre>
         * @param {Date} date The date
         * @return {Number} The day number (0-6).
         */
        getLastDayOfMonth: function (date) {
            return utilPDate.getLastDateOfMonth(date).getDay();
        },
        /**
         * Get the date of the first day of the month in which this date resides.
         * @param {Date} date The date
         * @return {Date}
         */
        getFirstDateOfMonth: function (date) {
            var c = Tamin.PDate.clone(date);
            Tamin.PDate.setDate(c, 1);
            return c;
        },
        /**
         * Get the date of the last day of the month in which this date resides.
         * @param {Date} date The date
         * @return {Date}
         */
        getLastDateOfMonth: function (date) {
            var c = Tamin.PDate.clone(date);
            Tamin.PDate.setDate(c, utilPDate.getDaysInMonth(date));
            return c;
        },
        /**
         * Get the number of days in the current month, adjusted for leap year.
         * @param {Date} date The date
         * @return {Number} The number of days in the month.
         * @method
         */
        getDaysInMonth: function (date) {
            var m = Tamin.PDate.getMonth(date);

            return m == 11 && Tamin.PDate.isLeapYear(date) ? 30 : Tamin.PDate.j_days_in_month[m];
        },
        /**
         * Get the English ordinal suffix of the current day (equivalent to the format specifier 'S').
         * @param {Date} date The date
         * @return {String} 'st, 'nd', 'rd' or 'th'.
         */
        //<locale type="function">
        getSuffix: Ext.Date.getSuffix,
        //</locale>

        /**
         * Creates and returns a new Date instance with the exact same date value as the called instance.
         * Dates are copied and passed by reference, so if a copied date variable is modified later, the original
         * variable will also be changed.  When the intention is to create a new variable that will not
         * modify the original instance, you should create a clone.
         *
         * Example of correctly cloning a date:
         * <pre><code>
         //wrong way:
         var orig = new Date('10/1/2006');
         var copy = orig;
         copy.setDate(5);
         console.log(orig);  //returns 'Thu Oct 05 2006'!

         //correct way:
         var orig = new Date('10/1/2006'),
         copy =     Tamin.PDate.clone(orig);
         copy.setDate(5);
         console.log(orig);  //returns 'Thu Oct 01 2006'
         * </code></pre>
         * @param {Date} date The date
         * @return {Date} The new Date instance.
         */
        clone: Ext.Date.clone,

        /**
         * Checks if the current date is affected by Daylight Saving Time (DST).
         * @param {Date} date The date
         * @return {Boolean} True if the current date is affected by DST.
         */
        isDST: Ext.Date.isDST,

        /**
         * Attempts to clear all time information from this Date by setting the time to midnight of the same day,
         * automatically adjusting for Daylight Saving Time (DST) where applicable.
         * (note: DST timezone information for the browser's host operating system is assumed to be up-to-date)
         * @param {Date} date The date
         * @param {Boolean} clone true to create a clone of this date, clear the time and return it (defaults to false).
         * @return {Date} this or the clone.
         */
        clearTime: Ext.Date.clearTime,

        /**
         * Provides a convenient method for performing basic date arithmetic. This method
         * does not modify the Date instance being called - it creates and returns
         * a new Date instance containing the resulting date value.
         *
         * Examples:
         * <pre><code>
         // Basic usage:
         var dt =     Tamin.PDate.add(new Date('10/29/2006'),     Tamin.PDate.DAY, 5);
         console.log(dt); //returns 'Fri Nov 03 2006 00:00:00'

         // Negative values will be subtracted:
         var dt2 =     Tamin.PDate.add(new Date('10/1/2006'), Ext.Date.DAY, -5);
         console.log(dt2); //returns 'Tue Sep 26 2006 00:00:00'

         * </code></pre>
         *
         * @param {Date} date The date to modify
         * @param {String} interval A valid date interval enum value.
         * @param {Number} value The amount to add to the current date.
         * @return {Date} The new Date instance.
         */
        add: function (date, interval, value) {
            var d = Tamin.PDate.clone(date),
                day;
            if (!interval || value === 0) {
                return d;
            }

            switch (interval.toLowerCase()) {
                case Ext.Date.MILLI:
                    d.setMilliseconds(d.getMilliseconds() + value);
                    break;
                case Ext.Date.SECOND:
                    d.setSeconds(d.getSeconds() + value);
                    break;
                case Ext.Date.MINUTE:
                    d.setMinutes(d.getMinutes() + value);
                    break;
                case Ext.Date.HOUR:
                    d.setHours(d.getHours() + value);
                    break;
                case Ext.Date.DAY:
                    d.setDate(d.getDate() + value);
                    break;
                case Ext.Date.MONTH:
                    day = Tamin.PDate.getDate(d);
                    if (day > 29) {
                        day = Math.min(day, Tamin.PDate.getLastDateOfMonth(Tamin.PDate.add(Tamin.PDate.getFirstDateOfMonth(d), Ext.Date.MONTH, value)).getDate());
                    }
                    Tamin.PDate.setDate(d, day);
                    Tamin.PDate.setMonth(d, Tamin.PDate.getMonth(d) + value);
                    break;
                case Ext.Date.YEAR:
                    day = Tamin.PDate.getDate(d);
                    if (day > 29) {
                        day = Math.min(day, Tamin.PDate.getLastDateOfMonth(Tamin.PDate.add(Tamin.PDate.getFirstDateOfMonth(d), Ext.Date.YEAR, value)).getDate());
                    }
                    Tamin.PDate.setDate(d, day);
                    Tamin.PDate.setFullYear(d, Tamin.PDate.getFullYear(d) + value);
                    break;
            }
            return d;
        },
        /**
         * Checks if a date falls on or between the given start and end dates.
         * @param {Date} date The date to check
         * @param {Date} start Start date
         * @param {Date} end End date
         * @return {Boolean} true if this date falls on or between the given start and end dates.
         */
        between: Ext.Date.between
    }
});
var utilPDate = Tamin.PDate;
function xf(format) {
    var args = Array.prototype.slice.call(arguments, 1);
    return format.replace(/\{(\d+)\}/g, function (m, i) {
        return args[i];
    });
}
*******************************************************************************************

* android 
./sdkmanager --proxy=http  --no_https --proxy_host=127.0.0.1 --proxy_port=8118 "ndk-bundle"
https://developer.android.com/studio/command-line/sdkmanager.html
https://developer.android.com/ndk/downloads/index.html


.side-menu {
    width: 200px !important;
}

.topbar .topbar-left {
    width: 200px !important;
}

.navbar-custom {
    margin-right: 200px !important;
}

* download 
https://www.qt.io/download-open-source/#section-2
http://radius-manager.soft112.com/
http://wifismartzone.com/files/rm_related/
android studio

* setting android development environmet
https://gist.github.com/venkateshshukla/9736261

* radius
http://radmandemo.dmasoftlab.com/
http://www.proradiusmanager.com/
http://bulbsoft.com/product/
http://daloradius.com/
https://splynx.com/
http://www.ispcube.com/
http://demo.snono.systems/#/dashboard
http://demo.snono.systems/
** radius lab
https://mellowd.co.uk/ccie/?p=2777

* useful css/javascript libs
http://malsup.com/jquery/form/
https://github.com/carhartl/jquery-cookie
https://github.com/onokumus/metisMenu
http://www.jacklmoore.com/autosize/
http://wenzhixin.net.cn/p/multiple-select/docs/
https://github.com/blueimp/jQuery-File-Upload
http://sandywalker.github.io/webui-popover/demo/
https://github.com/sandywalker/webui-popover
https://github.com/bseth99/jquery-ui-extensions
http://listjs.com/
https://rawgit.com/jeresig/jquery.hotkeys/master/test-static-01.html
http://ned.im/noty/
http://malsup.com/jquery/block/
* asus n552vm 4-300-0000
* 
