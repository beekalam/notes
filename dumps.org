* Tasks
** german anthem
Einigkeit und Recht und Freiheit
Für das deutsche Vaterland!
Danach lasst uns alle streben
Brüderlich mit Herz und Hand!
Einigkeit und Recht und Freiheit
Sind des Glückes Unterpfand;
 |: Blüh' im Glanze dieses Glückes,
  Blühe, deutsches Vaterland! :|
Unity, justice and liberty
For our German fatherland!
For all these let us work and strive
United in hearts and hands!
Unity, justice and liberty
Are the pledges of our land;
 |: Flourish in fortune's blessings,
  Flourish, German fatherland! :|

** Linux Standard Base
Probably the single most relevant standard for a Linux distribution maintainer is the
Linux Standard Base (LSB). The goal of the LSB is to establish a set of standards
designed to enhance the interoperability of applications among different Linux distributions.
** Linux Standard Base Project
http://www.linuxfoundation.org/collaborate/workgroups/lsb
Linux Foundation
http://www.linuxfoundation.org/
** TODO learn some more
  
   [[file:~/Documents/notes/emacs-notes.org::*org-capture][org-capture]]
[[file:~/Documents/notes/problem-solving.org::*Backtracking][Backtracking]]
** TODO update for groups
  
   [[file:~/Documents/notes/ubuntu.org::*Repair%20grub][Repair grub]]
** TODO log to db when shahkar is disconnected
** TODO aaaa
  
   [[file:~/.emacs.d/init.el::'(("t"%20"Todo"%20entry%20(file+headline%20"todo.org"%20"Tasks")]]
** TODO asdfd
  
   [[file:~/.emacs.d/init.el::(setq%20org-default-notes-file%20(concat%20org-directory%20"todo.org"))]]
* Embedded
* memory space
High-performance microprocessors contain complex hardware engines called
Memory Management Units (MMUs). Their purpose is to enable an operating system
to exercise a high degree of management and control over its address space and the
address space it allocates to processes. This control comes in two primary forms: access
rights and memory translation. Access rights allow an operating system to assign specific
memory-access privileges to specific tasks. Memory translation allows an operating
system to virtualize its address space, which has many benefits.
 The Linux kernel takes advantage of these hardware MMUs to create a virtual
memory operating system
* Execution Contexts
 In Linux, we refer to two distinctly separate operational contexts, based on the
environment in which a given thread15 is executing. Threads executing entirely within
the kernel are said to be operating in kernel context. Application programs are said to
operate in user space context. A user space process can access only memory it owns, and
it is required to use kernel system calls to access privileged resources such as file and
device I/O. 
 When an application program executes a system call that
results in a context switch and enters the kernel, it is executing kernel code on behalf
of a process. You will often hear this referred to as process context within the kernel. In
contrast, the interrupt service routine (ISR) handling the IDE drive (or any other ISR,
for that matter) is kernel code that is not executing on behalf of any particular process.
This is typically called interrupt context.
* Processors
* Stand-Alone Processors
Stand-alone processors are processor chips that are dedicated exclusively to the
processing function. As opposed to integrated processors, stand-alone processors
require additional support circuitry for their basic operation. In many cases, this
means a chipset or custom logic surrounding the processor to handle functions such
as DRAM controller, system bus addressing configuration, and external peripheral
devices such as keyboard controllers and serial ports. Stand-alone processors often
offer the highest overall CPU performance.

** Companion Chipsets
Stand-alone processors require support logic to connect to and enable
external peripheral devices such as main system memory (DRAM), ROM or
Flash memory, system buses such as PCI, and other peripherals.  This
support logic often is accomplished by companion chipsets, which may
even be purpose-designed specifically for a family of processors.

*** northbridge , southbridge
northbridge is directly connected to the  processor's high-speed front-side bus (FSB).

* Ich kann alless lyrics
[Verse 1]
Ich nehm' mein Ego, quetsch' es aus
Alle Tränen müssen raus
Betrunken von mir selbst, füll' leere Gläser wieder auf
Leere Gläser wieder aus
Selbst der Wasserwerfer kann mir nichts
Strahle so hell, dass alles regenbogenfarben ist
Wo die Nacht pulsiert, wo jeder was erwartet
Mich niemand wirklich kennt, wirklich niemand auf mich wartet

[Pre-Hook]
Weiß niemand, wo mein Herz schlägt?
Weiß niemand, wo mein Herz schlägt?
Und die Vögel, sie zwitschern immer noch das alte Lied
Ein zahmer singt von Freiheit, ein wilder Vogel fliegt
Und jeder Spruch klingt so wie tausende zuvor
Nicht mehr wert als nur ein Rauschen im Ohr

[Hook]
Mir egal, ich kann alles
Ich kann alles
Ich kann alles
Alles glänzt, was ab jetzt vor mir liegt
Ich kann alles
Ich kann alles
Ich kann alles
Bis ich aufschlag' beweis' ich, dass ich flieg'

[Verse 2]
Ich hab mir alles geglaubt, mir meine Lügen auch
Und dass die Lügen Lügen waren, glaub' ich mir jetzt auch
Wissen ersetzt denken nicht, weiß ich nicht, denke ich
Ich hab mich an mir verblendet, schrieb Geschichte nur in Blindenschrift
Wollte nicht so sein wie sie, wusste, was ich werden muss
Andere Leute werden groß, ich mach' mit dem werden Schluss
Und wenn mich jemand hasst, hab ich immer noch irgendwas
Das der jemand gerne hätte - alles richtig gemacht

[Pre-Hook]
Ich weiß wieder wo mein Herz schlägt
Ich weiß wieder wo mein Herz schlägt
Und die Vögel, sie zwitschern immer noch das alte Lied
Ein zahmer singt von Freiheit, ein wilder Vogel fliegt
Und jeder Spruch klingt so wie tausende zuvor
Nicht mehr wert als nur ein Rauschen im Ohr

[Hook]
Mir egal, ich kann alles
Ich kann alles
Ich kann alles
Alles glänzt, was ab jetzt vor mir liegt
Ich kann alles
Ich kann alles
Ich kann alles
Bis ich aufschlag' beweis' ich, dass ich flieg'

[Bridge]
Schau mich an, ich kann alles
Ich kann nicht viel, nein, alles
Wie viel ich verdien'? Alles!
Mein einziges Ziel? Alles!
Schau mich an, ich kann alles
Hab' mich entschieden gegen alle
Mach' meinen Frieden mit allen
Entschieden zu fliegen, bis ich falle

[Hook] x2
Ich kann alles
Ich kann alles
Ich kann alles
Alles glänzt, was ab jetzt vor mir liegt
Ich kann alles
Ich kann alles
Ich kann alles
Bis ich aufschlag' beweis' ich, dass ich flieg'
* LFS assumes that the root file system (/) is of type ext4. To create an ext4 file system on the LFS partition, run the following:
  
mkfs -v -t ext4 /dev/<xxx>
If you are using an existing swap partition, there is no need to format it. If a new swap partition was created, it will need to be initialized with this command:

mkswap /dev/<yyy>
Replace <yyy> with the name of the swap partition.
* LFS assumes that the root file system (/) is of type ext4. To create an ext4 file system on the LFS partition, run the following:

mkfs -v -t ext4 /dev/<xxx>
If you are using an existing swap partition, there is no need to format it. If a new swap partition was created, it will need to be initialized with this command:

mkswap /dev/<yyy>
Replace <yyy> with the name of the swap partition.
* LFS assumes that the root file system (/) is of type ext4. To create an ext4 file system on the LFS partition, run the following:

mkfs -v -t ext4 /dev/<xxx>
If you are using an existing swap partition, there is no need to format it. If a new swap partition was created, it will need to be initialized with this command:

mkswap /dev/<yyy>
Replace <yyy> with the name of the swap partition.
* LFS assumes that the root file system (/) is of type ext4. To create an ext4 file system on the LFS partition, run the following:

mkfs -v -t ext4 /dev/<xxx>
If you are using an existing swap partition, there is no need to format it. If a new swap partition was created, it will need to be initialized with this command:

mkswap /dev/<yyy>
Replace <yyy> with the name of the swap partition.

============ 
LFS assumes that the root file system (/) is of type
ext4. To create an ext4 file system on the LFS partition, run the
following:

mkfs -v -t ext4 /dev/<xxx> 

If you are using an existing swap
partition, there is no need to format it. If a new swap partition was
created, it will need to be initialized with this command:

mkswap /dev/<yyy>

Replace <yyy> with the name of the swap partition.
export LFS=/mnt/lfs

Create the mount point and mount the LFS file system by running:

mkdir -pv $LFS
mount -v -t ext4 /dev/<xxx> $LFS

If using multiple partitions for LFS (e.g., one for / and another for /usr), mount them using:

mkdir -pv $LFS
mount -v -t ext4 /dev/<xxx> $LFS
mkdir -v $LFS/usr
mount -v -t ext4 /dev/<yyy> $LFS/usr

If you are using a swap partition, ensure that it is enabled using the swapon command:

/sbin/swapon -v /dev/<zzz>
Replace <zzz> with the name of the swap partition

mkdir -v $LFS/sources
Make this directory writable and sticky. “Sticky” means that even if multiple users have write permission on a directory, only the owner of a file can delete the file within a sticky directory. The following command will enable the write and sticky modes:

chmod -v a+wt $LFS/sources
An easy way to download all of the packages and patches is by using wget-list as an input to wget. For example:

wget --input-file=wget-list --continue --directory-prefix=$LFS/sources


mkdir -v $LFS/tools
ln -sv $LFS/tools /
groupadd lfs
useradd -s /bin/bash -g lfs -m -k /dev/null lfs
passwd lfs
chown -v lfs $LFS/tools
chown -v lfs $LFS/sources
su - lfs

cat > ~/.bash_profile << "EOF"
exec env -i HOME=$HOME TERM=$TERM PS1='\u:\w\$ ' /bin/bash
EOF


cat > ~/.bashrc << "EOF"
set +h
umask 022
LFS=/mnt/lfs
LC_ALL=POSIX
LFS_TGT=$(uname -m)-lfs-linux-gnu
PATH=/tools/bin:/bin:/usr/bin
export LFS LC_ALL LFS_TGT PATH
EOF

source ./.bash_profile

The Binutils documentation recommends building Binutils in a dedicated build directory:

mkdir -v build
cd       build

../configure --prefix=/tools            \
             --with-sysroot=$LFS        \
             --with-lib-path=/tools/lib \
             --target=$LFS_TGT          \
             --disable-nls              \
             --disable-werror

If building on x86_64, create a symlink to ensure the sanity of the toolchain:

case $(uname -m) in
  x86_64) mkdir -v /tools/lib && ln -sv lib /tools/lib64 ;;
esac
Install the package:

make install
* this is a new todo?
  what is your name
route add -net 172.16.11.0/24 172.16.12.141
** 
howManyBees = function(hive) {
  var res = 0;
  for(var k in hive){
    var row = hive[k];
    var rev = row.split('').reverse().join('');
    res += (row.match(/bee/g) || []).length;
    res += (rev.match(/bee/g) || []).length;
  }
  var cols = [];
  for(var i = 0; i < hive.length; ++i){
    var col='';
    for(var j = 0; j< hive.length; ++j){
      col += hive[i][j];
    }
    cols.push(col);
  }
  
  for(var k in cols){
    var row = cols[k];
    var rev = row.split('').reverse().join('');
    res += (row.match(/bee/g) || []).length;
    res += (rev.match(/bee/g) || []).length;
  }
  
  return res;
}
* PPP over SSH with linux
PPP over SSH with linux

What?

PPP is an IP point-to-point link protocol that operates over terminals. Usually the terminal is a modem, but any tty will do. SSH creates secure ttys. SSH also has the advantage that it uses a single client->server TCP connection, and thereby NATs cleanly. These properties make it pass easily through firewalls and NAT routers. PPP over SSH is a poor man's VPN.

Why?

Because it can be done. And because sometimes it's quickest way to get the job done. One place it is useful is securing wireless connections. ppp over ssh over 802.11.

How?

PPP over SSH needs to be resilient. The SSH connection needs to connect and reconnect on its own when the connection is lost. To achieve this use SSH's public key authentication method and manually add the key to ssh-agent on the client side before connecting. Then configure ppp to "dial" using ssh, and to redial when the connection is lost. With this configuration SSH will reconnect as long as the client machine does not loose power. This is good enough in most cases; a UPS will make it even more reliable.

SSH will need a login and a public key. For safety this should be a new login on the server, and normal login should be disabled (A '*' in place of the password in /etc/shadow). If the client will be connecting from a static address, use of the public key should be restricted to that address. And that key does not need X11 forwarding, nor ssh agent forwarding. These also should be disabled for that key.

Because the PPP is tunneled over SSH you could use plaintext PPP passwords, but since CHAP is just as easy, do it.

Lastly if the client is in fact a router, IP routes should be setup at either end to point throught the tunnel. These can be hand configured in /etc/network/interfaces or with "/sbin/ip route add ..." commands in ppp-up. But running a routing daemon at both ends of the ppp link works much better. OSPF works well for this.

HOWTO

First configure ssh. Create a new user for SSH to login to.

root@server # adduser --disabled-password ppp-link
Create an ssh key pair on the client.

user@client > ssh-keygen -t rsa -f $HOME/.ssh/ppp_rsa
Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/user/.ssh/ppp_rsa.
Your public key has been saved in /home/user/.ssh/ppp_rsa.pub.
The key fingerprint is:
04:32:f5:c5:0f:94:4b:46:37:d4:00:ab:45:4d:66:ae user@client

Copy the public key (ppp_rsa.pub) to ~ppp-link/.ssh/authorized_keys on the
server. Then add options to the line in authorized_keys to restrict how it can
be used. For example:

ppp-link@server > cat $HOME/.ssh/authorized_keys
from="192.168.168.*",no-port-forwarding,no-X11-forwarding,no-agent-forwarding ssh-rsa AAAB...5+TCM= user@client

removes all the capabilities that aren't needed (port & X11 and ssh-agent
forwarding), and restricts the source IP so that the client must connect from
the 192.168.168.0/24 IP subnet. Restricting the client's IP address is a good
thing, especially if this is a public ssh server. See the AUTHORIZED_KEYS FILE
FORMAT section of the sshd manpage for more ways 'from' can be configured.

At this point ssh should be working. Test it:

user@client > ssh -l ppp-link -i $HOME/.ssh/ppp_rsa server
Enter passphrase for key '/home/user/.ssh/ppp_rsa':
ppp-link@server > exit
logout
Connection to server closed.

Then configure ppp. 

First add secrets for the chap authentication and IP addresses for the endpoints
of the ppp link. You can use a different secret in each direction. This way the
ppp client can authenticate the ppp server. In this example the client machine
has been called "client" and the server "server". They should be replaced with
the actual hostnames (or whatever PPP is configured to use for names).

root@server # echo >>/etc/ppp/chap-secrets <<EOF
client          server  secret1          10.1.1.1
server          client  secret2          10.1.1.2
EOF
Add the same secrets to the chap-secrets file on the client.

root@client # echo >>/etc/ppp/chap-secrets <<EOF
client          server  secret1          10.1.1.1
server          client  secret2          10.1.1.2
EOF
And lastly create a ppp peer configuration file on the client. The name of the file will be the name ppp will be told to call.

root@client # echo >>/etc/ppp/peers/server <<EOF

# use a seperate log file
logfile /var/log/ppp/server.log

# names to use in secret lookup
name client
remotename server

# other side must authenticate to us
auth

# don't allow pap out of paranoia (actually in case we mess up and don't use ssh)
require-chap

# don't accept the default route from the other end. This is useful if we are using
# ppp-over-ssh to reach only certain hosts, since it prevents us from sending everything
# through the ppp link. But if everything should go through the link then "nodefaultroute"
# should be commented out, and the "defaultroute" and "replacedefaultroute" lines uncommented.
nodefaultroute
#defaultroute
#replacedefaultroute

# to switch DNS servers to what server specifies, uncomment "usepeerdns"
# depending on your distribution, you might also have to copy /etc/ppp/resolv.conf 
# to /etc/resolv.conf as part of ppp-up
#usepeerdns

# the magic line: "dial" with ssh. blowfish is faster than 3DES.
pty "/usr/bin/ssh -e none -c blowfish -t -l ppp-link server /usr/sbin/pppd passive"

# give ssh+remote pppd up to 30 seconds to start ppp'ing
connect-delay 30000

# make sure we fit in a single ethernet packet after ssh-encryption/tcp/ip headers
mtu 1200
mru 1200

# after we connect, detach from shell and run in background
updetach

# reconnect if we get disconnected
persist
holdoff 60

# keep trying to connect forever
maxfail 0

EOF
On debian users must be part of the dip group so they can execute pppd

root@client # usermod -G dip user
root@server # usermod -G dip ppp-link
And the log directory needs to be created if it doesn't already exist

root@client # mkdir /var/log/ppp

Now everything is ready. Starting up an ssh-agent (note well: back-ticks, not
single-quotes), and adding the public key to ssh-agent keeps ssh from prompting
for a passphrase each time ppp (re)connects.

user@client > eval `ssh-agent`
Agent pid 12345
user@client > ssh-add $HOME/.ssh/ppp_rsa
Enter passphrase for /home/user/.ssh/ppp_rsa:
Identity added: /home/user/.ssh/ppp_rsa (/home/user/.ssh/ppp_rsa)
user@client > pppd call server
Check that the connection took place and is working as it should

user@client > tail /var/log/ppp/server.log
Using interface ppp0
Connect: ppp0 <--> /dev/pts/10
CHAP peer authentication succeeded for server
Remote message: Welcome to server.
Deflate (15) compression enabled
local  IP address 10.1.1.1
remote IP address 10.1.1.2
user@client > /sbin/ip addr
1: lo:  mtu 16436 qdisc noqueue
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    127.0.0.1/8 brd 127.255.255.255 scope host lo
2: eth0:  mtu 1500 qdisc pfifo_fast qlen 100
    link/ether 00:01:02:b1:12:5b brd ff:ff:ff:ff:ff:ff
    inet 192.168.168.2/24 brd 192.168.168.255 scope global eth0
3: ppp0:  mtu 1200 qdisc pfifo_fast qlen 3
    link/ppp
    inet 10.1.1.1 peer 10.1.1.2/32 scope global ppp0
user@client > ping -c3 10.1.1.2
PING 10.10.10.2 (10.1.1.2) from 10.1.1.1 : 56(84) bytes of data.
64 bytes from 10.1.1.2: icmp_seq=1 ttl=255 time=50.7 ms
64 bytes from 10.1.1.2: icmp_seq=2 ttl=255 time=26.7 ms
64 bytes from 10.1.1.2: icmp_seq=3 ttl=255 time=29.2 ms

--- 10.1.1.2 ping statistics ---
3 packets transmitted, 3 received, 0% loss, time 2023ms
rtt min/avg/max/mdev = 26.795/35.617/50.768/10.762 ms
Looks good!

tunneling the default route

If the ppp-over-ssh link is being used to create a link to the internet (for
example when securing a wireless link) then the default route must point through
the tunnel. Two things must be true for this to happen: 'nodefaultroute' must be
changed to 'defaultroute' in the ppp peer's configuration, and if there exists a
default route before ppp connects then 'replacedefaultroute' must also be in the
peer's configuration. Without this pppd will not replace the existing default
route. Instead it will log a message to that effect: "not replacing default
route to eth0 [192.168.168.1]". As an added niceity, ppp will restore the
default route when the ppp link is torn down.

In the case of a wireless connection, client usually gets its IP address and
route table from the DHCP server in the wireless router. That DHCP server cannot
be configured not to advertise itself as the default gateway. So both
'defaultroute' and 'replacedefaultroute' are needed.

The DNS server address(es) might also have to be altered if the router also
advertised itself as the DNS server. Again the cleanest way to do this is to
pass the DNS address(es) to client as part of the ppp connection parameters.
'usepeerdns' on the client's peer configuration, and 'ms-dns' in the server's
options configuration file /etc/ppp/options.

OSPF

If other computers need to use client's ppp link, client will be acting as a
router. In this case it is most dynamic to run a routing daemon on client and
server and have then exchange routes over the ppp link. I prefer OSPF for this
since it doesn't send much traffic when no routes change. OSPF can also
advertise a default route, which removes the need to add it manually. Here is a
typical configurations for zebra's ospfd

root@server # cat /etc/zebra/ospfd.conf
hostname server

# ospf on the local LAN
interface eth0
 ip ospf authentication message-digest
 ip ospf message-digest-key 1 md5 secret_phrase_for_lan
exit

# ospf through the ppp tunnel
interface ppp0
 ip ospf network point-to-point
 # binding of key to ppp0 gets lost after ppp0 goes and comes back, so don't use auth
 #ip ospf authentication message-digest
 #ip ospf message-digest-key 1 md5 secret_phrase_for_ppp
exit

router ospf
 ospf router-id 192.168.168.1
 redistribute connected
 #redistribute static
 network 192.168.168.0/24 area 0
 network 10.1.1.1/32 area 0
exit

log file /var/log/zebra/ospfd.log

Unfortunately zebra's ospf looses the md5 key -> ppp0 binding if ppp0 goes down,
so it is not possible to use authentication with ospf on the ppp link. And
unfortunately zebra's ospf needs the name of the ppp link device. If there is
only one tunnel at any time then it is ppp0. If there are multiple tunnels then
ospfd must be reconfigured dynamically as part of the ppp-up process by passing
the appropriate commands to vtysh.

http://nsd.dyndns.org/pppossh/
* hajimi
https://security.rapiditynetworks.com/publications/2016-10-16/hajime.pdf
https://github.com/beekalam/Mirai-Source-Code
** 
https://routerboard.com/rb750g
https://routerboard.com/rb433ah
https://routerboard.com/rb450g

https://www.itbazar.com/all2_P_S_4734321.aspx
** 
۱۳۹۶/۰۲/۰۳
۱۳۹۵/۱۲/۲۶

* writing maintainable software
** Write Short Units of Code
*** intro
Units are the smallest groups of code that can be maintained and executed independ‐
ently. In Java, units are methods or constructors. A unit is always executed as a whole.
It is not possible to invoke just a few lines of a unit. Therefore, the smallest piece of
code that can be reused and tested is a unit.

 - Short Units Are Easy to Test
 - Short Units Are Easy to Analyze
 - Short Units Are Easy to Reuse
*** how to apply
 - Refactoring technique: Extract Method
 - Refactoring technique: Replace Method with Method Object
 - Limit the length of code units to 15 lines of code.
** Write Simple Units of Code
*** intro
 - Limit the number of branch points per unit to 4.
 - Do this by splitting complex units into simpler ones and avoiding complex units altogether.
 - This improves maintainability because keeping the number of branch points low makes units easier to modify and test.
*** How to apply
**** Dealing with Conditional Chains
   - use a Map data structure
   - Replace Conditional with Polymorphism pattern 

* timer1
  https://github.com/samyk/evercookie/
* css

http://kushagragour.in/lab/hint/
https://purecss.io/tools/
https://me.tamin.ir/js/register.js
https://me.tamin.ir/service/secure/registration

* javascript

  
var complexityText = 'پیچیدگی گذرواژه کافی نیست';
var complexityTextUpperCase = 'گذرواژه باید حداقل شامل یک کاراکتر بزرگ باشد';
var complexityTextLowerCase = 'گذرواژه باید حداقل شامل یک کاراکتر کوچک باشد';
var complexityTextDigit = 'گذرواژه باید شامل عدد باشد';
var complexityTextStartCharAlphabet = 'گذرواژه باید با یک حرف آغاز شود';
var complexityTextLength = 'گذرواژه حداقل باید هشت حرف باشد';
var complexityTextNotContainsSomeFields = 'گذرواژه باید با حروف لاتین بوده و شامل نام، نام خانوادگی و شماره ملی یا کد اتباع خارجی نباشد.';
var complexityTextFirstName = 'پیش از ورود نام امکان ارزیابی گذرواژه وجود ندارد';
var complexityTextlastName = 'پیش از ورود نام خانوادگی امکان ارزیابی گذرواژه وجود ندارد';
var complexityTextNationalCode = 'پیش از ورود کدملی یا شماره اتباع خارجی امکان ارزیابی گذرواژه وجود ندارد';
var complexityTextValidChar = 'فقط از کاراکترهای لاتین مجاز استفاده نمایید. شامل حروف، اعداد و !#$%&* ';

function hasClass(ele, cls) {
    return ele.className.match(new RegExp('(\\s|^)' + cls + '(\\s|$)'));
}

function addClass(ele, cls) {
    if (!this.hasClass(ele, cls))
        ele.className += " " + cls;
}
function removeClass(ele, cls) {
    if (hasClass(ele, cls)) {
        var reg = new RegExp('(\\s|^)' + cls + '(\\s|$)');
        ele.className = ele.className.replace(reg, ' ');
    }
}

function deleteButtonClick() {
    var queueNumber = document.getElementById('queueNumber');
    var nationalCode = document.getElementById('nationalCode');
    window.location.href = 'service/secure/delete-request?nationalCode=' + nationalCode.value + '&queueNumber=' + queueNumber.value;
}

function validateForm() {
    var result = true;
    result = result &
            validateLastName() &
            validateFirstName() &
            validateNationalCode() &
            validateEmail() &
            validatePassword() &
            validateRepeatedPassword() &
            validatePasswordsEquality() &
            validateMobile() &
            validateQuestion1() &
            validateQuestion2() &
            validateQuestion3() &
            validateQuestionEquality() &
//            validateSerialNo() &
//            validateSerialDigit() &
//            validateSerialAlphabet() &
            validateIdNo() &
            validateAnswer1() &
            validateAnswer2() &
            validateAnswer3() &
            validateAnswerEquality() &
//            validateDayOfBirth() &
            validateYearOfBirth();

    console.log(result != 0);
    return result != 0;
}

function validateMobile() {
    var mobile = document.getElementById('mobile');
    removeValidationEffects(mobile)
    if (mobile.value == null || mobile.value.trim() == '') {
        setInvalid(mobile, 'وارد نمودن شماره موبایل اجباری است');
        return false;
    }

    var re = /^[0-9]*$/;
    if (!re.test(mobile.value)) {
        setInvalid(mobile, 'شماره موبایل باید با کاراکترهای لاتین، بدون حرف و سایر کاراکترها وارد شود.');
        return false;
    }

    if (isNaN(mobile.value)) {
        setInvalid(mobile, 'شماره موبایل باید عدد باشد');
        return false;
    }

    if (mobile.value.length < 11) {
        setInvalid(mobile, 'شماره موبایل نادرست است');
        return false;
    }

    var reg = /^[0][9].*$/;
    if (!reg.test(mobile.value)) {
        setInvalid(mobile, 'شماره موبایل باید با عدد 09 شروع شود.');
        return false;
    }


    setValid(mobile);
    return true;
}

//function validateMobile() {
//    var mobile = document.getElementById('mobile');
//    removeValidationEffects(mobile)
//    if (mobile.value == null || mobile.value.trim() == '') {
//        setInvalid(mobile, 'وارد نمودن شماره موبایل اجباری است');
//        return false;
//    }
//
//    var re = /^[0-9]*$/;
//    if (!re.test(mobile.value)) {
//        setInvalid(mobile, 'شماره موبایل باید با کاراکترهای لاتین، بدون حرف و سایر کاراکترها وارد شود.');
//        return false;
//    }
//
//    if (isNaN(mobile.value)) {
//        setInvalid(mobile, 'شماره موبایل باید عدد باشد');
//        return false;
//    }
//
//
//    setValid(mobile);
//    return true;
//}

function validateSerialNo() {
    var serialNo = document.getElementById('serialNo');
    removeValidationEffects(serialNo)
    if (serialNo.value == null || serialNo.value.trim() == '') {
        setInvalid(serialNo, 'وارد نمودن شماره سریال اجباری است');
        return false;
    }

    var re = /^[0-9]*$/;
    if (!re.test(serialNo.value)) {
        setInvalid(serialNo, 'شماره سریال باید با کاراکترهای لاتین، بدون حرف و سایر کاراکترها وارد شود.');
        return false;
    }

    if (isNaN(serialNo.value)) {
        setInvalid(serialNo, 'شماره سریال باید عدد باشد');
        return false;
    }

    setValid(serialNo);
    return true;
}

function validateSerialDigit() {
    var serialDigit = document.getElementById('serialDigit');
    removeValidationEffects(serialDigit)
    if (serialDigit.value == null || serialDigit.value.trim() == '') {
//        setInvalid(serialDigit, 'وارد نمودن شماره سری اجباری است');
//        return false;
        return true;
    }

    var re = /^[0-9]*$/;
    if (!re.test(serialDigit.value)) {
        setInvalid(serialDigit, 'شماره سری باید با کاراکترهای لاتین، بدون حرف و سایر کاراکترها وارد شود.');
        return false;
    }

    if (isNaN(serialDigit.value)) {
        setInvalid(serialDigit, 'شماره سری باید عدد باشد');
        return false;
    }

    setValid(serialDigit);
    return true;
}

function validateIdNo() {
    var idNo = document.getElementById('idNo');
    removeValidationEffects(idNo)
    if (idNo.value == null || idNo.value.trim() == '') {
        setInvalid(idNo, 'وارد نمودن شماره شناسنامه اجباری است');
        return false;
    }

    var re = /^[0-9]*$/;
    if (!re.test(idNo.value)) {
        setInvalid(idNo, 'شماره شناسنامه باید با کاراکترهای لاتین، بدون حرف و سایر کاراکترها وارد شود.');
        return false;
    }

    if (isNaN(idNo.value)) {
        setInvalid(idNo, 'شماره شناسنامه باید عدد باشد');
        return false;
    }
    setValid(idNo);
    return true;
}

function validateLastName() {
    var lastName = document.getElementById('lastName');
    removeValidationEffects(lastName)
    if (lastName.value == null || lastName.value.trim() == '') {
        setInvalid(lastName, 'وارد نمودن نام خانوادگی اجباری است');
        return false;
    }
    setValid(lastName);
    return true;
}
function validateFirstName() {
    var firstName = document.getElementById('firstName');
    removeValidationEffects(firstName);
    if (firstName.value == null || firstName.value.trim() == '') {
        setInvalid(firstName, 'وارد نمودن نام اجباری است');
        return false;
    }
    setValid(firstName);
    return true;
}
function validateNationalCode() {
    var nationalCode = document.getElementById('nationalCode');
    removeValidationEffects(nationalCode);
    if (nationalCode.value == null) {
        setInvalid(nationalCode, 'وارد نمودن کد ملی اجباری است');
        return false;
    }
    if (nationalCode.value.length != 10) {
        setInvalid(nationalCode, 'کد ملی نادرست است');
        return false;
    }
    var re = /^[0-9]*$/;
    if (!re.test(nationalCode.value)) {
        setInvalid(nationalCode, 'کد ملی باید با کاراکترهای لاتین، بدون حرف و سایر کاراکترها وارد شود.');
        return false;
    }

    if (isNaN(nationalCode.value)) {
        setInvalid(nationalCode, 'کد ملی می بایست عدد باشد');
        return false;
    }
    setValid(nationalCode);
    return true;
//    var nationalCode = document.getElementById('nationalCode');
//    removeValidationEffects(nationalCode);
//    if (nationalCode.value == null || nationalCode.value.trim() == '') {
//        setInvalid(nationalCode, 'وارد نمودن کد ملی/اتباع خارجی اجباری است');
//        return false;
//    }
//    if (nationalCode.value.length != 10 && nationalCode.value.length != 13) {
//        setInvalid(nationalCode, 'کد ملی/اتباع خارجی نادرست است');
//        return false;
//    }
//    setValid(nationalCode);
//    return true;
}
function validateEmail() {
    var email = document.getElementById('email');
    removeValidationEffects(email);
    if (email.value == null || email.value.trim() == '') {
        setInvalid(email, 'وارد نمودن ایمیل اجباری است');
        return false;
    }

    var re = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i;
    if (!re.test(email.value)) {
        setInvalid(email, 'آدرس ایمیل وارد شده صحیح نمی باشد');
        return false;
    }

    setValid(email);
    return true;
}

function validateSerialAlphabet() {
    var serialAlphabet = document.getElementById('serialAlphabet');
    removeValidationEffects(serialAlphabet);
    if (serialAlphabet.value == null || serialAlphabet.value.trim() == '') {
//        setInvalid(serialAlphabet, 'وارد نمودن شماره سریال اجباری است');
//        return false;
        return true;
    }

//    var re = '/^[\u0600-\u065F\u066A-\u06EF\u06FA-\u06FF]*$/';
//    if (!re.test(serialAlphabet.value)) {
//        setInvalid(serialAlphabet, 'بخش آغازین شماره سریال باید از حروف فارسی باشد.');
//        return false;
//    }

    setValid(serialAlphabet);
    return true;
}


function validatePassword() {
    var password = document.getElementById('password');
    removeValidationEffects(password);
    if (password.value == null || password.value.trim() == '') {
        setInvalid(password, 'وارد نمودن گذرواژه اجباری است');
        return false;
    }

    if (password.value.length < 8) {
        setInvalid(password, 'گذرواژه حداقل باید هشت حرف باشد');
        return false;
    }
    if (!passwordComplexityStartChar(password.value)) {
        setInvalid(password, complexityTextStartCharAlphabet);
        return false;
    }
    if (!passwordComplexityUpperCase(password.value)) {
        setInvalid(password, complexityTextUpperCase);
        return false;
    }
    if (!passwordComplexityLowerCase(password.value)) {
        setInvalid(password, complexityTextLowerCase);
        return false;
    }
    if (!passwordComplexityDigit(password.value)) {
        setInvalid(password, complexityTextDigit);
        return false;
    }
    if (!passwordComplexityValidChar(password.value)) {
        setInvalid(password, complexityTextValidChar);
        return false;
    }

    var nationalCode = document.getElementById('nationalCode');
    var firstName = document.getElementById('firstName');
    var lastName = document.getElementById('lastName');

    if (nationalCode.value === null || nationalCode.value === '') {
        setInvalid(password, complexityTextNationalCode);
        return false;
    }
    if (firstName.value === null || firstName.value === '') {
        setInvalid(password, complexityTextFirstName);
        return false;
    }
    if (lastName.value === null || lastName.value === '') {
        setInvalid(password, complexityTextlastName);
        return false;
    }

    if (passwordComplexityNotContainsSomeFields(password.value, firstName.value, lastName.value, nationalCode.value)) {
        setInvalid(password, complexityTextNotContainsSomeFields);
        return false;
    }



//    if (password.value.length < 8) {
//        setInvalid(password, 'گذرواژه حداقل باید هشت حرف باشد');
//        return false;
//    }
//
//    if (!passwordComplexity(password.value)) {
//        setInvalid(password, complexityText);
//        return false;
//    }

    setValid(password);
    return true;
}
function validateRepeatedPassword() {
    var repeatedPassword = document.getElementById('repeatedpassword');
    removeValidationEffects(repeatedPassword);
    if (repeatedPassword.value == null || repeatedPassword.value.trim() == '') {
        setInvalid(repeatedPassword, 'وارد نمودن تکرار گذرواژه اجباری است');
        return false;
    }

    if (repeatedPassword.value.length < 8) {
        setInvalid(repeatedPassword, 'گذرواژه حداقل باید هشت حرف باشد');
        return false;
    }
    if (!passwordComplexityStartChar(repeatedPassword.value)) {
        setInvalid(repeatedPassword, complexityTextStartCharAlphabet);
        return false;
    }
    if (!passwordComplexityUpperCase(repeatedPassword.value)) {
        setInvalid(repeatedPassword, complexityTextUpperCase);
        return false;
    }
    if (!passwordComplexityLowerCase(repeatedPassword.value)) {
        setInvalid(repeatedPassword, complexityTextLowerCase);
        return false;
    }
    if (!passwordComplexityDigit(repeatedPassword.value)) {
        setInvalid(repeatedPassword, complexityTextDigit);
        return false;
    }
    if (!passwordComplexityValidChar(repeatedPassword.value)) {
        setInvalid(repeatedPassword, complexityTextValidChar);
        return false;
    }

    var nationalCode = document.getElementById('nationalCode');
    var firstName = document.getElementById('firstName');
    var lastName = document.getElementById('lastName');

    if (nationalCode.value === null || nationalCode.value === '') {
        setInvalid(repeatedPassword, complexityTextNationalCode);
        return false;
    }
    if (firstName.value === null || firstName.value === '') {
        setInvalid(repeatedPassword, complexityTextFirstName);
        return false;
    }
    if (lastName.value === null || lastName.value === '') {
        setInvalid(repeatedPassword, complexityTextlastName);
        return false;
    }

    if (passwordComplexityNotContainsSomeFields(repeatedPassword.value, firstName.value, lastName.value, nationalCode.value)) {
        setInvalid(repeatedPassword, complexityTextNotContainsSomeFields);
        return false;
    }

//    if (repeatedPassword.value.length < 8) {
//        setInvalid(repeatedPassword, 'گذرواژه حداقل باید هشت حرف باشد');
//        return false;
//    }
//
//    if (!passwordComplexity(repeatedPassword.value)) {
//
//        setInvalid(repeatedPassword, complexityText);
//        return false;
//    }

    setValid(repeatedPassword);
    return true;
}

function validatePasswordsEquality() {
    var password = document.getElementById('password');
    var repeatedPassword = document.getElementById('repeatedpassword');
    if (!hasClass(password, 'valid') && !hasClass(repeatedPassword, 'valid')) {
        return false;
    }

    removeValidationEffects(password);
    removeValidationEffects(repeatedPassword);

    var v1 = repeatedPassword.value;
    var v2 = password.value;
    console.log(v1);
    console.log(v2);
    if (v1 !== v2) {
        console.log(password.value);
        console.log(repeatedPassword.value);
        setInvalid(repeatedPassword, 'گدرواژه و تکرار آن یکسان نمی باشد');
        setInvalid(password, 'گدرواژه و تکرار آن یکسان نمی باشد');
        return false;
    }
    setValid(password);
    setValid(repeatedPassword);
    return true;
}

function validateQuestionEquality() {
    var question1 = document.getElementById('question1');
    var question2 = document.getElementById('question2');
    var question3 = document.getElementById('question3');
    if (!hasClass(question1, 'valid') && !hasClass(question2, 'valid') && !hasClass(question3, 'valid')) {
        return false;
    }

    removeValidationEffects(question1);
    removeValidationEffects(question2);
    removeValidationEffects(question3);

    var v1 = question1.value.trim();
    var v2 = question2.value.trim();
    var v3 = question3.value.trim();
    if (v1 === v2 || v1 === v3 || v2 === v3) {
        setInvalid(question1, 'سوالات امنیتی نمیتوانند یکسان باشند.');
        setInvalid(question2, 'سوالات امنیتی نمیتوانند یکسان باشند.');
        setInvalid(question3, 'سوالات امنیتی نمیتوانند یکسان باشند.');
        return false;
    }
    setValid(question1);
    setValid(question2);
    setValid(question3);
    return true;
}

function validateAnswerEquality() {
    var answer1 = document.getElementById('answer1');
    var answer2 = document.getElementById('answer2');
    var answer3 = document.getElementById('answer3');
    if (!hasClass(answer1, 'valid') && !hasClass(answer2, 'valid') && !hasClass(answer3, 'valid')) {
        return false;
    }

    removeValidationEffects(answer1);
    removeValidationEffects(answer2);
    removeValidationEffects(answer3);

    var v1 = answer1.value.trim();
    var v2 = answer2.value.trim();
    var v3 = answer3.value.trim();
    if (v1 === v2 || v1 === v3 || v2 === v3) {
        setInvalid(answer1, 'پاسخ ها نمیتوانند یکسان باشند.');
        setInvalid(answer2, 'پاسخ ها نمیتوانند یکسان باشند.');
        setInvalid(answer3, 'پاسخ ها نمیتوانند یکسان باشند.');
        return false;
    }
    setValid(answer1);
    setValid(answer2);
    setValid(answer3);
    return true;
}

function validateYearOfBirth() {
    var yearOfBirth = document.getElementById('YearOfBirth');
    removeValidationEffects(yearOfBirth)
    if (yearOfBirth.value == null || yearOfBirth.value.trim() == '') {
        setInvalid(yearOfBirth, 'وارد نمودن سال تولد اجباری است');
        return false;
    }

    if (isNaN(yearOfBirth.value)) {
        setInvalid(yearOfBirth, 'سال تولد می بایست عدد باشد');
        return false;
    }

    if (yearOfBirth.value <= 1250 || yearOfBirth.value >= 2000) {
        setInvalid(yearOfBirth, 'سال تولد می بایست عددی بین ۱۲۵۰ تا ۲۰۰۰ باشد');
        return false;
    }

    setValid(yearOfBirth);
    return true;
}

function validateDayOfBirth() {
//    setInvalid(dayOfBirth, 'روز وارد شده معتبر نمیباشد.');
//            return false;
    var monthOfBirth = document.getElementById('MonthOfBirth');
    var dayOfBirth = document.getElementById('DayOfBirth');
    removeValidationEffects(dayOfBirth)
    if (dayOfBirth.value == null || dayOfBirth.value.trim() == '') {
        setInvalid(dayOfBirth, 'وارد نمودن روز تولد اجباری است');
        return false;
    }

    if (monthOfBirth == "07" || monthOfBirth == '08' || monthOfBirth == '09' || monthOfBirth == '10' || monthOfBirth == '11' || monthOfBirth == '12') {
//        if (dayOfBirth == '31') {
        setInvalid(dayOfBirth, 'روز وارد شده معتبر نمیباشد.');
        return false;
//        }
    }
    setValid(dayOfBirth);
    return true;
}

function validateQuestion1() {
    var question1 = document.getElementById('question1');
    removeValidationEffects(question1)
    if (question1.value == null || question1.value.trim() == '') {
        setInvalid(question1, 'وارد نمودن سوال ۱ اجباری است');
        return false;
    }
    setValid(question1);
    return true;
}

function validateQuestion2() {
    var question2 = document.getElementById('question2');
    removeValidationEffects(question2)
    if (question2.value == null || question2.value.trim() == '') {
        setInvalid(question2, 'وارد نمودن سوال ۲ اجباری است');
        return false;
    }
    setValid(question2);
    return true;
}

function validateQuestion3() {
    var question3 = document.getElementById('question3');
    removeValidationEffects(question3)
    if (question3.value == null || question3.value.trim() == '') {
        setInvalid(question3, 'وارد نمودن سوال ۳ اجباری است');
        return false;
    }
    setValid(question3);
    return true;
}

function validateAnswer1() {
    var answer1 = document.getElementById('answer1');
    removeValidationEffects(answer1)
    if (answer1.value == null || answer1.value.trim() == '') {
        setInvalid(answer1, 'وارد نمودن جواب ۱ اجباری است');
        return false;
    }
    setValid(answer1);
    return true;
}

function validateAnswer2() {
    var answer2 = document.getElementById('answer2');
    removeValidationEffects(answer2)
    if (answer2.value == null || answer2.value.trim() == '') {
        setInvalid(answer2, 'وارد نمودن جواب ۲ اجباری است');
        return false;
    }
    setValid(answer2);
    return true;
}

function validateAnswer3() {
    var answer3 = document.getElementById('answer3');
    removeValidationEffects(answer3)
    if (answer3.value == null || answer3.value.trim() == '') {
        setInvalid(answer3, 'وارد نمودن جواب ۳ اجباری است');
        return false;
    }
    setValid(answer3);
    return true;
}

function passwordComplexityLength(password) {

    if (password.length < 8)
        return false;

}

function passwordComplexityStartChar(password) {

    var hasStartCharAlphabetic = /^[A-Za-z].*$/.test(password);
    return hasStartCharAlphabetic === true;

}

function passwordComplexityUpperCase(password) {

    var hasUpperCase = /[A-Z]/.test(password);
    return hasUpperCase === true;

}

function passwordComplexityLowerCase(password) {

    var hasLowerCase = /[a-z]/.test(password);
    return hasLowerCase === true;

}

function passwordComplexityDigit(password) {

    var hasNumbers = /\d/.test(password);
    return hasNumbers === true;

}

function passwordComplexityValidChar(password) {

    var hasNumbers = /^(")?(?:[^\."])(?:(?:[\.])?(?:[\w\-!#$%&'*+\/=?\^_`{|}~]))*$/.test(password);
    return hasNumbers === true;

}

function passwordComplexityNotContainsSomeFields(password, firstName, lastName, nationalCode) {

//    var nationalCode = document.getElementById('nationalCode').value;
//    var firstName = document.getElementById('firstName').value;
//    var lastName = document.getElementById('lastName').value;
//    
//    if (nationalCode === null || nationalCode === ''){
//        return false;
//    }
//    if (hasLastName === null || hasLastName === ''){
//        return false;
//    }
//    if (hasFistNaame === null || hasFistNaame === ''){
//        return false;
//    }

//    var hasNatCode = password.indexOf(nationalCode) !== -1;
//    console.log('hasNatCode');
//    console.log(password.indexOf(nationalCode));
//    console.log(hasNatCode);
//    var hasFistNaame = password.indexOf(firstName) !== -1;
//    console.log('hasFistNaame');
//    console.log(password.indexOf(firstName));
//    console.log(hasFistNaame);
//    var hasLastName = password.indexOf(lastName) !== -1;
//    console.log('hasLastName');
//    console.log(password.indexOf(lastName));
//    console.log(hasLastName);
//    console.log('jam');
//    console.log(hasFistNaame + hasLastName + hasNatCode);
//    console.log('kol');
//    console.log(hasFistNaame + hasLastName + hasNatCode !== 0);
//    return hasFistNaame + hasLastName + hasNatCode !== 0;
    var hasNatCode = password.indexOf(nationalCode);
    if (hasNatCode !== -1)
        return true;
    var hasFistNaame = password.indexOf(firstName);
    if (hasFistNaame !== -1)
        return true;
    var hasLastName = password.indexOf(lastName);
    if (hasLastName !== -1)
        return true;
    return false;
}

function passwordComplexity(password) {

    if (password.length < 8)
        return false;

    var hasUpperCase = /[A-Z]/.test(password);
    var hasLowerCase = /[a-z]/.test(password);
    var hasNumbers = /\d/.test(password);
    return hasUpperCase + hasLowerCase + hasNumbers === 3;

}

function setInvalid(elem, msg) {
    elem.parentNode.setAttribute('data-hint', msg);
    addClass(elem.parentNode, 'hint--left hint--error');
    addClass(elem, 'invalid');
}
function setValid(elem) {
    addClass(elem, 'valid');
}
function removeValidationEffects(elem) {
    removeClass(elem, 'valid');
    removeClass(elem, 'invalid');
    removeClass(elem.parentNode, 'hint--left hint--error');
    elem.parentNode.removeAttribute('data-hint');
}
function myMethod(elem) {
    var country = document.getElementById('country');
    var fetchCity = document.getElementById('fetchCity');
    fetchCity.value = "true";
    setInvalid(country, country.value);
    var theForm = document.forms[0];
    theForm.submit();
}
function showResponse(originalRequest)
{
    setInvalid(country, 'finito');
//    var list = $('city');
//    var xmlString = originalRequest.responseXML;
//    var items = xmlString.getElementsByTagName('labelValueBean');
//    clearList(list);
//    if (items.length > 0)
//    {
//        for (var i = 0; i < items.length; i++)
//        {
//            var node = items[i];
//            var value = "";
//            var label = "";
//            if (node.getElementsByTagName("label")[0].firstChild.nodeValue) {
//                value = node.getElementsByTagName("label")[0].firstChild.nodeValue;
//                label = node.getElementsByTagName("value")[0].firstChild.nodeValue;
//            }
//            addElementToList(list, value, label);
//        }
//    }
//    else
//    {
//        addElementToList(list, "", "-- Select is Empty --");
//    }
}

* persianjs
Ext.define('Tamin.helpers.Persian', {
    requires:['Tamin.PDate'],
    statics: {
        persianToGregorian: function (pdate) {
            var ymd = pdate.split('/');
            var tmp = Tamin.PDate.PersianToGregorian(ymd[0], ymd[1], ymd[2]);
            return new Date(tmp[0],tmp[1] - 1, tmp[2]);
        },
        gregorianToPersian: function (date) {
            function setLeadingZero(str) {
                if (isNaN(str)) return str;
                if (Number(str) > 0 && Number(str) <= 9) return '0' + str;
                return str;
            }

            var year = date.getFullYear();
            var month = date.getMonth() + 1;
            var day = date.getDate();
            var tmp = Tamin.PDate.GregorianToPersian(year, month, day);
            return tmp[0] + '/' + setLeadingZero(tmp[1]) + '/' + setLeadingZero(tmp[2]);
        },
        gregorianToPersianWithTime: function (date) {
            function setLeadingZero(str) {
                if (isNaN(str)) return str;
                if (Number(str) > 0 && Number(str) <= 9) return '0' + str;
                return str;
            }

            var year = date.getFullYear();
            var month = date.getMonth() + 1;
            var day = date.getDate();
            var tmp = Tamin.PDate.GregorianToPersian(year, month, day);
            var time = setLeadingZero(date.getHours()) + ':' + setLeadingZero(date.getMinutes()) + ':' + setLeadingZero(date.getSeconds());
            return time + ' ' + tmp[0] + '/' + setLeadingZero(tmp[1]) + '/' + setLeadingZero(tmp[2]);
        },
        taminDateToGregorian: function (value) {
            
            if (value == null || value.length != 8 || isNaN(value)) return null;
            var y = value.substring(0, 4);
            var m = value.substring(4, 6);
            var d = value.substring(6, 8);
            var tmp = Tamin.PDate.PersianToGregorian(y, m, d);
            return new Date(tmp[0], tmp[1], tmp[2]);
        }

    }
});
**********************************************8
Ext.define('Tamin.PDate', {
    statics: {
        g_days_in_month: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        j_days_in_month: [31, 31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 29],

        PersianToGregorian: function (jy, jm, jd) {

            var jy = parseInt(jy) - 979,
                jm = parseInt(jm) - 1,
                jd = parseInt(jd) - 1,
                j_day_no = 365 * jy + parseInt(jy / 33) * 8 + parseInt((jy % 33 + 3) / 4),
                g_day_no,
                leap,
                gm;

            for (var i = 0; i < jm; ++i)
                j_day_no += Tamin.PDate.j_days_in_month[i];

            j_day_no += jd;

            g_day_no = j_day_no + 79,
                gy = 1600 + 400 * parseInt(g_day_no / 146097);
            /* 146097 = 365*400 + 400/4 - 400/100 + 400/400 */
            g_day_no = g_day_no % 146097;

            leap = true;
            if (g_day_no >= 36525) /* 36525 = 365*100 + 100/4 */ {
                g_day_no--;
                gy += 100 * parseInt(g_day_no / 36524);
                /* 36524 = 365*100 + 100/4 - 100/100 */
                g_day_no = g_day_no % 36524;

                if (g_day_no >= 365)
                    g_day_no++;
                else
                    leap = false;
            }

            gy += 4 * parseInt(g_day_no / 1461);
            /* 1461 = 365*4 + 4/4 */
            g_day_no %= 1461;

            if (g_day_no >= 366) {
                leap = false;

                g_day_no--;
                gy += parseInt(g_day_no / 365);
                g_day_no = g_day_no % 365;
            }

            for (var i = 0; g_day_no >= Tamin.PDate.g_days_in_month[i] + (i == 1 && leap); i++)
                g_day_no -= Tamin.PDate.g_days_in_month[i] + (i == 1 && leap);
            gm = i + 1,
                gd = g_day_no + 1;

            return [gy, gm, gd];
        },
        GregorianToPersian: function (gy, gm, gd) {
            var gy = parseInt(gy) - 1600,
                gm = parseInt(gm) - 1,
                gd = parseInt(gd) - 1,
                g_day_no = 365 * gy + parseInt((gy + 3) / 4) - parseInt((gy + 99) / 100) + parseInt((gy + 399) / 400),
                j_day_no,
                jy,
                jm;

            for (var i = 0; i < gm; ++i)
                g_day_no += Tamin.PDate.g_days_in_month[i];
            if (gm > 1 && ((gy % 4 == 0 && gy % 100 != 0) || (gy % 400 == 0)))
            /* leap and after Feb */
                ++g_day_no;
            g_day_no += gd;

            j_day_no = g_day_no - 79,
                j_np = parseInt(j_day_no / 12053);
            j_day_no %= 12053;

            jy = 979 + 33 * j_np + 4 * parseInt(j_day_no / 1461);

            j_day_no %= 1461;

            if (j_day_no >= 366) {
                jy += parseInt((j_day_no - 1) / 365);
                j_day_no = (j_day_no - 1) % 365;
            }

            for (var i = 0; i < 11 && j_day_no >= Tamin.PDate.j_days_in_month[i]; ++i) {
                j_day_no -= Tamin.PDate.j_days_in_month[i];
            }
            jm = i + 1,
                jd = j_day_no + 1;

            return [jy, jm, jd];
        },
        setFullYear: function (date, y, m, d) {
            var gd = date.getDate(),
                gm = date.getMonth(),
                gy = date.getFullYear(),
                j = Tamin.PDate.GregorianToPersian(gy, gm + 1, gd);

            if (y < 100)
                y += 1300;

            j[0] = y;
            if (m != undefined) {
                if (m > 11) {
                    j[0] += Math.floor(m / 11);
                    j[1] = (m % 11);
                } else if (m < 0) {
                    j[0] += Math.floor(m / 11);
                    j[1] = (m % 11) + 13;
                } else
                    j[1] = m + 1;

            }
            if (d != undefined)
                j[2] = d;
            var g = Tamin.PDate.PersianToGregorian(j[0], j[1], j[2]);
            return date.setFullYear(g[0], g[1] - 1, g[2]);
        },
        setMonth: function (date, m, d) {
            var gd = date.getDate(),
                gm = date.getMonth(),
                gy = date.getFullYear(),
                j = Tamin.PDate.GregorianToPersian(gy, gm + 1, gd);
            if (m > 11) {
                j[0] += Math.floor(m / 11);
                j[1] = (m % 11);

            } else if (m < 0) {
                j[0] -= Math.floor((-m) / 11);
                j[0] -= 1;
                j[1] = (m % 11) + 13;
            } else {
                j[1] = m + 1;
            }

            if (d != undefined)
                j[2] = d;

            var g = Tamin.PDate.PersianToGregorian(j[0], j[1], j[2]);
            return date.setFullYear(g[0], g[1] - 1, g[2]);
        },

        setDate: function (date, d) {
            var gd = date.getDate(),
                gm = date.getMonth(),
                gy = date.getFullYear(),
                j = Tamin.PDate.GregorianToPersian(gy, gm + 1, gd);
            j[2] = d;

            var g = Tamin.PDate.PersianToGregorian(j[0], j[1], j[2]);
            return date.setFullYear(g[0], g[1] - 1, g[2]);
        },
        getFullYear: function (date) {
            var gd = date.getDate(),
                gm = date.getMonth(),
                gy = date.getFullYear(),
                j = Tamin.PDate.GregorianToPersian(gy, gm + 1, gd);
            return j[0];
        },
        getMonth: function (date) {
            var gd = date.getDate(),
                gm = date.getMonth(),
                gy = date.getFullYear(),
                j = Tamin.PDate.GregorianToPersian(gy, gm + 1, gd);
            return j[1] - 1;
        },
        getDate: function (date) {
            var gd = date.getDate(),
                gm = date.getMonth(),
                gy = date.getFullYear(),
                j = Tamin.PDate.GregorianToPersian(gy, gm + 1, gd);
            return j[2];
        },
        getDay: function (date) {
            var day = date.getDay();
            day = (day + 1) % 7;
            return day;
        },
        /**
         * Persian UTC functions
         */

        getUTCFullYear: function (date) {
            var gd = date.getUTCDate(),
                gm = date.getUTCMonth(),
                gy = date.getUTCFullYear(),
                j = Tamin.PDate.GregorianToPersian(gy, gm + 1, gd);
            return j[0];
        },
        getUTCMonth: function (date) {
            var gd = date.getUTCDate(),
                gm = date.getUTCMonth(),
                gy = date.getUTCFullYear(),
                j = Tamin.PDate.GregorianToPersian(gy, gm + 1, gd);
            return j[1] - 1;
        },
        getUTCDate: function (date) {
            var gd = date.getUTCDate(),
                gm = date.getUTCMonth(),
                gy = date.getUTCFullYear(),
                j = Tamin.PDate.GregorianToPersian(gy, gm + 1, gd);
            return j[2];
        },
        getUTCDay: function (date) {
            var day = date.getUTCDay();
            day = (day + 1) % 7;
            return day;
        },
        /**
         * Returns the current timestamp
         * @return {Number} The current timestamp
         * @method
         */
        now: Ext.Date.now,

        /**
         * @private
         * Private for now
         */
        toString: function (date) {
            var pad = Ext.String.leftPad;

            return Tamin.PDate.getFullYear(date) + "-"
                + pad(Tamin.PDate.getMonth(date) + 1, 2, '0') + "-"
                + pad(Tamin.PDate.getDate(date), 2, '0') + "T"
                + pad(date.getHours(), 2, '0') + ":"
                + pad(date.getMinutes(), 2, '0') + ":"
                + pad(date.getSeconds(), 2, '0');
        },
        /**
         * Returns the number of milliseconds between two dates
         * @param {Date} dateA The first date
         * @param {Date} dateB (optional) The second date, defaults to now
         * @return {Number} The difference in milliseconds
         */
        getElapsed: Ext.Date.getElapsed,

        /**
         * Global flag which determines if strict date parsing should be used.
         * Strict date parsing will not roll-over invalid dates, which is the
         * default behaviour of javascript Date objects.
         * (see {@link #parse} for more information)
         * Defaults to <tt>false</tt>.
         * @static
         * @type Boolean
         */
        useStrict: Ext.Date.useStrict,

        // private
        formatCodeToRegex: function (character, currentGroup) {
            // Note: currentGroup - position in regex result array (see notes for Ext.Date.parseCodes below)
            var p = utilPDate.parseCodes[character];

            if (p) {
                p = typeof p == 'function' ? p() : p;
                utilPDate.parseCodes[character] = p; // reassign function result to prevent repeated execution
            }

            return p ? Ext.applyIf({
                c: p.c ? xf(p.c, currentGroup || "{0}") : p.c
            }, p) : {
                g: 0,
                c: null,
                s: Ext.String.escapeRegex(character) // treat unrecognised characters as literals
            };
        },
        /**
         * <p>An object hash in which each property is a date parsing function. The property name is the
         * format string which that function parses.</p>
         * <p>This object is automatically populated with date parsing functions as
         * date formats are requested for Ext standard formatting strings.</p>
         * <p>Custom parsing functions may be inserted into this object, keyed by a name which from then on
         * may be used as a format string to {@link #parse}.<p>
         * <p>Example:</p><pre><code>
         Tamin.PDate.parseFunctions['x-date-format'] = myDateParser;
         </code></pre>
         * <p>A parsing function should return a Date object, and is passed the following parameters:<div class="mdetail-params"><ul>
         * <li><code>date</code> : String<div class="sub-desc">The date string to parse.</div></li>
         * <li><code>strict</code> : Boolean<div class="sub-desc">True to validate date strings while parsing
         * (i.e. prevent javascript Date "rollover") (The default must be false).
         * Invalid date strings should return null when parsed.</div></li>
         * </ul></div></p>
         * <p>To enable Dates to also be <i>formatted</i> according to that format, a corresponding
         * formatting function must be placed into the {@link #formatFunctions} property.
         * @property parseFunctions
         * @static
         * @type Object
         */
        parseFunctions: {
            "MS": function (input, strict) {
                // note: the timezone offset is ignored since the MS Ajax server sends
                // a UTC milliseconds-since-Unix-epoch value (negative values are allowed)
                var re = new RegExp('\\/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\/'),
                    r = (input || '').match(re);
                return r ? new Date(((r[1] || '') + r[2]) * 1) : null;
            }
        },
        parseRegexes: [],

        /**
         * <p>An object hash in which each property is a date formatting function. The property name is the
         * format string which corresponds to the produced formatted date string.</p>
         * <p>This object is automatically populated with date formatting functions as
         * date formats are requested for Ext standard formatting strings.</p>
         * <p>Custom formatting functions may be inserted into this object, keyed by a name which from then on
         * may be used as a format string to {@link #format}. Example:</p><pre><code>
         Tamin.PDate.formatFunctions['x-date-format'] = myDateFormatter;
         </code></pre>
         * <p>A formatting function should return a string representation of the passed Date object, and is passed the following parameters:<div class="mdetail-params"><ul>
         * <li><code>date</code> : Date<div class="sub-desc">The Date to format.</div></li>
         * </ul></div></p>
         * <p>To enable date strings to also be <i>parsed</i> according to that format, a corresponding
         * parsing function must be placed into the {@link #parseFunctions} property.
         * @property formatFunctions
         * @static
         * @type Object
         */
        formatFunctions: {
            "MS": function () {
                // UTC milliseconds since Unix epoch (MS-AJAX serialized date format (MRSF))
                return '\\/Date(' + this.getTime() + ')\\/';
            }
        },

        y2kYear: 50,

        /**
         * Date interval constant
         * @static
         * @type String
         */
        MILLI: "ms",

        /**
         * Date interval constant
         * @static
         * @type String
         */
        SECOND: "s",

        /**
         * Date interval constant
         * @static
         * @type String
         */
        MINUTE: "mi",

        /** Date interval constant
         * @static
         * @type String
         */
        HOUR: "h",

        /**
         * Date interval constant
         * @static
         * @type String
         */
        DAY: "d",

        /**
         * Date interval constant
         * @static
         * @type String
         */
        MONTH: "mo",

        /**
         * Date interval constant
         * @static
         * @type String
         */
        YEAR: "y",

        /**
         * <p>An object hash containing default date values used during date parsing.</p>
         * <p>The following properties are available:<div class="mdetail-params"><ul>
         * <li><code>y</code> : Number<div class="sub-desc">The default year value. (defaults to undefined)</div></li>
         * <li><code>m</code> : Number<div class="sub-desc">The default 1-based month value. (defaults to undefined)</div></li>
         * <li><code>d</code> : Number<div class="sub-desc">The default day value. (defaults to undefined)</div></li>
         * <li><code>h</code> : Number<div class="sub-desc">The default hour value. (defaults to undefined)</div></li>
         * <li><code>i</code> : Number<div class="sub-desc">The default minute value. (defaults to undefined)</div></li>
         * <li><code>s</code> : Number<div class="sub-desc">The default second value. (defaults to undefined)</div></li>
         * <li><code>ms</code> : Number<div class="sub-desc">The default millisecond value. (defaults to undefined)</div></li>
         * </ul></div></p>
         * <p>Override these properties to customize the default date values used by the {@link #parse} method.</p>
         * <p><b>Note: In countries which experience Daylight Saving Time (i.e. DST), the <tt>h</tt>, <tt>i</tt>, <tt>s</tt>
         * and <tt>ms</tt> properties may coincide with the exact time in which DST takes effect.
         * It is the responsiblity of the developer to account for this.</b></p>
         * Example Usage:
         * <pre><code>
         // set default day value to the first day of the month
         Tamin.PDate.defaults.d = 1;

         // parse a February date string containing only year and month values.
         // setting the default day value to 1 prevents weird date rollover issues
         // when attempting to parse the following date string on, for example, March 31st 2009.
         Tamin.PDate.parse('2009-02', 'Y-m'); // returns a Date object representing February 1st 2009
         </code></pre>
         * @property defaults
         * @static
         * @type Object
         */
        defaults: {},

        /**
         * An array of textual day names.
         * Override these values for international dates.
         * Example:
         * <pre><code>
         Tamin.PDate.dayNames = [
         'SundayInYourLang',
         'MondayInYourLang',
         ...
         ];
         </code></pre>
         * @type Array
         * @static
         */
        dayNames: Ext.Date.dayNames,

        //<locale type="array">
        /**
         * An array of textual month names.
         * Override these values for international dates.
         * Example:
         * <pre><code>
         Tamin.PDate.monthNames = [
         'FarvardinInYourLang',
         'OrdibeheshtInYourLang',
         ...
         ];
         </code></pre>
         * @type Array
         * @static
         */
        monthNames: [
            "فروردین",
            "اردیبهشت",
            "خرداد",
            "تیر",
            "مرداد",
            "شهریور",
            "مهر",
            "آبان",
            "آذر",
            "دی",
            "بهمن",
            "اسفند"
        ],

        //</locale>
        //<locale type="array">
        /**
         * An object hash of zero-based javascript month numbers (with short month names as keys. note: keys are case-sensitive).
         * Override these values for international dates.
         * Example:
         * <pre><code>
         Tamin.PDate.monthNumbers = {
		 'ShortFarNameInYourLang':0,
		 'ShortOrdNameInYourLang':1,
		 ...
		 };
         </code></pre>
         * @type Object
         * @static
         */
        monthNumbers: {
            Far: 0,
            Farvardin: 0,
            Ord: 1,
            Ordibehesht: 1,
            Kho: 2,
            Khordad: 2,
            Tir: 3,
            Mor: 4,
            Mordad: 4,
            Sha: 5,
            Shahrivar: 5,
            Meh: 6,
            Mehr: 6,
            Aba: 7,
            Aban: 7,
            Aza: 8,
            Azar: 8,
            Dey: 9,
            Bah: 10,
            Bahman: 10,
            Esf: 11,
            Esfand: 11
        },
        //</locale>

        //<locale>
        /**
         * <p>The date format string that the {@link Ext.util.Format#dateRenderer}
         * and {@link Ext.util.Format#date} functions use.  See {@link     Tamin.PDate} for details.</p>
         * <p>This defaults to <code>m/d/Y</code>, but may be overridden in a locale file.</p>
         * @property defaultFormat
         * @static
         * @type String
         */
        defaultFormat: "Y/m/d",
        //</locale>

        /**
         * Get the short month name for the given month number.
         * Override this function for international dates.
         * @param {Number} month A zero-based javascript month number.
         * @return {String} The short month name.
         * @static
         */
        getShortMonthName: function (month) {
            return Tamin.PDate.monthNames[month].substring(0, 3);
        },
        //</locale>

        //<locale type="function">
        /**
         * Get the short day name for the given day number.
         * Override this function for international dates.
         * @param {Number} day A zero-based javascript day number.
         * @return {String} The short day name.
         * @static
         */
        //</locale>

        //<locale type="function">
        getShortDayName: function (day) {
            return Tamin.PDate.dayNames[day].substring(0, 3);
        },
        //</locale>

        //<locale type="function">
        /**
         * Get the zero-based javascript month number for the given short/full month name.
         * Override this function for international dates.
         * @param {String} name The short/full month name.
         * @return {Number} The zero-based javascript month number.
         * @static
         */
        //</locale>

        //<locale type="function">
        getMonthNumber: function (name) {
            // handle camel casing for english month names (since the keys for the     Tamin.PDate.monthNumbers hash are case sensitive)
            return Tamin.PDate.monthNumbers[name.substring(0, 1).toUpperCase() + name.substring(1, 3).toLowerCase()];
        },
        //</locale>

        /**
         * Checks if the specified format contains hour information
         * @param {String} format The format to check
         * @return {Boolean} True if the format contains hour information
         * @static
         * @method
         */
        formatContainsHourInfo: (function () {
            var stripEscapeRe = /(\\.)/g,
                hourInfoRe = /([gGhHisucUOPZ]|MS)/;
            return function (format) {
                return hourInfoRe.test(format.replace(stripEscapeRe, ''));
            };
        }()),
        /**
         * Checks if the specified format contains information about
         * anything other than the time.
         * @param {String} format The format to check
         * @return {Boolean} True if the format contains information about
         * date/day information.
         * @static
         * @method
         */
        formatContainsDateInfo: (function () {
            var stripEscapeRe = /(\\.)/g,
                dateInfoRe = /([djzmnYycU]|MS)/;

            return function (format) {
                return dateInfoRe.test(format.replace(stripEscapeRe, ''));
            };
        }()),

        /**
         * Removes all escaping for a date format string. In date formats,
         * using a '\' can be used to escape special characters.
         * @param {String} format The format to unescape
         * @return {String} The unescaped format
         * @method
         */
        unescapeFormat: (function () {
            var slashRe = /\\/gi;
            return function (format) {
                // Escape the format, since \ can be used to escape special
                // characters in a date format. For example, in a spanish
                // locale the format may be: 'd \\de F \\de Y'
                return format.replace(slashRe, '');
            }
        }()),
        /**
         * The base format-code to formatting-function hashmap used by the {@link #format} method.
         * Formatting functions are strings (or functions which return strings) which
         * will return the appropriate value when evaluated in the context of the Date object
         * from which the {@link #format} method is called.
         * Add to / override these mappings for custom date formatting.
         * Note:     Tamin.PDate.format() treats characters as literals if an appropriate mapping cannot be found.
         * Example:
         * <pre><code>
         Tamin.PDate.formatCodes.x = "Ext.util.Format.leftPad(this.getDate(), 2, '0')";
         console.log(    Tamin.PDate.format(new Date(), 'X'); // returns the current day of the month
         </code></pre>
         * @type Object
         * @static
         */
        formatCodes: {
            d: "Ext.String.leftPad(    Tamin.PDate.getDate(this), 2, '0')",
            D: "    Tamin.PDate.getShortDayName(this.getDay())", // get localised short day name
            j: "    Tamin.PDate.getDate(this)",
            l: "    Tamin.PDate.dayNames[this.getDay()]",
            N: "(this.getDay() ? this.getDay() : 7)",
            S: "    Tamin.PDate.getSuffix(this)",
            w: "this.getDay()",
            z: "    Tamin.PDate.getDayOfYear(this)",
            W: "Ext.String.leftPad(    Tamin.PDate.getWeekOfYear(this), 2, '0')",
            F: "    Tamin.PDate.monthNames[    Tamin.PDate.getMonth(this)]",
            m: "Ext.String.leftPad(    Tamin.PDate.getMonth(this) + 1, 2, '0')",
            M: "    Tamin.PDate.getShortMonthName(    Tamin.PDate.getMonth(this))", // get localised short month name
            n: "(    Tamin.PDate.getMonth(this) + 1)",
            t: "    Tamin.PDate.getDaysInMonth(this)",
            L: "(    Tamin.PDate.isLeapYear(this) ? 1 : 0)",
            o: "(    Tamin.PDate.getFullYear(this) + (    Tamin.PDate.getWeekOfYear(this) == 1 &&     Tamin.PDate.getMonth(this) > 0 ? +1 : (    Tamin.PDate.getWeekOfYear(this) >= 52 &&     Tamin.PDate.getMonth(this) < 11 ? -1 : 0)))",
            Y: "Ext.String.leftPad(    Tamin.PDate.getFullYear(this), 4, '0')",
            y: "('' +     Tamin.PDate.getFullYear(this)).substring(2, 4)",
            a: "(this.getHours() < 12 ? 'am' : 'pm')",
            A: "(this.getHours() < 12 ? 'AM' : 'PM')",
            g: "((this.getHours() % 12) ? this.getHours() % 12 : 12)",
            G: "this.getHours()",
            h: "Ext.String.leftPad((this.getHours() % 12) ? this.getHours() % 12 : 12, 2, '0')",
            H: "Ext.String.leftPad(this.getHours(), 2, '0')",
            i: "Ext.String.leftPad(this.getMinutes(), 2, '0')",
            s: "Ext.String.leftPad(this.getSeconds(), 2, '0')",
            u: "Ext.String.leftPad(this.getMilliseconds(), 3, '0')",
            O: "    Tamin.PDate.getGMTOffset(this)",
            P: "Ext.{Date.getGMTOffset(this, true)",
            T: "    Tamin.PDate.getTimezone(this)",
            Z: "(this.getTimezoneOffset() * -60)",

            c: function () { // ISO-8601 -- GMT format
                var c, code, i, l, e;
                for (c = "Y-m-dTH:i:sP", code = [], i = 0, l = c.length; i < l; ++i) {
                    e = c.charAt(i);
                    code.push(e == "T" ? "'T'" : utilPDate.getFormatCode(e)); // treat T as a character literal
                }
                return code.join(" + ");
            },
            /*
             c: function() { // ISO-8601 -- UTC format
             return [
             "this.getUTCFullYear()", "'-'",
             "Ext.util.Format.leftPad(this.getUTCMonth() + 1, 2, '0')", "'-'",
             "Ext.util.Format.leftPad(this.getUTCDate(), 2, '0')",
             "'T'",
             "Ext.util.Format.leftPad(this.getUTCHours(), 2, '0')", "':'",
             "Ext.util.Format.leftPad(this.getUTCMinutes(), 2, '0')", "':'",
             "Ext.util.Format.leftPad(this.getUTCSeconds(), 2, '0')",
             "'Z'"
             ].join(" + ");
             },
             */

            U: "Math.round(this.getTime() / 1000)"
        },

        /**
         * Checks if the passed Date parameters will cause a javascript Date "rollover".
         * @param {Number} year 4-digit year
         * @param {Number} month 1-based month-of-year
         * @param {Number} day Day of month
         * @param {Number} hour (optional) Hour
         * @param {Number} minute (optional) Minute
         * @param {Number} second (optional) Second
         * @param {Number} millisecond (optional) Millisecond
         * @return {Boolean} true if the passed parameters do not cause a Date "rollover", false otherwise.
         * @static
         */
        isValid: Ext.Date.isValid,

        /**
         * Parses the passed string using the specified date format.
         * Note that this function expects normal calendar dates, meaning that months are 1-based (i.e. 1 = January).
         * The {@link #defaults} hash will be used for any date value (i.e. year, month, day, hour, minute, second or millisecond)
         * which cannot be found in the passed string. If a corresponding default date value has not been specified in the {@link #defaults} hash,
         * the current date's year, month, day or DST-adjusted zero-hour time value will be used instead.
         * Keep in mind that the input date string must precisely match the specified format string
         * in order for the parse operation to be successful (failed parse operations return a null value).
         * <p>Example:</p><pre><code>
         //dt = Fri May 25 2007 (current date)
         var dt = new Date();

         //dt = Thu May 25 2006 (today&#39;s month/day in 2006)
         dt =     Tamin.PDate.parse("2006", "Y");

         //dt = Sun Jan 15 2006 (all date parts specified)
         dt =     Tamin.PDate.parse("2006-01-15", "Y-m-d");

         //dt = Sun Jan 15 2006 15:20:01
         dt =     Tamin.PDate.parse("2006-01-15 3:20:01 PM", "Y-m-d g:i:s A");

         // attempt to parse Sun Feb 29 2006 03:20:01 in strict mode
         dt =     Tamin.PDate.parse("2006-02-29 03:20:01", "Y-m-d H:i:s", true); // returns null
         </code></pre>
         * @param {String} input The raw date string.
         * @param {String} format The expected date string format.
         * @param {Boolean} strict (optional) True to validate date strings while parsing (i.e. prevents javascript Date "rollover")
         (defaults to false). Invalid date strings will return null when parsed.
         * @return {Date} The parsed Date.
         * @static
         */
        parse: function (input, format, strict) {
            var p = utilPDate.parseFunctions;
            if (p[format] == null) {
                utilPDate.createParser(format);
            }
            return p[format](input, Ext.isDefined(strict) ? strict : utilPDate.useStrict);
        },
        // Backwards compat
        parseDate: function (input, format, strict) {
            return utilPDate.parse(input, format, strict);
        },
        // private
        getFormatCode: function (character) {
            var f = utilPDate.formatCodes[character];

            if (f) {
                f = typeof f == 'function' ? f() : f;
                utilPDate.formatCodes[character] = f; // reassign function result to prevent repeated execution
            }

            // note: unknown characters are treated as literals
            return f || ("'" + Ext.String.escape(character) + "'");
        },
        // private
        createFormat: function (format) {
            var code = [],
                special = false,
                ch = '',
                i;

            for (i = 0; i < format.length; ++i) {
                ch = format.charAt(i);
                if (!special && ch == "\\") {
                    special = true;
                } else if (special) {
                    special = false;
                    code.push("'" + Ext.String.escape(ch) + "'");
                } else {
                    code.push(utilPDate.getFormatCode(ch));
                }
            }
            utilPDate.formatFunctions[format] = Ext.functionFactory("return " + code.join('+'));
        },
        // private
        createParser: (function () {
            var code = [
                "var dt, y, m, d, h, i, s, ms, o, z, zz, u, v,",
                "def =     Tamin.PDate.defaults,",
                "results = String(input).match(    Tamin.PDate.parseRegexes[{0}]);", // either null, or an array of matched strings

                "if(results){",
                "{1}",

                "if(u != null){", // i.e. unix time is defined
                "v = new Date(u * 1000);", // give top priority to UNIX time
                "}else{",
                // create Date object representing midnight of the current day;
                // this will provide us with our date defaults
                // (note: clearTime() handles Daylight Saving Time automatically)
                "dt =     Tamin.PDate.clearTime(new Date);",

                // date calculations (note: these calculations create a dependency on Ext.Number.from())
                "y = Ext.Number.from(y, Ext.Number.from(def.y,     Tamin.PDate.getFullYear(dt)));",
                "m = Ext.Number.from(m, Ext.Number.from(def.m - 1,     Tamin.PDate.getMonth(dt)));",
                "d = Ext.Number.from(d, Ext.Number.from(def.d,     Tamin.PDate.getDate(dt)));",

                // time calculations (note: these calculations create a dependency on Ext.Number.from())
                "h  = Ext.Number.from(h, Ext.Number.from(def.h, dt.getHours()));",
                "i  = Ext.Number.from(i, Ext.Number.from(def.i, dt.getMinutes()));",
                "s  = Ext.Number.from(s, Ext.Number.from(def.s, dt.getSeconds()));",
                "ms = Ext.Number.from(ms, Ext.Number.from(def.ms, dt.getMilliseconds()));",
                "gm=    Tamin.PDate.PersianToGregorian(y, m+1, d);y=gm[0];m=gm[1]-1;d=gm[2];",

                "if(z >= 0 && y >= 0){",
                // both the year and zero-based day of year are defined and >= 0.
                // these 2 values alone provide sufficient info to create a full date object

                // create Date object representing January 1st for the given year
                // handle years < 100 appropriately
                "v = Ext.Date.add(new Date(y < 100 ? 100 : y, 0, 1, h, i, s, ms), Ext.Date.YEAR, y < 100 ? y - 100 : 0);",

                // then add day of year, checking for Date "rollover" if necessary
                "v = !strict? v : (strict === true && (z <= 364 || (Ext.Date.isLeapYear(v) && z <= 365))? Ext.Date.add(v, Ext.Date.DAY, z) : null);",
                "}else if(strict === true && !Ext.Date.isValid(y, m + 1, d, h, i, s, ms)){", // check for Date "rollover"
                "v = null;", // invalid date, so return null
                "}else{",
                // plain old Date object
                // handle years < 100 properly
                "v = Ext.Date.add(new Date(y < 100 ? 100 : y, m, d, h, i, s, ms), Ext.Date.YEAR, y < 100 ? y - 100 : 0);",
                "}",
                "}",
                "}",

                "if(v){",
                // favour UTC offset over GMT offset
                "if(zz != null){",
                // reset to UTC, then add offset
                "v = Ext.Date.add(v, Ext.Date.SECOND, -v.getTimezoneOffset() * 60 - zz);",
                "}else if(o){",
                // reset to GMT, then add offset
                "v = Ext.Date.add(v, Ext.Date.MINUTE, -v.getTimezoneOffset() + (sn == '+'? -1 : 1) * (hr * 60 + mn));",
                "}",
                "}",

                "return v;"
            ].join('\n');

            return function (format) {
                var regexNum = utilPDate.parseRegexes.length,
                    currentGroup = 1,
                    calc = [],
                    regex = [],
                    special = false,
                    ch = "",
                    i = 0,
                    len = format.length,
                    atEnd = [],
                    obj;

                for (; i < len; ++i) {
                    ch = format.charAt(i);
                    if (!special && ch == "\\") {
                        special = true;
                    } else if (special) {
                        special = false;
                        regex.push(Ext.String.escape(ch));
                    } else {
                        obj = utilPDate.formatCodeToRegex(ch, currentGroup);
                        currentGroup += obj.g;
                        regex.push(obj.s);
                        if (obj.g && obj.c) {
                            if (obj.calcAtEnd) {
                                atEnd.push(obj.c);
                            } else {
                                calc.push(obj.c);
                            }
                        }
                    }
                }


                calc = calc.concat(atEnd);

                utilPDate.parseRegexes[regexNum] = new RegExp("^" + regex.join('') + "$", 'i');
                utilPDate.parseFunctions[format] = Ext.functionFactory("input", "strict", xf(code, regexNum, calc.join('')));
            };
        }()),
        // private
        parseCodes: {
            /*
             * Notes:
             * g = {Number} calculation group (0 or 1. only group 1 contributes to date calculations.)
             * c = {String} calculation method (required for group 1. null for group 0. {0} = currentGroup - position in regex result array)
             * s = {String} regex pattern. all matches are stored in results[], and are accessible by the calculation mapped to 'c'
             */
            d: {
                g: 1,
                c: "d = parseInt(results[{0}], 10);\n",
                s: "(3[0-1]|[1-2][0-9]|0[1-9])" // day of month with leading zeroes (01 - 31)
            },
            j: {
                g: 1,
                c: "d = parseInt(results[{0}], 10);\n",
                s: "(3[0-1]|[1-2][0-9]|[1-9])" // day of month without leading zeroes (1 - 31)
            },
            D: function () {
                for (var a = [], i = 0; i < 7; a.push(utilPDate.getShortDayName(i)), ++i); // get localised short day names
                return {
                    g: 0,
                    c: null,
                    s: "(?:" + a.join("|") + ")"
                };
            },
            l: function () {
                return {
                    g: 0,
                    c: null,
                    s: "(?:" + utilPDate.dayNames.join("|") + ")"
                };
            },
            N: {
                g: 0,
                c: null,
                s: "[1-7]" // ISO-8601 day number (1 (monday) - 7 (sunday))
            },
            //<locale type="object" property="parseCodes">
            S: {
                g: 0,
                c: null,
                s: "(?:st|nd|rd|th)"
            },
            //</locale>
            w: {
                g: 0,
                c: null,
                s: "[0-6]" // javascript day number (0 (sunday) - 6 (saturday))
            },
            z: {
                g: 1,
                c: "z = parseInt(results[{0}], 10);\n",
                s: "(\\d{1,3})" // day of the year (0 - 364 (365 in leap years))
            },
            W: {
                g: 0,
                c: null,
                s: "(?:\\d{2})" // ISO-8601 week number (with leading zero)
            },
            F: function () {
                return {
                    g: 1,
                    c: "m = parseInt(    Tamin.PDate.getMonthNumber(results[{0}]), 10);\n", // get localised month number
                    s: "(" + utilPDate.monthNames.join("|") + ")"
                };
            },
            M: function () {
                for (var a = [], i = 0; i < 12; a.push(utilPDate.getShortMonthName(i)), ++i); // get localised short month names
                return Ext.applyIf({
                    s: "(" + a.join("|") + ")"
                }, utilPDate.formatCodeToRegex("F"));
            },
            m: {
                g: 1,
                c: "m = parseInt(results[{0}], 10) - 1;\n",
                s: "(1[0-2]|0[1-9])" // month number with leading zeros (01 - 12)
            },
            n: {
                g: 1,
                c: "m = parseInt(results[{0}], 10) - 1;\n",
                s: "(1[0-2]|[1-9])" // month number without leading zeros (1 - 12)
            },
            t: {
                g: 0,
                c: null,
                s: "(?:\\d{2})" // no. of days in the month (28 - 31)
            },
            L: {
                g: 0,
                c: null,
                s: "(?:1|0)"
            },
            o: function () {
                return utilPDate.formatCodeToRegex("Y");
            },
            Y: {
                g: 1,
                c: "y = parseInt(results[{0}], 10);\n",
                s: "(\\d{4})" // 4-digit year
            },
            y: {
                g: 1,
                c: "var ty = parseInt(results[{0}], 10);\n"
                + "y = ty >     Tamin.PDate.y2kYear ? 1300 + ty : 1400 + ty;\n", // 2-digit year
                s: "(\\d{1,2})"
            },
            /*
             * In the am/pm parsing routines, we allow both upper and lower case
             * even though it doesn't exactly match the spec. It gives much more flexibility
             * in being able to specify case insensitive regexes.
             */
            //<locale type="object" property="parseCodes">
            a: {
                g: 1,
                c: "if (/(am)/i.test(results[{0}])) {\n"
                + "if (!h || h == 12) { h = 0; }\n"
                + "} else { if (!h || h < 12) { h = (h || 0) + 12; }}",
                s: "(am|pm|AM|PM)",
                calcAtEnd: true
            },
            //</locale>
            //<locale type="object" property="parseCodes">
            A: {
                g: 1,
                c: "if (/(am)/i.test(results[{0}])) {\n"
                + "if (!h || h == 12) { h = 0; }\n"
                + "} else { if (!h || h < 12) { h = (h || 0) + 12; }}",
                s: "(AM|PM|am|pm)",
                calcAtEnd: true
            },
            //</locale>
            g: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(1[0-2]|[0-9])" //  12-hr format of an hour without leading zeroes (1 - 12)
            },
            G: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(2[0-3]|1[0-9]|[0-9])" // 24-hr format of an hour without leading zeroes (0 - 23)
            },
            h: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(1[0-2]|0[1-9])" //  12-hr format of an hour with leading zeroes (01 - 12)
            },
            H: {
                g: 1,
                c: "h = parseInt(results[{0}], 10);\n",
                s: "(2[0-3]|[0-1][0-9])" //  24-hr format of an hour with leading zeroes (00 - 23)
            },
            i: {
                g: 1,
                c: "i = parseInt(results[{0}], 10);\n",
                s: "([0-5][0-9])" // minutes with leading zeros (00 - 59)
            },
            s: {
                g: 1,
                c: "s = parseInt(results[{0}], 10);\n",
                s: "(\\d{2})" // seconds with leading zeros (00 - 59)
            },
            u: {
                g: 1,
                c: "ms = results[{0}]; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n",
                s: "(\\d+)" // decimal fraction of a second (minimum = 1 digit, maximum = unlimited)
            },
            O: {
                g: 1,
                c: [
                    "o = results[{0}];",
                    "var sn = o.substring(0,1),", // get + / - sign
                    "hr = o.substring(1,3)*1 + Math.floor(o.substring(3,5) / 60),", // get hours (performs minutes-to-hour conversion also, just in case)
                    "mn = o.substring(3,5) % 60;", // get minutes
                    "o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n" // -12hrs <= GMT offset <= 14hrs
                ].join("\n"),
                s: "([+-]\\d{4})" // GMT offset in hrs and mins
            },
            P: {
                g: 1,
                c: [
                    "o = results[{0}];",
                    "var sn = o.substring(0,1),", // get + / - sign
                    "hr = o.substring(1,3)*1 + Math.floor(o.substring(4,6) / 60),", // get hours (performs minutes-to-hour conversion also, just in case)
                    "mn = o.substring(4,6) % 60;", // get minutes
                    "o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n" // -12hrs <= GMT offset <= 14hrs
                ].join("\n"),
                s: "([+-]\\d{2}:\\d{2})" // GMT offset in hrs and mins (with colon separator)
            },
            T: {
                g: 0,
                c: null,
                s: "[A-Z]{1,4}" // timezone abbrev. may be between 1 - 4 chars
            },
            Z: {
                g: 1,
                c: "zz = results[{0}] * 1;\n" // -43200 <= UTC offset <= 50400
                + "zz = (-43200 <= zz && zz <= 50400)? zz : null;\n",
                s: "([+\-]?\\d{1,5})" // leading '+' sign is optional for UTC offset
            },
            c: function () {
                var calc = [],
                    arr = [
                        utilPDate.formatCodeToRegex("Y", 1), // year
                        utilPDate.formatCodeToRegex("m", 2), // month
                        utilPDate.formatCodeToRegex("d", 3), // day
                        utilPDate.formatCodeToRegex("H", 4), // hour
                        utilPDate.formatCodeToRegex("i", 5), // minute
                        utilPDate.formatCodeToRegex("s", 6), // second
                        {
                            c: "ms = results[7] || '0'; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n"
                        }, // decimal fraction of a second (minimum = 1 digit, maximum = unlimited)
                        {
                            c: [ // allow either "Z" (i.e. UTC) or "-0530" or "+08:00" (i.e. UTC offset) timezone delimiters. assumes local timezone if no timezone is specified
                                "if(results[8]) {", // timezone specified
                                "if(results[8] == 'Z'){",
                                "zz = 0;", // UTC
                                "}else if (results[8].indexOf(':') > -1){",
                                utilPDate.formatCodeToRegex("P", 8).c, // timezone offset with colon separator
                                "}else{",
                                utilPDate.formatCodeToRegex("O", 8).c, // timezone offset without colon separator
                                "}",
                                "}"
                            ].join('\n')
                        }
                    ],
                    i,
                    l;

                for (i = 0, l = arr.length; i < l; ++i) {
                    calc.push(arr[i].c);
                }

                return {
                    g: 1,
                    c: calc.join(""),
                    s: [
                        arr[0].s, // year (required)
                        "(?:", "-", arr[1].s, // month (optional)
                        "(?:", "-", arr[2].s, // day (optional)
                        "(?:",
                        "(?:T| )?", // time delimiter -- either a "T" or a single blank space
                        arr[3].s, ":", arr[4].s,  // hour AND minute, delimited by a single colon (optional). MUST be preceded by either a "T" or a single blank space
                        "(?::", arr[5].s, ")?", // seconds (optional)
                        "(?:(?:\\.|,)(\\d+))?", // decimal fraction of a second (e.g. ",12345" or ".98765") (optional)
                        "(Z|(?:[-+]\\d{2}(?::)?\\d{2}))?", // "Z" (UTC) or "-0530" (UTC offset without colon delimiter) or "+08:00" (UTC offset with colon delimiter) (optional)
                        ")?",
                        ")?",
                        ")?"
                    ].join("")
                };
            },
            U: {
                g: 1,
                c: "u = parseInt(results[{0}], 10);\n",
                s: "(-?\\d+)" // leading minus sign indicates seconds before UNIX epoch
            }
        },

        //Old     Tamin.PDate prototype methods.
        // private
        dateFormat: function (date, format) {
            return utilPDate.format(date, format);
        },

        /**
         * Compares if two dates are equal by comparing their values.
         * @param {Date} date1
         * @param {Date} date2
         * @return {Boolean} True if the date values are equal
         */
        isEqual: Ext.Date.isEqual,

        /**
         * Formats a date given the supplied format string.
         * @param {Date} date The date to format
         * @param {String} format The format string
         * @return {String} The formatted date or an empty string if date parameter is not a JavaScript Date object
         */
        format: function (date, format) {
            var formatFunctions = utilPDate.formatFunctions;

            if (!Ext.isDate(date)) {
                return '';
            }

            if (formatFunctions[format] == null) {
                utilPDate.createFormat(format);
            }

            return formatFunctions[format].call(date) + '';
        },
        /**
         * Get the timezone abbreviation of the current date (equivalent to the format specifier 'T').
         *
         * Note: The date string returned by the javascript Date object's toString() method varies
         * between browsers (e.g. FF vs IE) and system region settings (e.g. IE in Asia vs IE in America).
         * For a given date string e.g. "Thu Oct 25 2007 22:55:35 GMT+0800 (Malay Peninsula Standard Time)",
         * getTimezone() first tries to get the timezone abbreviation from between a pair of parentheses
         * (which may or may not be present), failing which it proceeds to get the timezone abbreviation
         * from the GMT offset portion of the date string.
         * @param {Date} date The date
         * @return {String} The abbreviated timezone name (e.g. 'CST', 'PDT', 'EDT', 'MPST' ...).
         */
        getTimezone: Ext.Date.getTimezone,

        /**
         * Get the offset from GMT of the current date (equivalent to the format specifier 'O').
         * @param {Date} date The date
         * @param {Boolean} colon (optional) true to separate the hours and minutes with a colon (defaults to false).
         * @return {String} The 4-character offset string prefixed with + or - (e.g. '-0600').
         */
        getGMTOffset: Ext.Date.getGMTOffset,

        /**
         * Get the numeric day number of the year, adjusted for leap year.
         * @param {Date} date The date
         * @return {Number} 0 to 364 (365 in leap years).
         */
        getDayOfYear: function (date) {
            var num = 0,
                d = Tamin.PDate.clone(date),
                m = Tamin.PDate.getMonth(date),
                i;

            for (i = 0, utilPDate.setDate(d, 1), utilPDate.setMonth(d, 0); i < m; utilPDate.setMonth(d, ++i)) {
                num += utilPDate.getDaysInMonth(d);
            }
            return num + Tamin.PDate.getDate(date) - 1;
        },
        /**
         * Get the numeric ISO-8601 week number of the year.
         * (equivalent to the format specifier 'W', but without a leading zero).
         * @param {Date} date The date
         * @return {Number} 1 to 53
         * @method
         */
        getWeekOfYear: function (date) {
            var days = Tamin.PDate.getDayOfYear(date);
            return Math.ceil(days / 7);
        },
        /**
         * Checks if the current date falls within a leap year.
         * @param {Date} date The date
         * @return {Boolean} True if the current date falls within a leap year, false otherwise.
         */
        isLeapYear: function (date) {
            var year = Tamin.PDate.getFullYear(date),
                mod = year % 33;
            return !!(mod == 1 || mod == 5 || mod == 9 || mod == 13 || mod == 17 || mod == 22 || mod == 26 || mod == 30);
        },
        /**
         * Get the first day of the current month, adjusted for leap year.  The returned value
         * is the numeric day index within the week (0-6) which can be used in conjunction with
         * the {@link #monthNames} array to retrieve the textual day name.
         * Example:
         * <pre><code>
         var dt = new Date('1/10/2007'),
         firstDay =     Tamin.PDate.getFirstDayOfMonth(dt);
         console.log(    Tamin.PDate.dayNames[firstDay]); //output: 'Monday'
         * </code></pre>
         * @param {Date} date The date
         * @return {Number} The day number (0-6).
         */
        getFirstDayOfMonth: function (date) {
            utilPDate.getFirstDateOfMonth(date).getDay();
        },
        /**
         * Get the last day of the current month, adjusted for leap year.  The returned value
         * is the numeric day index within the week (0-6) which can be used in conjunction with
         * the {@link #monthNames} array to retrieve the textual day name.
         * Example:
         * <pre><code>
         var dt = new Date('1/10/2007'),
         lastDay =     Tamin.PDate.getLastDayOfMonth(dt);
         console.log(    Tamin.PDate.dayNames[lastDay]); //output: 'Wednesday'
         * </code></pre>
         * @param {Date} date The date
         * @return {Number} The day number (0-6).
         */
        getLastDayOfMonth: function (date) {
            return utilPDate.getLastDateOfMonth(date).getDay();
        },
        /**
         * Get the date of the first day of the month in which this date resides.
         * @param {Date} date The date
         * @return {Date}
         */
        getFirstDateOfMonth: function (date) {
            var c = Tamin.PDate.clone(date);
            Tamin.PDate.setDate(c, 1);
            return c;
        },
        /**
         * Get the date of the last day of the month in which this date resides.
         * @param {Date} date The date
         * @return {Date}
         */
        getLastDateOfMonth: function (date) {
            var c = Tamin.PDate.clone(date);
            Tamin.PDate.setDate(c, utilPDate.getDaysInMonth(date));
            return c;
        },
        /**
         * Get the number of days in the current month, adjusted for leap year.
         * @param {Date} date The date
         * @return {Number} The number of days in the month.
         * @method
         */
        getDaysInMonth: function (date) {
            var m = Tamin.PDate.getMonth(date);

            return m == 11 && Tamin.PDate.isLeapYear(date) ? 30 : Tamin.PDate.j_days_in_month[m];
        },
        /**
         * Get the English ordinal suffix of the current day (equivalent to the format specifier 'S').
         * @param {Date} date The date
         * @return {String} 'st, 'nd', 'rd' or 'th'.
         */
        //<locale type="function">
        getSuffix: Ext.Date.getSuffix,
        //</locale>

        /**
         * Creates and returns a new Date instance with the exact same date value as the called instance.
         * Dates are copied and passed by reference, so if a copied date variable is modified later, the original
         * variable will also be changed.  When the intention is to create a new variable that will not
         * modify the original instance, you should create a clone.
         *
         * Example of correctly cloning a date:
         * <pre><code>
         //wrong way:
         var orig = new Date('10/1/2006');
         var copy = orig;
         copy.setDate(5);
         console.log(orig);  //returns 'Thu Oct 05 2006'!

         //correct way:
         var orig = new Date('10/1/2006'),
         copy =     Tamin.PDate.clone(orig);
         copy.setDate(5);
         console.log(orig);  //returns 'Thu Oct 01 2006'
         * </code></pre>
         * @param {Date} date The date
         * @return {Date} The new Date instance.
         */
        clone: Ext.Date.clone,

        /**
         * Checks if the current date is affected by Daylight Saving Time (DST).
         * @param {Date} date The date
         * @return {Boolean} True if the current date is affected by DST.
         */
        isDST: Ext.Date.isDST,

        /**
         * Attempts to clear all time information from this Date by setting the time to midnight of the same day,
         * automatically adjusting for Daylight Saving Time (DST) where applicable.
         * (note: DST timezone information for the browser's host operating system is assumed to be up-to-date)
         * @param {Date} date The date
         * @param {Boolean} clone true to create a clone of this date, clear the time and return it (defaults to false).
         * @return {Date} this or the clone.
         */
        clearTime: Ext.Date.clearTime,

        /**
         * Provides a convenient method for performing basic date arithmetic. This method
         * does not modify the Date instance being called - it creates and returns
         * a new Date instance containing the resulting date value.
         *
         * Examples:
         * <pre><code>
         // Basic usage:
         var dt =     Tamin.PDate.add(new Date('10/29/2006'),     Tamin.PDate.DAY, 5);
         console.log(dt); //returns 'Fri Nov 03 2006 00:00:00'

         // Negative values will be subtracted:
         var dt2 =     Tamin.PDate.add(new Date('10/1/2006'), Ext.Date.DAY, -5);
         console.log(dt2); //returns 'Tue Sep 26 2006 00:00:00'

         * </code></pre>
         *
         * @param {Date} date The date to modify
         * @param {String} interval A valid date interval enum value.
         * @param {Number} value The amount to add to the current date.
         * @return {Date} The new Date instance.
         */
        add: function (date, interval, value) {
            var d = Tamin.PDate.clone(date),
                day;
            if (!interval || value === 0) {
                return d;
            }

            switch (interval.toLowerCase()) {
                case Ext.Date.MILLI:
                    d.setMilliseconds(d.getMilliseconds() + value);
                    break;
                case Ext.Date.SECOND:
                    d.setSeconds(d.getSeconds() + value);
                    break;
                case Ext.Date.MINUTE:
                    d.setMinutes(d.getMinutes() + value);
                    break;
                case Ext.Date.HOUR:
                    d.setHours(d.getHours() + value);
                    break;
                case Ext.Date.DAY:
                    d.setDate(d.getDate() + value);
                    break;
                case Ext.Date.MONTH:
                    day = Tamin.PDate.getDate(d);
                    if (day > 29) {
                        day = Math.min(day, Tamin.PDate.getLastDateOfMonth(Tamin.PDate.add(Tamin.PDate.getFirstDateOfMonth(d), Ext.Date.MONTH, value)).getDate());
                    }
                    Tamin.PDate.setDate(d, day);
                    Tamin.PDate.setMonth(d, Tamin.PDate.getMonth(d) + value);
                    break;
                case Ext.Date.YEAR:
                    day = Tamin.PDate.getDate(d);
                    if (day > 29) {
                        day = Math.min(day, Tamin.PDate.getLastDateOfMonth(Tamin.PDate.add(Tamin.PDate.getFirstDateOfMonth(d), Ext.Date.YEAR, value)).getDate());
                    }
                    Tamin.PDate.setDate(d, day);
                    Tamin.PDate.setFullYear(d, Tamin.PDate.getFullYear(d) + value);
                    break;
            }
            return d;
        },
        /**
         * Checks if a date falls on or between the given start and end dates.
         * @param {Date} date The date to check
         * @param {Date} start Start date
         * @param {Date} end End date
         * @return {Boolean} true if this date falls on or between the given start and end dates.
         */
        between: Ext.Date.between
    }
});
var utilPDate = Tamin.PDate;
function xf(format) {
    var args = Array.prototype.slice.call(arguments, 1);
    return format.replace(/\{(\d+)\}/g, function (m, i) {
        return args[i];
    });
}
*******************************************************************************************

* android 
./sdkmanager --proxy=http  --no_https --proxy_host=127.0.0.1 --proxy_port=8118 "ndk-bundle"
https://developer.android.com/studio/command-line/sdkmanager.html
https://developer.android.com/ndk/downloads/index.html


.side-menu {
    width: 200px !important;
}

.topbar .topbar-left {
    width: 200px !important;
}

.navbar-custom {
    margin-right: 200px !important;
}

* download 
https://www.qt.io/download-open-source/#section-2
http://radius-manager.soft112.com/
http://wifismartzone.com/files/rm_related/
android studio

* setting android development environmet
https://gist.github.com/venkateshshukla/9736261

* radius
http://radmandemo.dmasoftlab.com/
http://www.proradiusmanager.com/
http://bulbsoft.com/product/
http://daloradius.com/
https://splynx.com/
http://www.ispcube.com/
http://demo.snono.systems/#/dashboard
http://demo.snono.systems/
** radius lab
https://mellowd.co.uk/ccie/?p=2777

* useful css/javascript libs
http://malsup.com/jquery/form/
https://github.com/carhartl/jquery-cookie
https://github.com/onokumus/metisMenu
http://www.jacklmoore.com/autosize/
http://wenzhixin.net.cn/p/multiple-select/docs/
https://github.com/blueimp/jQuery-File-Upload
http://sandywalker.github.io/webui-popover/demo/
https://github.com/sandywalker/webui-popover
https://github.com/bseth99/jquery-ui-extensions
http://listjs.com/
https://rawgit.com/jeresig/jquery.hotkeys/master/test-static-01.html
http://ned.im/noty/
http://malsup.com/jquery/block/
* asus n552vm 4-300-0000
* upgrage baileys 
* projects
http://www.freeformatter.com/string-utilities.html
http://www.lukepaynesoftware.com/projects/peek-through/
* Splitting Strings with .split( )
You want to be able to split a string into an array of strings, given a specific substring (or regular expression)
to split them by.

#+begin_src javascript
console.log('abc'.split('a'));
console.log('/var/www/site/javascriptrecipes'.split('/'));
console.log('/var/www/site/javascriptrecipes'.split(/\//g));
console.log('/var/www/site/javascriptrecipes'.split('/', 2));
#+end_src

String.prototype.split()uses regular expressions (discussed at length in Chapter 20) to search for
matches inside of the parent string. If the first argument passed to it is not a regular expression, it will
convert it to one (using the RegExp constructor function). This means simply using a string is mostly fine,
as long as you don’t cross swords with regular expression syntax. The second argument can be used to limit
the amount of splits that happen. It defaults to 2^53-1 (9,007,199,254,740,991) and if you attempt to enter a
larger value (e.g., 9,007,199,254,740,992), 2^53-1 will be used. It’s a hard cap on the amount of splits that can
occur in a string. Realistically this is a limit that you’re very unlikely to hit.
* Stripping Blank Spaces with trim( )
Problem
You want to be able to remove trailing and leading whitespace from a string.
#+begin_src javascript
console.log(' hello '.trim());
console.log('\r\n\r\nFile start...\r\n...\r\nFile end...\r\n');
console.log('\r\n\r\nFile start...\r\n...\r\nFile end...\r\n'.trim());
#+end_src

* Determining If a String “Comes Before” Another with
localeCompare( )
You want to check if a particular string should precede another, in terms of ordering within a particular
locale. For example in English a “comes before” b, as a precedes b in the English alphabet.
 Determining If a String “Comes Before” Another with localeCompare()
#+begin_src javascript 
if ('Mike'.localeCompare('John') === -1) {
    console.log('Mike comes before John');
} else if ('Mike'.localeCompare('John') === 1) {
    console.log('John comes before Mike');
} else {
    console.log('John and Mike are both in the same position');
}
if ('Jan'.localeCompare('John') === -1) {
    console.log('Jan comes before John');
} else if ('Jan'.localeCompare('John') === 1) {
    console.log('John comes before Jan');
} else {
    console.log('John and Jan are both in the same position');
}
 if ('a'.localeCompare('á') === -1) {
    console.log('a comes before á');
} else if ('a'.localeCompare('á') === 1) {
    console.log('á comes before a');
} else {
    console.log('a and á are the same kind of letter');
}
if ('Michelle'.localeCompare('Michéllé') === -1) {
    console.log('Michelle comes before Michéllé');
} else if ('Michelle'.localeCompare('Michéllé') === 1) {
    console.log('Michéllé comes before Michelle');
} else {
    console.log('Michéllé and Michelle are both in the same position');
}
The output is:
John comes before Mike
Jan comes before John
a comes before á
Michelle comes before Michéllé
#+end_src

* Counting the Occurrences of a Substring
Problem
You want to be able to count the occurrences of a substring in a given parent string, but no methods exist for
this natively in JavaScript.

Counting the Occurrences of a Substring
 
#+begin_src javascript
function findOccurrences(string, substring) {
  var occurrenceCount = 0, position = 0;
  while ((position = string.indexOf(substring, position)) !== -1)  {
      occurrenceCount++;
      position += substring.length;
  }
  return occurrenceCount;
}
#+end_src

* Padding a String with a Custom Function
 adding a String with a Custom Function

#+begin_src javascript  
function pad(string, desiredLength = 0, padString = ' ', direction = -1) {
    var repetition = (desiredLength - string.length) / padString.length;
    if (repetition && direction > 0) {
        return string + padString.repeat(repetition);
    } else if (repetition && direction < 0) {
        return padString.repeat(repetition) + string;
    } else if (repetition && direction === 0) {
        var left = Math.floor(repetition/2),
            right = repetition - left;
        return padString.repeat(left) + string + padString.repeat(right);
    }
    return string;
}
#+end_src

* Truncating a String with a Custom Function
#+begin_src javascript 
function truncate(string, desiredLength, addendum = '\u2026') {
    if (string.length <= desiredLength) {
        return string;
    }
    return string.slice(0, string.lastIndexOf(' ', desiredLength - addendum.length)) + addendum;
}
#+end_src

The solution in this particular implementation is simple, perhaps a
little naive. Much more complex solutions exist for the same problem. This also generally only works with
LTR (Left to Right) languages such as English or French. String.prototype.slice() is given two arguments,
the first is 0 (the beginning of the string) the next is more complex.
Here the function calls String.prototype.lastIndexOf(). It calls it with a ' ' (space) character, the
idea being it should look for the last space character in the string, which would indicate the index between
the last and second to last word. Except it's actually passed a second argument, desiredLength - addendum.
length, which tells String.prototype.lastIndexOf() to look further down the string. This means that
String.prototype.lastIndexOf() actually finds the nearest space, left-most of the desiredLength cutoff
point. This makes the function a little greedy, oftentimes coming in under the desiredLength, but the use
case of this means it’s better to be under than over.

* Creating a Number Object
You want to create an object whose datatype is a number in order to work with numerical values.

#+begin_src javascript 
var myNumberObject = new Number(2);
console.log(myNumberObject);
if(myNumberObject.valueOf() === 2){
   console.log(‘we are the same’);
}
console.log(typeof parseInt('2')); // returns number
console.log(typeof parseFloat('2')); //returns number
console.log(typeof parseFloat(myNumberObject)); //returns number
#+end_src

* Checking If a Value Is Not a Number
 Using the isNaN Method on the Number Object to Check Value
#+begin_src javascript

var numberObject = new Number('things');
function checkIsNaN(value){
  if(typeof value !== 'number'){
    return 'is not a number';
  }else{
    return 'is a number';
  }
}
checkIsNaN('1234'); //returns is not a number
isNaN('things'); // returns true
Number.isNaN(numberObject.valueOf()); //returns true
Number.isNaN(4); //returns false
Number.isNaN(NaN); //returns true
#+end_src

 Using the global isNaN method, parameters are converted to numbers, then evaluated. If you were to pass a
string or number to the method on the number object, it will return false. This makes it possible to only pass
parameters that can safely be converted to NaN but are not the same value. In addition, you can use the typeof
operator and strict equality or inequality operators. One way to think of this would be, “is this not a number?”.
* Formatting a Number to a Fixed Amount of Digits
Fixing the Amount of Numbers after a Decimal Point
#+begin_src javascript
var numObj = 1.23456789;
numObj.toPrecision(); //returns 1.23456789
numObj.toPrecision(2); //returns 1.2
numObj.toPrecision(5); //returns 1.2346 Five numbers total. Notice how it is rounded up
numObj.toFixed(5); //returns 1.23457 Notice how it rounds up
numObj.toFixed(2); //returns 1.2
#+end_src

* Checking to See If a Number Is Finite
You want to make sure the number being used is a finite number.
#+begin_src javascript
var myNumberObject = new Number(2);
isFinite(myNumberObject); //returns true
isFinite(2); //returns true
isFinite('myNumberObject'); //returns false
Number.isFinite(myNumberObject.valueOf()); //returns true  
Number.isFinite(myNumberObject); //returns false  
Number.isFinite('myNumberObject'); //returns false  
Number.isFinite(NaN); //returns false  
isFinite(NaN); //returns false
isFinite(null); //returns true
Number.isFinite(null); //returns false  
#+end_src

The global isFinite function will do type conversion while the version associated with the number object
does not. If you’re passing a number object to the global version, it will be treated like a number due to type
conversion. Passing a string that cannot be converted into a number will return false. Values like null will
be converted into a number and return true, while NaN will return false.
* Checking If a Value Is an Integer
You want to determine if the number are working with is a whole number.
JavaScript does not have an integer datatype; all numbers are really floating-point numbers. For these
purposes, you want a number converted to a whole number without decimals. The methods round, ceil,
and floor used with the math object will return integers and will convert strings into numbers. If the string
cannot be converted, it will return NaN.

#+begin_src javascript
var myNumber = 1
Number.isInteger(myNumber);//returns true does not work in IE
Number.isInteger('2'); //returns false does not work in IE
Math.floor(1.6); //returns 1
Math.floor(1.4); //returns 1
Math.floor(NaN); //returns NaN
Math.ceil(1.6); //returns 2
Math.ceil(1.4); //returns 2
Math.round(1.6); //returns 2
Math.round(1.4); //returns 1
Math.round(-1.5); //returns -1
Math.round(-1.6); //returns -2
Math.round('3.5'); //returns -4
Math.round('jenny'); //returns NaN
Math.round(null); //returns 0
#+end_src

* Formatting Numbers for Date Time and Currency
You want to take numbers and format them into percentages and currency.
The number object does not have built-in formatting functions. Because of this, there are a lot of third-party
libraries and APIs to give you what you need. The ECMAScript Internationalization API has methods for date
time and currency. The visualization library D3 also has formatting methods. The internationalization API
works with IE 11, but not in Safari and the D3 library works with IE 9 and above.

#+begin_src javascript 
d3.format('%')(1); // returns 100%
d3.format(',')(1000000); //returns 1,000,000
d3.format("$,")(1250); //returns $1,250
d3.format("$,.2f")(1250);  //returns $1,250.00
d3.time.format('%Y-%m-%d').parse('1975-08-19');
//returns Tue Aug 19 1975 00:00:00 GMT-0400 (EDT)
new Intl.NumberFormat().format(45000);   // returns 45,000
new Intl.NumberFormat('ja-JP', { style: 'currency', currency: 'JPY' }).format(45000);
// returns ¥45,000
new Intl.DateTimeFormat('ja-JP', { weekday: 'long', year: 'numeric', month: 'long', day:
'numeric' }).format(new Date(1975, 07, 19)); //returns 1975年8月19日火曜日
new Intl.DateTimeFormat('en-US', { weekday: 'long', year: 'numeric', month: 'long', day:
'numeric' }).format(new Date(1975, 07, 19)); // returns Tuesday, August 19, 1975
#+end_src

* Creating a Random Number Generator
You want generate a random number between two values.
Creating a Random Number Generator Based on the Range of Two Numbers

#+begin_src javascript 
function getRandomBetweenMinAndMax(min, max) {
  return Math.floor(Math.random() * (max - min) + min);
}
function getRandomArbitrary(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
getRandomBetweenMinAndMax(0,5);
getRandomArbitrary(0,5);
#+end_src

* Using Math.max to Determine the Highest Number
Without performing a loop or any type of comparison function, you need to determine the highest number
in a list or in an array.

#+begin_src javascript 
Math.max(1,10) //returns 10
Math.max(-100,10) //returns 10
Using apply as part of the method call can define scope of the array.
var myNumArray = [1,2,3,4,5,6,7,8,9];
Math.max.apply(null,myArray); //returns 9
This would give you the same result:
Math.max.apply(this,myArray); //returns 9
Math.max.apply(myArray) //returns –Infinity
Math.max(myArray) //Returns NaN
#+end_src

* Returning the Square Root of a Number

#+begin_src javascript 
Math.sqrt(’Roger’) //result NaN
Math.sqrt(1000); //result 31.622776601683793
#+end_src 

* Using Coercion and Performing Equations
Because JavaScript does type coercion, strings can be converted into numbers and used in equations
dynamically. Depending on the order of the strings, numbers, and operators (+, -), the results can be
different.

#+begin_src javascript 
var myNumber = ‘15’;
//adding numbers
console.log(myNumber + 5) // returns 155
console.log(5 + myNumber) //returns 515
//subtracting numbers
console.log(5 – myNumber) // returns -10
console.log(myNumber – 5) //returns 10
var testNum = ‘7’;
    testNum += 7 // returns 77
    testumber – ‘1’ // returns 6
var machineType = ‘Tardis Type ‘;
    machineType += 40 // returns Tardis Type 40
var num1 = 5;
var num2= 5;
console.log (‘the total is ‘ + (num1 + num2)); // returns the total is 10
#+end_src 

* Returning a Number in Reverse
You are given a number and are asked to give that number back in reverse. For example, if you are given 123
the result should be 321.

#+begin_src javascript 

var numSequence = 1234;  
 var reversedNumbers = Number(numSequence.toString().split(”).reverse().join(”));
console.log(reversedNumbers) // returns 4321
//with out converting to a string
var = 123456789, b=0;
while(a > 0){
  b = b * 10;
  b = b + parseInt(a%10);
 a = parseInt(a/10);
}
console.log("Reversed number: " + b);
#+end_src 

* Determining the Length of a Number

#+begin_src javascript 
var myNum = 123456789;
console.log(myNum.toString().split(‘’).length);
//without converting to a string
var length = Math.log(555555555) * Math.LOG10E + 1 | 0;
console.log(length);
#+end_src 

* Swapping Two Numbers Without a Temporary Variable
Determine First with String Conversion then Without

#+begin_src javascript 
function swapNumbers(numb1, numb2){
   console.log(‘starting order = ‘ + numb1 + ‘,’ + numb2);
   numb2 = numb2 – numb1; //is now -150
   numb1 = numb1 + numb2; //is now 50
   numb2 = numb1 – numb2; //is now 200
   console.log(‘ending order = ‘ + numb1 + ‘,’ + numb2);
}
swapNumbers(200,50);
#+end_src

* myscript shirazs http://shirazs.ir/JavaScripts/myScript.js

/// <reference path="references.js" />

//------------ Global Function --------------------------
$(document).ready(function () {

    //------ animate icon-bar---------------
    $(".navbar-toggle").on("click", function () {
        $(this).toggleClass("active");
    });



    //--------animate hamburger css --------
    var toggles = document.querySelectorAll(".c-hamburger");

    for (var i = toggles.length - 1; i >= 0; i--) {
        var toggle = toggles[i];
        toggleHandler(toggle);
    };

    function toggleHandler(toggle) {
        toggle.addEventListener("click", function (e) {
            e.preventDefault();
            (this.classList.contains("is-active") === true) ? this.classList.remove("is-active") : this.classList.add("is-active");
        });
    }

    $('.mnu').click(function () {
        toggle.click();
    });

    // correct table header
    // $.fn.dataTable.tables({ visible: true, api: true }).columns.adjust();
    $('a[data-toggle="tab"]').on('shown.bs.tab', function (e) {
        $.fn.dataTable.tables({ visible: true, api: true }).columns.adjust();
    });


    //fix modal force focus
    $.fn.modal.Constructor.prototype.enforceFocus = function () { };
});

// ------------ ajax ----------------
//$.ajaxSetup({
//    beforeSend: function (xhr) {
//        //var token = "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJJRCI6MSwiSXNBZG1pbiI6dHJ1ZSwiRnVsbE5hbWUiOiLYudmE24zYsdi22KcsINin2LnYqtmF2KfYr9uMIiwiQWNjZXNzIjoiMTExMTAiLCJFeHAiOjYzNjIyMTU1MTI2MDE3NzQzM30.tqz0TsPqG3w3omQAqLTx3bLnRxoskiEjGM_IHojUtpODiYLUEYoy4vnW4F8c3NxE-XCPK2m5c4mQGn_43bdhBA";
//        //localStorage.getItem('token');
//        //xhr.setRequestHeader('Token', token);
//    }
//});

$(document).ajaxStart(function () {
    utility.enableLoading();
});

$(document).ajaxStop(function () {

    utility.disableLoading();
});

$(document).ajaxError(function (XMLHttpRequest, textStatus, errorThrow) {
    $(".cssload-modal").fadeOut(300);

    if (textStatus.status == 401) {
        utility.showNotify("اتمام جلسه کاری...", false);

        setTimeout(
          function () {
              utility.logout();
          }, 3000);
    } else if (textStatus.status == 404) {
        utility.showNotify("رکورد مورد نظر یافت نگردید.", false);
    }
});

$(window).load(function () {
    // $(".cssload-modal").fadeOut(300);
});
//------------ /Global Function -------------------------


var utility = (function () {

    var option = {
        showLoading: true
    };

    /*####################################
                    create
    ####################################*/
    function loadCreateModal(container_id, strModal_id, url, callback) {

        var containerModal = getContainerObj(container_id);
        var strFrm_id = strModal_id.replace('modal', 'frm');
        var frm;

        // is veiw not loaded
        if (containerModal.children('.modal').length == 0) {

            getData(url, function (response, status, xhr) {

                if (status == "success") {

                    // set modal html
                    containerModal.html(response);

                    // open modal
                    var modal = variables.get(strModal_id);
                    modal.modal('show');

                    // form validation
                    frm = variables.get(strFrm_id);
                    $.validator.unobtrusive.parse(frm);

                    //prevent post back
                    frm.submit(function (e) {
                        e.preventDefault();
                    });

                    //prevent default reset
                    frm.on('reset', function (e) {
                        e.preventDefault();
                    });

                    variables.setObject(strFrm_id, frm);

                    //modal.on('shown.bs.modal', function (e) {
                    callback(null, frm);
                    //});

                } else {
                    showNotifyErr();
                }
            });
        } else {

            frm = variables.getObject(strFrm_id);
            callback(null, frm);
            resetFormValidaion(frm);
            variables.get(strModal_id).modal('show');
        }
    }

    function submitModalCreate(frm, closeModal, callback) {

        var modal = variables.get('#' + frm.attr('id').replace('frm', 'modal'));
        var url = frm.attr('action');
        var formData = frm.serialize();
        postData(frm, url, formData, function (data) {

            showNotify(data.msg, data.success);
            if (data.success) {
                if (closeModal) {
                    modal.modal('hide');
                }

                // پاس دادن شی به متد
                // callback
                // برای درج در جدول
                callback(data.obj);
            }
        });
    }


    /*####################################
                    edit
    ####################################*/
    function loadEditModal(container_id, id, strModal_id, editUrl, getByIDUrl, callBack) {

        var containerModal = getContainerObj(container_id);
        var strFrm_id = strModal_id.replace('modal', 'frm');
        var frm;

        // is veiw not loaded
        if (containerModal.children('.modal').length == 0) {

            getData(editUrl, function (response, status, xhr) {

                if (status == "success") {

                    // set modal html
                    containerModal.html(response);

                    // open modal
                    var modal = variables.get(strModal_id);
                    modal.modal('show');

                    // form validation
                    frm = variables.get(strFrm_id);
                    $.validator.unobtrusive.parse(frm);

                    //prevent post back
                    frm.submit(function (e) {
                        e.preventDefault();
                    });

                    //prevent default reset
                    frm.on('reset', function (e) {
                        e.preventDefault();
                    });

                    variables.setObject(strFrm_id, frm);

                    //load data
                    //modal.one('shown.bs.modal', function (e) {
                    getData(getByIDUrl, function (data) {
                        setFrmAction(id, frm)
                        callBack(data, frm);
                    });
                    //});



                } else {
                    showNotifyErr();
                }
            });
        }
            // only load data
        else {

            frm = variables.getObject(strFrm_id);
            resetFormValidaion(frm);
            getData(getByIDUrl, function (data) {

                variables.get(strModal_id).modal('show');
                setFrmAction(id, frm)
                callBack(data, frm);
            });
        }
    }

    function submitModalEdit(frm, closeModal, callback) {

        var modal = variables.get('#' + frm.attr('id').replace('frm', 'modal'));
        var url = frm.attr('action');
        var formData = frm.serialize();

        postData(frm, url, formData, function (data) {

            showNotify(data.msg, data.success);
            if (data.success) {

                if (closeModal) {
                    modal.modal('hide');
                }
                callback(data.obj);
            }
        });
    }


    /*####################################
                    delete
    ####################################*/
    function loadDeleteModal(container_id, id, strModal_id, url, getByIDUrl, callback) {

        var containerModal = getContainerObj(container_id);
        var strFrm_id = strModal_id.replace('modal', 'frm');
        var frm;

        // if veiw not loaded
        if (containerModal.children('.modal').length == 0) {

            getData(url, function (response, status, xhr) {

                if (status == "success") {

                    // set modal html
                    containerModal.html(response);

                    variables.get(strModal_id).modal('show');
                    frm = variables.get(strFrm_id);

                    //prevent post back
                    $(frm).submit(function (e) {
                        e.preventDefault();
                    });

                    //load data
                    getData(getByIDUrl, function (data) {
                        setFrmAction(id, frm)
                        callback(data, frm);
                    });
                } else {
                    showNotifyErr();
                }
            });


        }
            // only load data
        else {

            variables.get(strModal_id).modal('show');
            frm = variables.get(strFrm_id);

            getData(getByIDUrl, function (data) {

                variables.get(strModal_id).modal('show');
                setFrmAction(id, frm)
                if (callback) {
                    callback(data);
                }
            });
        }
    }

    function submitModalDelete(strFrm_id, tbl_id, callback) {

        var frm = variables.get(strFrm_id);
        var modal = variables.get(strFrm_id.replace('frm', 'modal'));
        var url = frm.attr('action');
        var formData = frm.serialize();

        postData(frm, url, formData, function (data) {

            showNotify(data.msg, data.success);
            if (data.success) {
                modal.modal('hide');

                // پیدا کردن آی دی از روی اکشن فرم
                var frmAction = frm.attr('action');
                var indexOfID = Number(frmAction.lastIndexOf('/'));
                var id = frmAction.substring(indexOfID + 1, frmAction.length);

                if (isNaN(id)) {
                    id = null;
                }

                datatable.deleteFromDataTable(tbl_id, id);

                if (callback) {
                    callback();
                }
            }
        });

    }


    /*####################################
            custom view, modal
    ####################################*/
    function loadCustomModal(container_id, loadUrl, callback) {

        var containerModal = getContainerObj(container_id);

        // if veiw not loaded
        if (containerModal.children('.modal').length == 0) {
            getData(loadUrl, function (response, status, xhr) {

                if (status == "success") {

                    // set modal html
                    containerModal.html(response);

                    modal = containerModal.find('.modal:first');
                    modal.modal('show');
                    modal.on('shown.bs.modal', function (e) {
                        //$.fn.dataTable.tables({ visible: true, api: true }).columns.adjust();
                        var tbl = modal.find('table');
                        if (tbl && tbl[1]) {
                            datatable.adjustHeader(modal.find('table')[1].id);
                        }

                        //if (callback) {
                        //    callback();
                        //}
                    });

                    var frm = containerModal.find('form');
                    $.validator.unobtrusive.parse(frm);

                    //prevent post back
                    $(frm).submit(function (e) {
                        e.preventDefault();
                    });

                    if (callback) {
                        callback();
                    }

                } else {
                    showNotifyErr();
                }
            });
        }
            // open modal
        else {

            containerModal.find('.modal:first').modal('show');

            if (callback) {
                callback();
            }
        }
    }

    function loadCustomView(container_id, loadUrl, callback) {

        var container = variables.get('#' + container_id);
        if (!container.length) {
            throw "contianer does not define";
        }

        // if veiw not loaded
        if (container.children().length == 0) {
            getData(loadUrl, function (response, status, xhr) {

                if (status == "success") {

                    // set modal html
                    container.html(response);

                    var frm = container.find('form');
                    $.validator.unobtrusive.parse(frm);
                    //prevent post back
                    $(frm).submit(function (e) {
                        e.preventDefault();
                    });

                    if (callback) {
                        callback();
                    }
                } else {
                    showNotifyErr();
                }
            });
        }
        else {

            if (callback) {
                callback();
            }
        }
    }

    /*####################################
            post data to server
    ####################################*/
    function postData(frm, url, formData, callback) {

        if (!frm.valid()) {
            return false;
        }

        if (frm.find('input[type=file]').length) {
            $.ajax({
                type: 'post',
                url: url,
                data: new FormData(frm[0]),
                cache: false,
                //async: false,
                processData: false,
                contentType: false,
                success: function (data) {
                    if (callback)
                        callback(data);
                },
                error: function () {
                    showNotifyErr();
                }
            });
        } else {
            $.ajax({
                type: 'post',
                url: url,
                data: formData,
                cache: false,
                //async: false,
                success: function (data) {
                    if (callback)
                        callback(data);
                },
                error: function () {
                    showNotifyErr();
                }
            });
        }

    }


    /*####################################
            get data from server
    ####################################*/
    function getData(url, callback) {

        $.ajax({
            type: 'get',
            url: url,
            success: function (data, textStatus, jqXHR) {
                if (callback)
                    callback(data, textStatus, jqXHR);
            },
            error: function (jqXHR, textStatus, errorThrown) {
                showNotifyErr();
            }
        });
    }


    /*####################################
                notification
    ####################################*/
    function showNotify(msg, isSuccess) {
        if (isSuccess) {
            $.notify({
                icon: 'glyphicon glyphicon-ok',
                message: msg
            }, {
                type: 'success',
                z_index: 1050
            });
        } else {
            $.notify({
                icon: 'glyphicon glyphicon-exclamation-sign',
                message: msg
            }, {
                type: 'danger',
                z_index: 1050
            });
        }
    }

    function showNotifyErr() {
        showNotify('خطا در دریافت اطلاعات...', false);
    }


    /*####################################
                date time
    ####################################*/
    function fillDateTime(selector, targetSelector, hasTimePicker, group, isFromDate, isToDate) {

        // set default val
        hasTimePicker = !hasTimePicker ? false : hasTimePicker;
        group = !group ? '' : group;
        isToDate = !isToDate ? false : isToDate;
        isFromDate = !isFromDate ? false : isFromDate;

        variables.get(selector).MdPersianDateTimePicker({
            //Placement: 'bottom', // default is 'bottom'
            Trigger: 'click', // default is 'focus',
            EnableTimePicker: hasTimePicker, // default is true,
            TargetSelector: targetSelector, // default is empty,
            GroupId: group, // default is empty,
            ToDate: isToDate, // default is false,
            FromDate: isFromDate, // default is false,
            EnglishNumber: true,
            Disabled: false,
        });
    }

    function enableDateTime(selector, isEnable) {
        if (isEnable) {
            variables.get(selector).addClass('_date');
        }
        else {
            variables.get(selector).removeClass('_date');
        }

        variables.get(selector).MdPersianDateTimePicker('disable', !isEnable);
    }

    function convertJSONMiladiToPersian(mDate) {
        return persianDate(mDate).format('YYYY/MM/DD');
    }

    function convertJSONMiladiToPersianDateTime(mDateTime) {
        return persianDate(mDateTime).format('YYYY/MM/DD HH:mm:ss');
    }

    function convertPersianToMiladi(pDate) {

        if (!pDate || !pDate.trim()) {
            //showNotify('تاریخ خالی میباشد');
            return "";
        }

        pDate = pDate.replace(/-/g, '/');
        var arr = pDate.split('/');

        if (arr.length != 3) {
            showNotify('خطای تبدیل تاریخ');
            return false;
        }
        var jy = Number(arr[0]);
        var jm = Number(arr[1]);
        var jd = Number(arr[2]);

        var converted = toGregorian(jy, jm, jd);
        return converted.gy + '/' + converted.gm + '/' + converted.gd;
    }

    function convertPersianToMiladiDateTime(pDateTime) {

        if (!pDateTime || !pDateTime.trim()) {
            return false;
        }

        var arrDateTime = pDateTime.match(/\S+/g);
        var pDate = arrDateTime[0];
        var time = arrDateTime[1];

        pDate = pDate.replace(/-/g, '/');
        var arr = pDate.split('/');

        if (arr.length != 3) {
            showNotify('خطای تبدیل تاریخ');
            return false;
        }
        var jy = Number(arr[0]);
        var jm = Number(arr[1]);
        var jd = Number(arr[2]);

        var converted = toGregorian(jy, jm, jd);
        return converted.gy + '/' + converted.gm + '/' + converted.gd + ' ' + time;
    }

    function convertMiladiToPersian(mDate) {

        if (!mDate.trim()) {
            return false;
        }

        mDate = mDate.replace(/-/g, '/');
        var arr = mDate.split('/');

        if (arr.length != 3) {
            showNotify('خطای تبدیل تاریخ');
            return false;
        }
        var gy = Number(arr[0]);
        var gm = Number(arr[1]);
        var gd = Number(arr[2]);

        var converted = toJalaali(gy, gm, gd);
        return converted.jy + '/' + converted.jm + '/' + converted.jd;
    }

    function addDays(date, days) {
        var result = new Date(date);
        result.setDate(result.getDate() + days);
        return result;
    }

    function getCurrentMiladiDateTime() {
        var date = new Date();

        return date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate() + ' '
            + date.getHours() + ':' + date.getMinutes() + ':' + date.getSeconds();
    }

    function getCurrentPersianDate() {
        var date = new Date();

        var gy = date.getFullYear();
        var gm = date.getMonth() + 1;
        var gd = date.getDate();


        var converted = toJalaali(gy, gm, gd);
        return converted.jy + '/' + converted.jm + '/' + converted.jd;
    }


    /*####################################
            reset and preview img
   ####################################*/
    function resetImgPreview(file_id, img_id, lblFimeName_id) {

        variables.get('#' + file_id).val('');
        variables.get('#' + img_id).attr('src', 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTQwIiBoZWlnaHQ9IjE0MCIgdmlld0JveD0iMCAwIDE0MCAxNDAiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiPjxkZWZzLz48cmVjdCB3aWR0aD0iMTQwIiBoZWlnaHQ9IjE0MCIgZmlsbD0iI0VFRUVFRSIvPjxnPjx0ZXh0IHg9IjQzLjUiIHk9IjcwIiBzdHlsZT0iZmlsbDojQUFBQUFBO2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1mYW1pbHk6QXJpYWwsIEhlbHZldGljYSwgT3BlbiBTYW5zLCBzYW5zLXNlcmlmLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHQ7ZG9taW5hbnQtYmFzZWxpbmU6Y2VudHJhbCI+MTQweDE0MDwvdGV4dD48L2c+PC9zdmc+');
        variables.get('#' + lblFimeName_id).text('');
    }

    function setImgSrc(file_id, img_id, lblFimeName_id, src) {

        variables.get('#' + file_id).val('');
        variables.get('#' + lblFimeName_id).text('');
        variables.get('#' + img_id).attr('src', src);
    }

    function readImgURL(input, img_id, lblFimeName_id) {
        var imgName = input.value.toLowerCase();

        if (imgName.lastIndexOf('.jpg') > -1 ||
            imgName.lastIndexOf('.jpeg') > -1 ||
            imgName.lastIndexOf('.gif') > -1 ||
            imgName.lastIndexOf('.png') > -1 ||
            imgName.lastIndexOf('.bmp') > -1 ||
            imgName.lastIndexOf('.icn') > -1) {

            variables.get('#' + lblFimeName_id).text(imgName);

            if (input.files && input.files[0]) {
                var reader = new FileReader();

                reader.onload = function (e) {
                    $('#' + img_id).attr('src', e.target.result);
                }

                reader.readAsDataURL(input.files[0]);
            }
        } else {
            input.value = '';
            variables.get('#' + lblFimeName_id).text('');
            showNotify('فایل نامعتبر میباشد.', false);
        }
    }


    /*####################################
               file upload
   ####################################*/
    function readFileURL(input, lblFimeName_id) {

        var imgName = input.value;
        variables.get('#' + lblFimeName_id).text(imgName);
    }

    function resetFile(file_id, lblFileName_id) {
        variables.get('#' + file_id).val('');
        variables.get('#' + lblFileName_id).text('');
    }


    /*####################################
               select2 component
   ####################################*/
    function fillSelect2(select2_id, _url, remotable, data, taggable, callback) {

        var slct2 = variables.get('#' + select2_id);
        taggable = taggable ? true : false;

        var options = {
            placehoder: "جستجو...",
            dir: 'rtl',
            language: 'fa',
            tags: taggable,
            tokenSeparators: [',']
        };

        if (taggable) {
            options.multiple = 'multiple'
        }

        if (remotable) {
            slct2.find('option').remove();

            options.ajax = {
                url: _url,
                length: [],
                dataType: 'json',
                delay: 800,
                data: function (params) {
                    return {
                        term: params.term, // search term
                        page: params.page
                    };
                },
                processResults: function (data, params) {
                    // parse the results into the format expected by Select2
                    // since we are using custom formatting functions we do not need to
                    // alter the remote JSON data, except to indicate that infinite
                    // scrolling can be used
                    params.page = params.page || 1;

                    if (data.results && data.pagination) {
                        return data;
                    }
                    else {
                        return {
                            results: data,
                            pagination: {
                                more: (params.page * 30) < data.length
                            }
                        };
                    }
                },
                cache: true
            };
            //options.escapeMarkup = function (markup) { return markup; }; // let our custom formatter work
            options.minimumInputLength = 3;
        }
        else if (data) {

            slct2.find('option').remove();
            options.data = data;
        }
        else if (_url) {
            $.getJSON(_url, function (d) {

                slct2.find('option').remove();
                options.data = d;
                slct2.select2(options);
            }).done(function () {
                if (callback) {
                    callback();
                }
            });
        }

        slct2.select2(options);

        if (taggable) {
            slct2.val(null).trigger('change');
        }
    }

    function select2SearchProgrammatic(select2_id, term) {

        $('.select2-hidden-accessible').select2('close');
        variables.get('#' + select2_id).select2('open');

        var $searchInput = variables.get('input.select2-search__field');
        $searchInput.val(term);
        $searchInput.trigger('input')
    }


    /*####################################
               convert num
   ####################################*/
    function convertToInt(num) {
        num = num || '0';
        num = isNaN(num) ? 0 : num;
        num = parseInt(num);

        return num;
    }

    function unFormatAndConvertToInt(num) {
        num = unFormatNumber(num);
        num = convertToInt(num);

        return num;
    }

    function unFormatAndFormatNumber(num) {
        num = unFormatNumber(num);
        num = convertToInt(num);

        return formatNumber(num);
    }

    function formatNumber(num) {
        num = convertToInt(num);

        return num.toLocaleString();
    }

    function formatNumberWithCama(num) {
        num = unFormatAndConvertToInt(num);
        num = convertToInt(num);

        return num.toLocaleString();
    }

    function unFormatNumber(num) {
        num = convertPersianNumToEng(num);

        return num.replace(/,/g, '');
    }

    function convertEngNumToPersian(engStr) {

        engStr = engStr || '';
        engStr = engStr.toString() || '';
        var arr = engStr.split('');

        for (var i = 0; i < arr.length; i++) {
            var replacement = arr[i];
            switch (arr[i]) {
                case '0':
                    replacement = '۰';
                    break;
                case '1':
                    replacement = '۱';
                    break;
                case '2':
                    replacement = '۲';
                    break;
                case '3':
                    replacement = '۳';
                    break;
                case '4':
                    replacement = '۴';
                    break;
                case '5':
                    replacement = '۵';
                    break;
                case '6':
                    replacement = '۶';
                    break;
                case '7':
                    replacement = '۷';
                    break;
                case '8':
                    replacement = '۸';
                    break;
                case '9':
                    replacement = '۹';
                    break;

            }
            arr[i] = replacement;
        }

        return arr.join("");
    }

    function convertPersianNumToEng(persianStr) {

        persianStr = persianStr || '';
        persianStr = persianStr.toString() || '';
        var arr = persianStr.split('');

        for (var i = 0; i < arr.length; i++) {
            var replacement = arr[i];
            switch (arr[i]) {
                case '۰':
                    replacement = '0';
                    break;
                case '۱':
                    replacement = '1';
                    break;
                case '۲':
                    replacement = '2';
                    break;
                case '۳':
                    replacement = '3';
                    break;
                case '۴':
                    replacement = '4';
                    break;
                case '۵':
                    replacement = '5';
                    break;
                case '۶':
                    replacement = '6';
                    break;
                case '۷':
                    replacement = '7';
                    break;
                case '۸':
                    replacement = '8';
                    break;
                case '۹':
                    replacement = '9';
                    break;
                case '٫':
                case '\'':
                case '،':
                case '٬':
                    replacement = ',';
                    break;
            }
            arr[i] = replacement;
        }

        return arr.join("");
    }

    function makeTexBoxFormatable(txt_id) {

        var $txt = variables.get('#' + txt_id);
        $txt.addClass('text-center')
            .on('input', function () {
                this.value = unFormatAndFormatNumber(this.value);
            }).focus(function () {
                $txt.select();
            });
    }

    function limitMaxLen(txt_id, isNumerical, isMobile) {

        var $txt = variables.get('#' + txt_id);
        $txt.on('keydown', function (e) {

            if (isMobile && $txt.val().charAt(0) == 0) {
                $txt.val($txt.val().substr(1));
            }

            if ($.inArray(e.keyCode, [46, 8, 9, 27, 13, 190]) !== -1 ||  // {46:delete, 8:backspace, 9:tab, 27:escape, 13:enter, 110:decimal point, 190:period}
                // Allow: Ctrl/cmd+A
                    (e.keyCode == 65 && (e.ctrlKey === true || e.metaKey === true)) ||
                // Allow: Ctrl/cmd+C
                    (e.keyCode == 67 && (e.ctrlKey === true || e.metaKey === true)) ||
                // Allow: Ctrl/cmd+X
                    (e.keyCode == 88 && (e.ctrlKey === true || e.metaKey === true)) ||
                // Allow: home, end, left, right
                    (e.keyCode >= 35 && e.keyCode <= 39)) {
                // let it happen, don't do anything
                return;
            }

            var maxLen = $txt.data()["valLengthMax"] || $txt.data()["valMaxlengthMax"] || $txt.attr('maxlength') || 0;

            if (getSelectionTextLen() == maxLen) {
                return true;
            }

            // Ensure that it is a number and stop the keypress
            if ($txt.val().length >= maxLen
                || (isNumerical
                    && (e.shiftKey || (e.keyCode < 48 || e.keyCode > 57))
                    && (e.keyCode < 96 || e.keyCode > 105))) {
                e.preventDefault();
            }
        });
    }

    function getSelectionTextLen() {
        var text = "";
        var activeEl = document.activeElement;
        var activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;
        if (
          (activeElTagName == "textarea") || (activeElTagName == "input" &&
          /^(?:text|search|password|tel|url)$/i.test(activeEl.type)) &&
          (typeof activeEl.selectionStart == "number")
        ) {
            text = activeEl.value.slice(activeEl.selectionStart, activeEl.selectionEnd);
        } else if (window.getSelection) {
            text = window.getSelection().toString();
        }
        return text.length;
    }

    function onlyPersianChar(txt_id, spn_id) {
        var regex = /^[\u0600-\u06FF\s]+$/;

        var spn = variables.get('#' + spn_id);
        var $txt = variables.get('#' + txt_id);

        $txt.on('keydown', function (e) {

            if ($txt.val() == "" ||
                $.inArray(e.keyCode, [46, 8, 9, 27, 13, 190, 32]) !== -1 ||  // {46:delete, 8:backspace, 9:tab, 27:escape, 13:enter, 110:decimal point, 190:period, 32:space}
                // Allow: Ctrl/cmd+A
                    (e.keyCode == 65 && (e.ctrlKey === true || e.metaKey === true)) ||
                // Allow: Ctrl/cmd+C
                    (e.keyCode == 67 && (e.ctrlKey === true || e.metaKey === true)) ||
                // Allow: Ctrl/cmd+X
                    (e.keyCode == 88 && (e.ctrlKey === true || e.metaKey === true)) ||
                // Allow: home, end, left, right
                    (e.keyCode >= 35 && e.keyCode <= 39)) {
                // let it happen, don't do anything
                return;
            }

            if (!regex.test($txt.val())) {
                e.preventDefault();
                spn.text('از حروف فارسی استفاده شود');
            }
            else {
                spn.text('');
            }
        });
    }


    /*####################################
                no category
    ####################################*/
    function setFrmAction(id, frm) {

        var frmAction = frm.attr('action');
        var indexOfID = frmAction.lastIndexOf('/');
        frmAction = frmAction.substring(0, indexOfID);
        frm.attr('action', frmAction + '/' + id);
    }

    function getContainerObj(container_id) {
        allModalContainer = variables.get('#containerModals');
        var containerModal = allModalContainer.children('#' + container_id);

        // if contianer not exists, create one
        if (!containerModal.length) {
            allModalContainer.append('<div id="' + container_id + '"></div>');

            containerModal = allModalContainer.children('#' + container_id);
        }

        return containerModal;
    }

    function resetFormValidaion(frm) {
        //Removes validation from input-fields
        frm.find('.input-validation-error').addClass('input-validation-valid').removeClass('input-validation-error');
        //Removes validation message after input-fields
        frm.find('.field-validation-error').addClass('field-validation-valid').removeClass('field-validation-error');
        //Removes validation summary
        frm.find('.validation-summary-errors').addClass('validation-summary-valid').removeClass('validation-summary-errors');
    }

    function correctModalOverflowY(modal_front, modal_back) {
        variables.get('#' + modal_front).on('hide.bs.modal', function () {
            $('#' + modal_back).css('overflow-y', 'scroll');
        });
    }

    function loadMenu(url) {

        var jwtObj = getJwtObject();
        variables.get('#spn_user_fullName').text(decodeURI(jwtObj.FullName));

        getData(url, function (data) {

            // image profile
            variables.get('#userImageProfile').attr('src', data.UserImgPath)


            // load menu
            var myMenu = new SideMenu();

            var lstMenu = [];

            for (var i = 0; i < data.lstMdl.length; i++) {
                var mdl = data.lstMdl[i];
                for (var j = 0; j < data.lstAccessPage.length; j++) {
                    var mnu = data.lstAccessPage[j];

                    if (mnu.Module_FK == mdl.ID) {
                        lstMenu.push(new SMLinkItem(mnu.FaName, mnu.EnName));
                    }
                }

                if (lstMenu.length) {
                    myMenu.addItem(new SMSubMenuItem(mdl.Name, lstMenu));
                }
                lstMenu.splice(0, lstMenu.length)
            }
            myMenu.appendTo(document.getElementById('menu'));

            // ----- open close menu----------------
            variables.get('#_btnMenu').click(function () {
                myMenu.toggle();
            });

        });

    }

    function disableLoading() {

        variables.get(".cssload-modal").fadeOut(300)
    }

    function enableLoading() {
        if (option.showLoading) {
            variables.get(".cssload-modal").fadeIn(50)
        }
    }


    /*####################################
        jwt token and base 64 conversion
    ####################################*/
    function b64DecodeUnicode(str) {
        return decodeURIComponent(Array.prototype.map.call(atob(str), function (c) {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
    }

    function b64EncodeUnicode(str) {
        return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p1) {
            return String.fromCharCode('0x' + p1);
        }));
    }

    function parseJwt(token) {
        var base64Url = token.split('.')[1];
        var base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
        return JSON.parse(b64DecodeUnicode(base64));
    };

    function getJwtObject() {
        var token = myCookie.getCookie('Token');
        return parseJwt(token);
    }


    //نمایش وضعیت دانش آموز در مراحل تعیین سرویس
    //type-->0 فقط مراحل ثبت نام 
    //type-->1 تمام اطلاعات (پنل) کاربری

    function setStudentStatus(data, type) {
        var MustPay = data.PrePayment;

        var Status = (data.StuPay - MustPay >= 0) ? 'glyphicon-ok-circle text-success' : 'glyphicon-remove-circle text-danger';
        var StatusPre = (data.HasPrePaid) ? 'text-success">پرداخت موفق پیش پرداخت' : 'text-danger">ضروری جهت تعیین سرویس';

        var Part = ['<p class="row label-default"><span class="glyphicon ', Status, '">&nbsp;</span><strong>1-  پیش پرداخت (از اول شهریورماه)</strong><br />&nbsp;&nbsp;<strong class="' + StatusPre + '</strong><br />&nbsp;&nbsp;<font>* مبلغ : </font>&nbsp;<strong>', utility.formatNumber(MustPay), ' ریال</strong></p>'].join("");

        variables.get("#PrePayment").addClass(Status);
        variables.get("#VerifyPhone").addClass(enums.CheckStuStatus[data.VerifyPhone]);
        variables.get("#HasRegister").addClass(enums.CheckStuStatus[data.HasRegister]);
        variables.get("#HasService").addClass(enums.CheckStuStatus[data.HasService]);
        variables.get("#AcceptLaw").addClass(enums.CheckStuStatus[(data.AcceptLaw) ? true : false && data.HasService]);
        variables.get("#HasSettle").addClass(enums.CheckStuStatus[data.HasSettle && data.HasService]);

        if (type == 1) {
            variables.get("#StuId").text(data.StuNationalNo);
            variables.get("#School").text(data.School);
            variables.get("#ServicePrice").text(data.ServicePrice);
            variables.get("#StuLevel").text(data.StuLevel);
            variables.get("#StuFather").text(data.StuFather);
            variables.get("#PayAmount").text(utility.formatNumber(data.StuPay) + ' ریال');
            variables.get("#StuName").text(data.StuName);
            variables.get("#ServicePrice").text(utility.formatNumber(data.ServicePrice) + ' ریال');
            variables.get("#RemainServicePrice").text(utility.formatNumber(data.StuPay - data.ServicePrice) + ' ریال');

            if (data.HasService) {
                variables.get("#CompanyName").text(data.CompanyName);
                variables.get("#ServiceDistance").text(data.ServiceDistance + ' کیلومتر');
                variables.get("#DrvName").text(data.DrvName);
            }
            else
                variables.get(".NoService").removeClass("hidden");

            variables.get("#Installment").append(Part);
            if (data.HasService) {
                data.Services.forEach(function (item, index) {
                    MustPay += item.Amount;
                    var Status = (data.StuPay - MustPay > 0) ? 'glyphicon-ok-circle text-success' : 'glyphicon-remove-circle text-danger';
                    var Part = ['<p class="row label-default"><span class="glyphicon ', Status, '">&nbsp;</span><strong>', index + 2, '- قسط ', item.PartNo, ' </strong><br />&nbsp;&nbsp;<font>* مهلت پرداخت : </font>&nbsp;<strong class="text-danger">', utility.convertJSONMiladiToPersian(item.ExpireDate), '</strong><br />&nbsp;&nbsp;<font>* مبلغ : </font>&nbsp;<strong>', utility.formatNumber(item.Amount), ' ریال</strong></p>'].join("");
                    variables.get("#Installment").append(Part);
                });
            }

        }
        $("._stepfix p").find(".glyphicon-remove-circle").first().parent().addClass("row label-default alert alert-info");

    }

    function printingElement(elementid) {
        $("#" + elementid).print({
            globalStyles: true,
            mediaPrint: false,
            stylesheet: null,
            noPrintSelector: ".no-print",
            iframe: true,
            append: null,
            prepend: null,
            manuallyCopyFormValues: true,
            deferred: $.Deferred(),
            timeout: 750,
            title: null,
            doctype: '<!doctype html>'
        });
    }
    //---------------------------------
    return {
        option: option,
        //--load modal--
        loadCreateModal: loadCreateModal,
        submitModalCreate: submitModalCreate,
        loadEditModal: loadEditModal,
        submitModalEdit: submitModalEdit,
        loadDeleteModal: loadDeleteModal,
        submitModalDelete: submitModalDelete,
        resetFormValidaion: resetFormValidaion,
        loadCustomModal: loadCustomModal,
        loadCustomView: loadCustomView,
        //--connect to server--
        postData: postData,
        getData: getData,
        //--notify--
        showNotify: showNotify,
        showNotifyErr: showNotifyErr,
        //--date time--
        fillDateTime: fillDateTime,
        enableDateTime: enableDateTime,
        convertJSONMiladiToPersian: convertJSONMiladiToPersian,
        convertJSONMiladiToPersianDateTime: convertJSONMiladiToPersianDateTime,
        convertPersianToMiladi: convertPersianToMiladi,
        convertPersianToMiladiDateTime: convertPersianToMiladiDateTime,
        convertMiladiToPersian: convertMiladiToPersian,
        addDays: addDays,
        getCurrentMiladiDateTime: getCurrentMiladiDateTime,
        getCurrentPersianDate: getCurrentPersianDate,
        //--img--
        resetImgPreview: resetImgPreview,
        setImgSrc: setImgSrc,
        readImgURL: readImgURL,
        //--file upload
        readFileURL: readFileURL,
        resetFile: resetFile,
        //--Select2--
        fillSelect2: fillSelect2,
        select2SearchProgrammatic: select2SearchProgrammatic,
        //--format--
        convertToInt: convertToInt,
        unFormatAndConvertToInt: unFormatAndConvertToInt,
        formatNumber: formatNumber,
        formatNumberWithCama: formatNumberWithCama,
        unFormatNumber: unFormatNumber,
        unFormatAndFormatNumber: unFormatAndFormatNumber,
        convertEngNumToPersian: convertEngNumToPersian,
        convertPersianNumToEng: convertPersianNumToEng,
        makeTexBoxFormatable: makeTexBoxFormatable,
        limitMaxLen: limitMaxLen,
        onlyPersianChar: onlyPersianChar,
        //--no category
        correctModalOverflowY: correctModalOverflowY,
        loadMenu: loadMenu,
        disableLoading: disableLoading,
        enableLoading: enableLoading,
        setStudentStatus: setStudentStatus,
        printingElement: printingElement
    }
})();

var datatable = (function () {
    //------------- datatable component--------------
    var lstDataTables = {};

    function fillDataTable(tbl_id, src, col, hasIndex, hasEdit, hasDelete, appName, searchableFooter, callback) {

        var tbl;

        if (lstDataTables[tbl_id]) {
            reloadDataTable(tbl_id, src);
            return lstDataTables[tbl_id];
        } else {


            if (hasIndex) {
                col.unshift({
                    title: 'ردیف',
                    data: null,
                    searchable: false,
                    sortable: false,
                    visible: true
                })
            }

            if (hasEdit) {
                col.push({
                    title: 'ویرایش',
                    data: 'id',
                    searchable: false,
                    sortable: false,
                    render: function (data, type, row) {
                        return '<a href="javascript:' + appName + '._loadEditModal(' + data + ')" ><span class="glyphicon glyphicon-edit"></span></a>';
                    }
                })
            }

            if (hasDelete) {
                col.push({
                    title: 'حذف',
                    data: 'id',
                    searchable: false,
                    sortable: false,
                    render: function (data, type, row) {
                        return '<a href="javascript:' + appName + '._loadDeleteModal(' + data + ');" class="text-danger"><span class="glyphicon glyphicon-remove"></span></a>';
                    }
                });
            }

            var $tbl = $('#' + tbl_id);

            // serachable footer
            if (searchableFooter) {
                var $tfootTr = $tbl.append('<tfoot></tfoot>').find('tfoot').append('<tr></tr>').find('tr');

                for (var i = 0; i < col.length; i++) {
                    if (col[i].searchable == false) {
                        $tfootTr.append('<td></td>')
                    }
                    else if (col[i].myType == 'bool') {
                        $tfootTr.append('<td><label class="checkbox">فیلتر<input type="checkbox" class="_chkFooterSearch" data-related="' + tbl_id + '" data-state="indeterminate"/></label></td>');
                    }
                    else {
                        $tfootTr.append('<td><input type="text" class="_txtFooterSearch" data-related="' + tbl_id + '" style="width:100%" placeholder="جستجو" /></td>')
                    }
                }

                $tfootTr.find('input[type="checkbox"]').prop('indeterminate', true);
                //--------------------------------------
            }

            // init datatable
            tbl = $tbl.DataTable({
                aaSorting: [],
                sAjaxSource: src,
                sAjaxDataProp: "",
                columns: col,
                responsive: true,
                scrollY: 350,
                language: {
                    "sProcessing": "درحال پردازش...",
                    "sLengthMenu": "نمایش محتویات _MENU_",
                    "sZeroRecords": "موردی یافت نشد",
                    "sInfo": "نمایش _START_ تا _END_ از مجموع _TOTAL_ مورد",
                    "sInfoEmpty": "تهی",
                    "sInfoFiltered": "(فیلتر شده از مجموع _MAX_ مورد)",
                    "sInfoPostFix": "",
                    "sSearch": "جستجو:",
                    "sUrl": "",
                    "oPaginate": {
                        "sFirst": "ابتدا",
                        "sPrevious": "قبلی",
                        "sNext": "بعدی",
                        "sLast": "انتها"
                    }
                },
                initComplete: function (settings, json) {
                    if (callback) {
                        callback(settings, json);
                    }
                }
            });

            if (hasIndex) {
                tbl.on('order.dt search.dt', function () {
                    tbl.column(0, { search: 'applied', order: 'applied' }).nodes().each(function (cell, i) {
                        cell.innerHTML = i + 1;
                    });
                }).draw();
            }

            $('#' + tbl_id + ' tbody').on('click', 'tr', function () {
                tbl.$('tr.selected').removeClass('selected');
                $(this).addClass('selected');
            });

            lstDataTables[tbl_id] = tbl;

            //event for footer search
            if (searchableFooter) {
                tbl.columns().every(function () {
                    var dataTableColumn = this;
                    var $footer = $(this.footer());
                    $footer.find('input[type="text"]').on('input', function () {
                        dataTableColumn.search(this.value).draw();
                    });

                    $footer.find('input[type="checkbox"]').change(function () {

                        var attr = this.getAttribute('data-state');

                        if (attr == "indeterminate") {
                            this.checked = true;
                            this.indeterminate = false;
                            this.setAttribute('data-state', 'checked')
                        }
                        else if (attr == "checked") {

                            this.checked = false;
                            this.indeterminate = false;
                            this.setAttribute('data-state', 'unchecked')
                        }
                        else if (attr == "unchecked") {

                            this.indeterminate = true;
                            this.setAttribute('data-state', 'indeterminate')
                        }

                        if (this.indeterminate) {
                            dataTableColumn.search('').draw();
                        }
                        else {
                            dataTableColumn.search(this.checked).draw();
                        }

                    });
                });
            }

            return tbl;
        }
    }

    function fillDataTable2(tbl_id, option, callback) {

        var tbl;

        // default option
        if (option.sAjaxSource) {
            option.sAjaxSource = option.sAjaxSource;
        }
        if (option.columns) {
            option.columns = option.columns;
        }
        option.aaSorting = option.aaSorting ? option.aaSorting : [];
        option.responsive = option.responsive ? option.responsive : true;
        option.scrollY = option.scrollY ? option.scrollY : 350;
        option.language = option.language ? option.language : {
            "sProcessing": "درحال پردازش...",
            "sLengthMenu": "نمایش محتویات _MENU_",
            "sZeroRecords": "موردی یافت نشد",
            "sInfo": "نمایش _START_ تا _END_ از مجموع _TOTAL_ مورد",
            "sInfoEmpty": "تهی",
            "sInfoFiltered": "(فیلتر شده از مجموع _MAX_ مورد)",
            "sInfoPostFix": "",
            "sSearch": "جستجو:",
            "sUrl": "",
            "oPaginate": {
                "sFirst": "ابتدا",
                "sPrevious": "قبلی",
                "sNext": "بعدی",
                "sLast": "انتها"
            }
        };

        option.initComplete = option.initComplete ? option.initComplete : function (settings, json) {
            if (callback) {
                callback(settings, json);
            }
        };
        //--------------------------------



        if (lstDataTables[tbl_id]) {
            reloadDataTable(tbl_id, src);
            return lstDataTables[tbl_id];
        } else {

            var col = option.columns;
            var hasIndex = option.hasIndex;
            var hasEdit = option.hasEdit;
            var hasDelete = option.hasDelete;
            var appName = option.appName;

            if (hasIndex) {
                col.unshift({
                    title: 'ردیف',
                    data: null,
                    searchable: false,
                    sortable: false,
                    visible: true
                })
            }

            if (hasEdit) {
                col.push({
                    title: 'ویرایش',
                    data: 'id',
                    searchable: false,
                    sortable: false,
                    render: function (data, type, row) {
                        return '<a href="javascript:' + appName + '._loadEditModal(' + data + ')" ><span class="glyphicon glyphicon-edit"></span></a>';
                    }
                })
            }

            if (hasDelete) {
                col.push({
                    title: 'حذف',
                    data: 'id',
                    searchable: false,
                    sortable: false,
                    render: function (data, type, row) {
                        return '<a href="javascript:' + appName + '._loadDeleteModal(' + data + ');" class="text-danger"><span class="glyphicon glyphicon-remove"></span></a>';
                    }
                });
            }

            tbl = $('#' + tbl_id).DataTable(option);

            if (hasIndex) {
                tbl.on('order.dt search.dt', function () {
                    tbl.column(0, { search: 'applied', order: 'applied' }).nodes().each(function (cell, i) {
                        cell.innerHTML = i + 1;
                    });
                }).draw();
            }

            $('#' + tbl_id + ' tbody').on('click', 'tr', function () {
                tbl.$('tr.selected').removeClass('selected');
                $(this).addClass('selected');
            });

            lstDataTables[tbl_id] = tbl;

            return tbl;

            //    for(let i = 0; i< col.length; i++)
            //    {
            //        if(col[i].searchable == false)
            //        {
            //            $tfootTr.append('')
            //        }
            //    }
            //}
        }
    }

    function insertToDataTable(tbl_id, rowData) {

        var isInserted = false;
        // باز یابی شی جدول با نام آن
        var tbl = lstDataTables[tbl_id];

        if (tbl) {

            clearSearchbox(tbl_id);

            // اضافه
            var insertedRow = tbl.row.add(rowData).draw().node();
            tbl.page('last').draw('page');

            // حذف تمامی سطرهای انتخاب شده
            tbl.$('tr.selected').removeClass('selected');

            // انتخاب کردن ردیف اضاف شده
            $(insertedRow).addClass('selected');

            isInserted = true;
        }

        return isInserted;
    }

    function editDataTable(tbl_id, rowData) {


        // باز یابی شی جدول با نام آن
        var tbl = lstDataTables[tbl_id];
        var isUpdated = false;

        if (tbl) {
            var index = getRowIndexById(tbl, rowData.id);
            if (index != -1) {
                // ویرایش
                tbl.row(index).data(rowData).draw(false);
                isUpdated = true;
            }
        }

        return isUpdated;
    }

    function deleteFromDataTable(tbl_id, id) {

        // باز یابی شی جدول با نام آن
        var tbl = lstDataTables[tbl_id];
        var isDeleted = false;

        if (tbl) {
            if (!id) {
                id = tbl.row('.selected').data().id;
            }

            var index = getRowIndexById(tbl, id);
            if (index != -1) {
                // حذف
                tbl.row(index).remove().draw(false);
                isDeleted = true;
            }
        }

        return isDeleted;
    }

    function reloadDataTable(tbl_id, url, data) {

        var tbl = lstDataTables[tbl_id];
        if (data) {
            tbl.clear();
            tbl.rows.add(data).draw();
        } else if (url) {
            tbl.ajax.url(url).load();
        } else {
            tbl.ajax.reload();
        }
    }

    /* search in dataTables data and find row index */
    function getRowIndexById(tbl, id) {

        var index = -1

        tbl.rows().every(function (rowIdx, tableLoop, rowLoop) {

            var data = this.data();
            if (data.id == id) {
                index = rowIdx;
                return false;
            }
        });
        return index;
    }


    function getRowById(tbl_id, id) {

        var tbl = lstDataTables[tbl_id];
        var row = [];

        if (tbl) {
            tbl.rows().every(function (rowIdx, tableLoop, rowLoop) {

                var data = this.data();
                if (data.id == id) {
                    row = data;
                    return false;
                }
            });
        }

        return row;
    }


    /* find page of record by index */
    function getPageOfRowIndex(tbl, rowIndex) {
        var index = 0;
        tbl.rows().every(function (rowIdx, tableLoop, rowLoop) {

            var data = this.data();
            if (data.id == id) {
                index = rowLoop;
                return false;
            }
        });

        var pageLen = tbl.page.info().length;
        var pageToDisplay = Math.floor(index / pageLen);
        return pageToDisplay;
    }

    /* merge form data and Table data */
    function concatFormAndTableData(frm) {

        var tbl_id = frm.find('table')
              .filter(function () {
                  var attr = $(this).attr('id');
                  return (typeof attr !== typeof undefined && attr !== false)
              }).attr('id')
        var tableData = lstDataTables[tbl_id].$('input').serialize();

        var formData = frm.find('input').not('#' + tbl_id + ' input').serialize();

        formData += '&' + tableData;
        return formData;
    }

    function adjustHeader(tbl_id) {

        var tbl = lstDataTables[tbl_id];
        if (tbl) {
            tbl.columns.adjust();
        }
    }

    function initDatatableChkHeader(chkHeader_id) {

        var chk = $('#' + chkHeader_id);
        chk.unbind();
        chk.click(function (e) {

            e.stopPropagation()
        });

        var col_index = chk.parent().index();
        var tbl_id = chk.parents('.dataTables_wrapper:first').attr('id').replace('_wrapper', '');

        var tbl = lstDataTables[tbl_id];
        if (tbl) {

            tbl.off('page');

            var allPageNodes = tbl.rows().nodes();
            var allPageChk = $(allPageNodes).find('td:eq(' + col_index + ') input[type=checkbox]');
            //allPageChk.off('change');

            chk.on('change', function () {

                var currentPageNodes = tbl.rows({ page: 'current' }).nodes();
                var currentPageChk = $(currentPageNodes).find('td:eq(' + col_index + ') input[type=checkbox]');
                currentPageChk.prop('checked', $(this).is(':checked'));
            });

            function correctHeaderCheckState() {
                var currentPageNodes = tbl.rows({ page: 'current' }).nodes();
                var currentPageChk = $(currentPageNodes).find('td:eq(' + col_index + ') input[type=checkbox]');

                var currentPageChkLen = currentPageChk.length;
                var currentPageCheckedLen = $(currentPageNodes).find('td:eq(' + col_index + ') input[type=checkbox]:checked').length;
                var currentPageUnCheckedLen = currentPageChkLen - currentPageCheckedLen;

                if (currentPageCheckedLen == currentPageChkLen) {
                    chk.prop('indeterminate', false);
                    chk.prop('checked', true);
                } else if (currentPageUnCheckedLen == currentPageChkLen) {
                    chk.prop('indeterminate', false);
                    chk.prop('checked', false);
                } else {
                    chk.prop('indeterminate', true);
                }
            }

            tbl.on('page', correctHeaderCheckState);
            allPageChk.on('change', correctHeaderCheckState);
            correctHeaderCheckState();
        }
    }

    function clearSearchbox(tbl_id) {
        // header search box
        var $searchBox = variables.get('input[type="search"][aria-controls="' + tbl_id + '"]');
        if ($searchBox.val() != '') {

            $searchBox.val('');
            lstDataTables[tbl_id].search('').draw();
        }
        //------------------


        // footer search box
        variables.get('input[data-related="' + tbl_id + '"], input[data-related="' + tbl_id + '"]').each(function () {

            var $input = $(this);

            if ($input.hasClass('_chkFooterSearch') && $input.prop('indeterminate') != true) {

                $input.data('state', 'unchecked');
                $input.trigger('change');
            }
            else if ($input.hasClass('_txtFooterSearch') && $input.val() != '') {
                $input.val('');
                $input.trigger('input');
            }
        });
        //------------------
    }

    return {
        fillDataTable: fillDataTable,
        insertToDataTable: insertToDataTable,
        editDataTable: editDataTable,
        deleteFromDataTable: deleteFromDataTable,
        reloadDataTable: reloadDataTable,
        getRowIndexById: getRowIndexById,
        getPageOfRowIndex: getPageOfRowIndex,
        adjustHeader: adjustHeader,
        concatFormAndTableData: concatFormAndTableData,
        initDatatableChkHeader: initDatatableChkHeader,
        getRowById: getRowById
    }
})();

var enums = {
    UserType: ["دانش آموز", "اولیا دانش آموز", "سازمان دانش آموزی", "ناحیه", "شرکت", "راننده", "مدیر اجرایی", "بازرس"],
    Gender: { "false": "زن", "true": "مرد" },
    IsActive: { "false": "غیر فعال", "true": "فعال" },
    IsStatic: { "false": "متغیر", "true": "ثابت" },
    IsDeleted: { "false": "قطعی", "true": "حذف شده" },
    Nationality: ["ایرانی", "غیر ایرانی"],
    Reason: ["", "تغییرات قیمت دانش آموز", "انصراف و جابجایی", "تغییرات قیمت مدرسه"],
    IsPercent: { "false": "مقداری", "true": "درصدی" },
    ServiceState: ["عادی", "انصراف", "جابجایی بین راننده", "جابجایی بین مدرسه", "جابجایی بین شرکت"],
    SpectorType: { "false": "بازرس", "true": "سر بازرس" },
    QuestionType: ["دو گزینه ای", "تک انتخابی", "چند انتخابی", "عددی", "متنی"],
    FilterType: ["ورودی عدد", "ورودی متن", "انتخابی"],
    CheckStuStatus: { "true": "glyphicon-ok-circle text-success", "false": "glyphicon-remove-circle text-danger" },
    IsIncremental: { "false": "کاهشی", "true": "افزایشی" },
    PaymentResult: {
        5: {
            '-30': "پرداخت قبلاً برگشت خورده است",
            '-4': "اطلاعات پرداخت موجود نمی باشد",//invoice =""
            '-3': "عدم تکمیل عملیات پرداخت، بازگشت مبلغ حداکثر تا 48 ساعت",
            '-2': "خطای ارتباط با درگاه پرداخت",
            '-1': "عدم تکمیل عملیات پرداخت",
            0: "انصراف دارنده کارت",
            100: "پرداخت موفق",
            110: "انصراف دارنده ی کارت",
            120: "موجودی حساب کافی نیست",
            140: "اطلاعات کارت اشتباه است",
            131: "رمز کارت اشتباه است",
            132: "کارت مسدود شده است",
            133: "کارت منقضی شده است",
            130: "زمان مورد نظر به پایان رسیده است",
            150: "خطای داخل بانکی",
            160: "خطا در cvv2 یا تاریخ انقضاء کارت",
            166: "بانک صادر کننده مجوز انجام تراکنش را صادر نکرده است",
            200: "مبلغ مورد نظر بیش از سقف مجاز برای هر تراکنش میباشد",
            201: "مبلغ مورد نظر بیش از سقف مجاز در روز میباشد",
            202: "مبلغ مورد نظر بیش از سقف مجاز در ماه میباشد",
            507: "خطای سیستمی 507 از سمت درگاه پرداخت"
        },
        1: {
            '-6': "عدم تکمیل عملیات پرداخت، بازگشت مبلغ حداکثر تا 48 ساعت",
            '-5': "عدم تکمیل عملیات پرداخت، بازگشت مبلغ حداکثر تا 48 ساعت",
            '-4': "اطلاعات پرداخت موجود نمی باشد",//invoice =""
            '-3': "عدم تکمیل عملیات پرداخت، بازگشت مبلغ حداکثر تا 48 ساعت",
            '-2': "خطای ارتباط با درگاه پرداخت",
            '-1': "عدم تکمیل عملیات پرداخت",
            2: "انصراف دارنده کارت",
            0: "پرداخت موفق",
            100: "پرداخت موفق",
            1029: "خطای ارتباطی با درگاه بانک",
            1: "لطفاً با بانک صادرکننده،تماس حاصل فرمائید!",
            3: "کارت پذیرنده فعال نیست",
            14: "شماره کارت شناخته شده نیست",
            23: "کارت پذیرنده نامعتبر است",
            33: "کارت شما منقضی شده است",
            38: "تعداد دفعات ورود رمز نادرست بیش از حد مجاز است",
            41: "کارت مفقوده می باشد",
            43: "کارت مسروقه می باشد",
            44: "اطلاعات قبض صحیح نیست",
            51: "مبلغ درخواستی از موجودی حساب شما، بیشتر است",
            52: "شماره حساب نامعتبر است",
            54: "تاریخ انقضا کارت سپری شده است",
            55: "رمز کارت صحیح نمی باشد",
            56: "اطلاعات کارت نادرست است",
            57: "دارنده کارت مجاز به انجام این تراکنش نمی باشد",
            61: "مبلغ تراکنش بیش از حدمجاز است",
            62: "کارت محدود شده است",
            65: "تعداد دفعات تراکنش بیشتر از حد مجاز است",
            75: "ورود رمز دوم کارت از حد مجاز بیشتر است",
            78: "کارت غیر فعال می باشد",
            79: "حساب متصل به کارت نامعتبر است",
            92: "صادر کننده کارت معتبر نیست",
            1016: "پرداخت با کارت های شتاب غیرفعال شده است",
            1031: "مهلت زمانی شما جهت پرداخت به پایان رسيده است",
            9006: "تراکنش ناموفق بوده و مبلغ با موفقيت به حساب شما برگشت داده شده است",
        }
    },
};

var myCookie = (function () {

    var setCookie = function (cname, cvalue, exdays) {
        var d = new Date();
        d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
        var expires = "expires=" + d.toUTCString();
        document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
    }

    var getCookie = function (cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) == ' ') {
                c = c.substring(1);
            }
            if (c.indexOf(name) == 0) {
                return c.substring(name.length, c.length);
            }
        }
        return "";
    }

    return {
        setCookie: setCookie,
        getCookie: getCookie
    }
})();

var variables = {
    lstNodes: {},
    get: function (selector) {

        var domNode = this.lstNodes[selector];
        if (domNode) {
            return domNode;
        }
        else {
            this.set(selector);
            return this.lstNodes[selector];
        }
    },
    set: function (selector) {

        this.lstNodes[selector] = $(selector);
    },
    getObject: function (key, callback) {
        var domNode = this.lstNodes[key];
        if (domNode) {
            return domNode;
        }
        else {
            if (!callback) {
                throw key + ' not found!';
            }
            this.setObject(key, callback());
            return this.lstNodes[key];
        }
    },
    setObject: function (key, value) {
        var domNode = this.lstNodes[key];
        this.lstNodes[key] = value;
    }
};

* http://shirazs.ir/JavaScripts/customValidation.js
/// <reference path="jquery-2.2.4.js" />
/// <reference path="myScript.js" />
/// <reference path="jquery.validate.js" />


// national number validaton
jQuery.validator.addMethod("nationalnovalidator",
     function (value, element, param) {

         if (["000000000", "1111111111", "2222222222", "3333333333", "4444444444", 
             "5555555555", "6666666666", "7777777777", "8888888888", "9999999999"]
             .indexOf(value) !== -1) {
             return false;
         }

         var L = value.length;

         if (L == 11) return true;

         if (L < 8 || parseInt(value, 10) == 0) return false;
         value = ('0000' + value).substr(L + 4 - 10);
         if (parseInt(value.substr(3, 6), 10) == 0) return false;
         var c = parseInt(value.substr(9, 1), 10);
         var s = 0;
         for (var i = 0; i < 9; i++)
             s += parseInt(value.substr(i, 1), 10) * (10 - i);
         s = s % 11;
         return (s < 2 && c == s) || (s >= 2 && c == (11 - s));
         return true;
     });

jQuery.validator.unobtrusive.adapters.addBool("nationalnovalidator");

*

* downloads
uberstudent
